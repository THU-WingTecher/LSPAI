[
  {
    "symbolName": "legacyArgs",
    "sourceCode": "func legacyArgs(cmd *Command, args []string) error {\n\t// no subcommand, always take args\n\tif !cmd.HasSubCommands() {\n\t\treturn nil\n\t}\n\n\t// root command with subcommands, do subcommand checking.\n\tif !cmd.HasParent() && len(args) > 0 {\n\t\treturn fmt.Errorf(\"unknown command %q for %q%s\", args[0], cmd.CommandPath(), cmd.findSuggestions(args[0]))\n\t}\n\treturn nil\n}",
    "importString": "",
    "lineNum": 11,
    "relativeDocumentPath": "args.go"
  },
  {
    "symbolName": "OnlyValidArgs",
    "sourceCode": "func OnlyValidArgs(cmd *Command, args []string) error {\n\tif len(cmd.ValidArgs) > 0 {\n\t\t// Remove any description that may be included in ValidArgs.\n\t\t// A description is following a tab character.\n\t\tvalidArgs := make([]string, 0, len(cmd.ValidArgs))\n\t\tfor _, v := range cmd.ValidArgs {\n\t\t\tvalidArgs = append(validArgs, strings.SplitN(v, \"\\t\", 2)[0])\n\t\t}\n\t\tfor _, v := range args {\n\t\t\tif !stringInSlice(v, validArgs) {\n\t\t\t\treturn fmt.Errorf(\"invalid argument %q for %q%s\", v, cmd.CommandPath(), cmd.findSuggestions(args[0]))\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}",
    "importString": "",
    "lineNum": 15,
    "relativeDocumentPath": "args.go"
  },
  {
    "symbolName": "writePreamble",
    "sourceCode": "func writePreamble(buf io.StringWriter, name string) {\n\tWriteStringAndCheck(buf, fmt.Sprintf(\"# bash completion for %-36s -*- shell-script -*-\\n\", name))\n\tWriteStringAndCheck(buf, fmt.Sprintf(`\n__%[1]s_debug()\n{\n    if [[ -n ${BASH_COMP_DEBUG_FILE:-} ]]; then\n        echo \"$*\" >> \"${BASH_COMP_DEBUG_FILE}\"\n    fi\n}\n\n# Homebrew on Macs have version 1.3 of bash-completion which doesn't include\n# _init_completion. This is a very minimal version of that function.\n__%[1]s_init_completion()\n{\n    COMPREPLY=()\n    _get_comp_words_by_ref \"$@\" cur prev words cword\n}\n\n__%[1]s_index_of_word()\n{\n    local w word=$1\n    shift\n    index=0\n    for w in \"$@\"; do\n        [[ $w = \"$word\" ]] && return\n        index=$((index+1))\n    done\n    index=-1\n}\n\n__%[1]s_contains_word()\n{\n    local w word=$1; shift\n    for w in \"$@\"; do\n        [[ $w = \"$word\" ]] && return\n    done\n    return 1\n}\n\n__%[1]s_handle_go_custom_completion()\n{\n    __%[1]s_debug \"${FUNCNAME[0]}: cur is ${cur}, words[*] is ${words[*]}, #words[@] is ${#words[@]}\"\n\n    local shellCompDirectiveError=%[3]d\n    local shellCompDirectiveNoSpace=%[4]d\n    local shellCompDirectiveNoFileComp=%[5]d\n    local shellCompDirectiveFilterFileExt=%[6]d\n    local shellCompDirectiveFilterDirs=%[7]d\n\n    local out requestComp lastParam lastChar comp directive args\n\n    # Prepare the command to request completions for the program.\n    # Calling ${words[0]} instead of directly %[1]s allows handling aliases\n    args=(\"${words[@]:1}\")\n    # Disable ActiveHelp which is not supported for bash completion v1\n    requestComp=\"%[8]s=0 ${words[0]} %[2]s ${args[*]}\"\n\n    lastParam=${words[$((${#words[@]}-1))]}\n    lastChar=${lastParam:$((${#lastParam}-1)):1}\n    __%[1]s_debug \"${FUNCNAME[0]}: lastParam ${lastParam}, lastChar ${lastChar}\"\n\n    if [ -z \"${cur}\" ] && [ \"${lastChar}\" != \"=\" ]; then\n        # If the last parameter is complete (there is a space following it)\n        # We add an extra empty parameter so we can indicate this to the go method.\n        __%[1]s_debug \"${FUNCNAME[0]}: Adding extra empty parameter\"\n        requestComp=\"${requestComp} \\\"\\\"\"\n    fi\n\n    __%[1]s_debug \"${FUNCNAME[0]}: calling ${requestComp}\"\n    # Use eval to handle any environment variables and such\n    out=$(eval \"${requestComp}\" 2>/dev/null)\n\n    # Extract the directive integer at the very end of the output following a colon (:)\n    directive=${out##*:}\n    # Remove the directive\n    out=${out%%:*}\n    if [ \"${directive}\" = \"${out}\" ]; then\n        # There is not directive specified\n        directive=0\n    fi\n    __%[1]s_debug \"${FUNCNAME[0]}: the completion directive is: ${directive}\"\n    __%[1]s_debug \"${FUNCNAME[0]}: the completions are: ${out}\"\n\n    if [ $((directive & shellCompDirectiveError)) -ne 0 ]; then\n        # Error code.  No completion.\n        __%[1]s_debug \"${FUNCNAME[0]}: received error from custom completion go code\"\n        return\n    else\n        if [ $((directive & shellCompDirectiveNoSpace)) -ne 0 ]; then\n            if [[ $(type -t compopt) = \"builtin\" ]]; then\n                __%[1]s_debug \"${FUNCNAME[0]}: activating no space\"\n                compopt -o nospace\n            fi\n        fi\n        if [ $((directive & shellCompDirectiveNoFileComp)) -ne 0 ]; then\n            if [[ $(type -t compopt) = \"builtin\" ]]; then\n                __%[1]s_debug \"${FUNCNAME[0]}: activating no file completion\"\n                compopt +o default\n            fi\n        fi\n    fi\n\n    if [ $((directive & shellCompDirectiveFilterFileExt)) -ne 0 ]; then\n        # File extension filtering\n        local fullFilter filter filteringCmd\n        # Do not use quotes around the $out variable or else newline\n        # characters will be kept.\n        for filter in ${out}; do\n            fullFilter+=\"$filter|\"\n        done\n\n        filteringCmd=\"_filedir $fullFilter\"\n        __%[1]s_debug \"File filtering command: $filteringCmd\"\n        $filteringCmd\n    elif [ $((directive & shellCompDirectiveFilterDirs)) -ne 0 ]; then\n        # File completion for directories only\n        local subdir\n        # Use printf to strip any trailing newline\n        subdir=$(printf \"%%s\" \"${out}\")\n        if [ -n \"$subdir\" ]; then\n            __%[1]s_debug \"Listing directories in $subdir\"\n            __%[1]s_handle_subdirs_in_dir_flag \"$subdir\"\n        else\n            __%[1]s_debug \"Listing directories in .\"\n            _filedir -d\n        fi\n    else\n        while IFS='' read -r comp; do\n            COMPREPLY+=(\"$comp\")\n        done < <(compgen -W \"${out}\" -- \"$cur\")\n    fi\n}\n\n__%[1]s_handle_reply()\n{\n    __%[1]s_debug \"${FUNCNAME[0]}\"\n    local comp\n    case $cur in\n        -*)\n            if [[ $(type -t compopt) = \"builtin\" ]]; then\n                compopt -o nospace\n            fi\n            local allflags\n            if [ ${#must_have_one_flag[@]} -ne 0 ]; then\n                allflags=(\"${must_have_one_flag[@]}\")\n            else\n                allflags=(\"${flags[*]} ${two_word_flags[*]}\")\n            fi\n            while IFS='' read -r comp; do\n                COMPREPLY+=(\"$comp\")\n            done < <(compgen -W \"${allflags[*]}\" -- \"$cur\")\n            if [[ $(type -t compopt) = \"builtin\" ]]; then\n                [[ \"${COMPREPLY[0]}\" == *= ]] || compopt +o nospace\n            fi\n\n            # complete after --flag=abc\n            if [[ $cur == *=* ]]; then\n                if [[ $(type -t compopt) = \"builtin\" ]]; then\n                    compopt +o nospace\n                fi\n\n                local index flag\n                flag=\"${cur%%=*}\"\n                __%[1]s_index_of_word \"${flag}\" \"${flags_with_completion[@]}\"\n                COMPREPLY=()\n                if [[ ${index} -ge 0 ]]; then\n                    PREFIX=\"\"\n                    cur=\"${cur#*=}\"\n                    ${flags_completion[${index}]}\n                    if [ -n \"${ZSH_VERSION:-}\" ]; then\n                        # zsh completion needs --flag= prefix\n                        eval \"COMPREPLY=( \\\"\\${COMPREPLY[@]/#/${flag}=}\\\" )\"\n                    fi\n                fi\n            fi\n\n            if [[ -z \"${flag_parsing_disabled}\" ]]; then\n                # If flag parsing is enabled, we have completed the flags and can return.\n                # If flag parsing is disabled, we may not know all (or any) of the flags, so we fallthrough\n                # to possibly call handle_go_custom_completion.\n                return 0;\n            fi\n            ;;\n    esac\n\n    # check if we are handling a flag with special work handling\n    local index\n    __%[1]s_index_of_word \"${prev}\" \"${flags_with_completion[@]}\"\n    if [[ ${index} -ge 0 ]]; then\n        ${flags_completion[${index}]}\n        return\n    fi\n\n    # we are parsing a flag and don't have a special handler, no completion\n    if [[ ${cur} != \"${words[cword]}\" ]]; then\n        return\n    fi\n\n    local completions\n    completions=(\"${commands[@]}\")\n    if [[ ${#must_have_one_noun[@]} -ne 0 ]]; then\n        completions+=(\"${must_have_one_noun[@]}\")\n    elif [[ -n \"${has_completion_function}\" ]]; then\n        # if a go completion function is provided, defer to that function\n        __%[1]s_handle_go_custom_completion\n    fi\n    if [[ ${#must_have_one_flag[@]} -ne 0 ]]; then\n        completions+=(\"${must_have_one_flag[@]}\")\n    fi\n    while IFS='' read -r comp; do\n        COMPREPLY+=(\"$comp\")\n    done < <(compgen -W \"${completions[*]}\" -- \"$cur\")\n\n    if [[ ${#COMPREPLY[@]} -eq 0 && ${#noun_aliases[@]} -gt 0 && ${#must_have_one_noun[@]} -ne 0 ]]; then\n        while IFS='' read -r comp; do\n            COMPREPLY+=(\"$comp\")\n        done < <(compgen -W \"${noun_aliases[*]}\" -- \"$cur\")\n    fi\n\n    if [[ ${#COMPREPLY[@]} -eq 0 ]]; then\n        if declare -F __%[1]s_custom_func >/dev/null; then\n            # try command name qualified custom func\n            __%[1]s_custom_func\n        else\n            # otherwise fall back to unqualified for compatibility\n            declare -F __custom_func >/dev/null && __custom_func\n        fi\n    fi\n\n    # available in bash-completion >= 2, not always present on macOS\n    if declare -F __ltrim_colon_completions >/dev/null; then\n        __ltrim_colon_completions \"$cur\"\n    fi\n\n    # If there is only 1 completion and it is a flag with an = it will be completed\n    # but we don't want a space after the =\n    if [[ \"${#COMPREPLY[@]}\" -eq \"1\" ]] && [[ $(type -t compopt) = \"builtin\" ]] && [[ \"${COMPREPLY[0]}\" == --*= ]]; then\n       compopt -o nospace\n    fi\n}\n\n# The arguments should be in the form \"ext1|ext2|extn\"\n__%[1]s_handle_filename_extension_flag()\n{\n    local ext=\"$1\"\n    _filedir \"@(${ext})\"\n}\n\n__%[1]s_handle_subdirs_in_dir_flag()\n{\n    local dir=\"$1\"\n    pushd \"${dir}\" >/dev/null 2>&1 && _filedir -d && popd >/dev/null 2>&1 || return\n}\n\n__%[1]s_handle_flag()\n{\n    __%[1]s_debug \"${FUNCNAME[0]}: c is $c words[c] is ${words[c]}\"\n\n    # if a command required a flag, and we found it, unset must_have_one_flag()\n    local flagname=${words[c]}\n    local flagvalue=\"\"\n    # if the word contained an =\n    if [[ ${words[c]} == *\"=\"* ]]; then\n        flagvalue=${flagname#*=} # take in as flagvalue after the =\n        flagname=${flagname%%=*} # strip everything after the =\n        flagname=\"${flagname}=\" # but put the = back\n    fi\n    __%[1]s_debug \"${FUNCNAME[0]}: looking for ${flagname}\"\n    if __%[1]s_contains_word \"${flagname}\" \"${must_have_one_flag[@]}\"; then\n        must_have_one_flag=()\n    fi\n\n    # if you set a flag which only applies to this command, don't show subcommands\n    if __%[1]s_contains_word \"${flagname}\" \"${local_nonpersistent_flags[@]}\"; then\n      commands=()\n    fi\n\n    # keep flag value with flagname as flaghash\n    # flaghash variable is an associative array which is only supported in bash > 3.\n    if [[ -z \"${BASH_VERSION:-}\" || \"${BASH_VERSINFO[0]:-}\" -gt 3 ]]; then\n        if [ -n \"${flagvalue}\" ] ; then\n            flaghash[${flagname}]=${flagvalue}\n        elif [ -n \"${words[ $((c+1)) ]}\" ] ; then\n            flaghash[${flagname}]=${words[ $((c+1)) ]}\n        else\n            flaghash[${flagname}]=\"true\" # pad \"true\" for bool flag\n        fi\n    fi\n\n    # skip the argument to a two word flag\n    if [[ ${words[c]} != *\"=\"* ]] && __%[1]s_contains_word \"${words[c]}\" \"${two_word_flags[@]}\"; then\n        __%[1]s_debug \"${FUNCNAME[0]}: found a flag ${words[c]}, skip the next argument\"\n        c=$((c+1))\n        # if we are looking for a flags value, don't show commands\n        if [[ $c -eq $cword ]]; then\n            commands=()\n        fi\n    fi\n\n    c=$((c+1))\n\n}\n\n__%[1]s_handle_noun()\n{\n    __%[1]s_debug \"${FUNCNAME[0]}: c is $c words[c] is ${words[c]}\"\n\n    if __%[1]s_contains_word \"${words[c]}\" \"${must_have_one_noun[@]}\"; then\n        must_have_one_noun=()\n    elif __%[1]s_contains_word \"${words[c]}\" \"${noun_aliases[@]}\"; then\n        must_have_one_noun=()\n    fi\n\n    nouns+=(\"${words[c]}\")\n    c=$((c+1))\n}\n\n__%[1]s_handle_command()\n{\n    __%[1]s_debug \"${FUNCNAME[0]}: c is $c words[c] is ${words[c]}\"\n\n    local next_command\n    if [[ -n ${last_command} ]]; then\n        next_command=\"_${last_command}_${words[c]//:/__}\"\n    else\n        if [[ $c -eq 0 ]]; then\n            next_command=\"_%[1]s_root_command\"\n        else\n            next_command=\"_${words[c]//:/__}\"\n        fi\n    fi\n    c=$((c+1))\n    __%[1]s_debug \"${FUNCNAME[0]}: looking for ${next_command}\"\n    declare -F \"$next_command\" >/dev/null && $next_command\n}\n\n__%[1]s_handle_word()\n{\n    if [[ $c -ge $cword ]]; then\n        __%[1]s_handle_reply\n        return\n    fi\n    __%[1]s_debug \"${FUNCNAME[0]}: c is $c words[c] is ${words[c]}\"\n    if [[ \"${words[c]}\" == -* ]]; then\n        __%[1]s_handle_flag\n    elif __%[1]s_contains_word \"${words[c]}\" \"${commands[@]}\"; then\n        __%[1]s_handle_command\n    elif [[ $c -eq 0 ]]; then\n        __%[1]s_handle_command\n    elif __%[1]s_contains_word \"${words[c]}\" \"${command_aliases[@]}\"; then\n        # aliashash variable is an associative array which is only supported in bash > 3.\n        if [[ -z \"${BASH_VERSION:-}\" || \"${BASH_VERSINFO[0]:-}\" -gt 3 ]]; then\n            words[c]=${aliashash[${words[c]}]}\n            __%[1]s_handle_command\n        else\n            __%[1]s_handle_noun\n        fi\n    else\n        __%[1]s_handle_noun\n    fi\n    __%[1]s_handle_word\n}\n\n`, name, ShellCompNoDescRequestCmd,\n\t\tShellCompDirectiveError, ShellCompDirectiveNoSpace, ShellCompDirectiveNoFileComp,\n\t\tShellCompDirectiveFilterFileExt, ShellCompDirectiveFilterDirs, activeHelpEnvVar(name)))\n}",
    "importString": "",
    "lineNum": 366,
    "relativeDocumentPath": "bash_completions.go"
  },
  {
    "symbolName": "writePostscript",
    "sourceCode": "func writePostscript(buf io.StringWriter, name string) {\n\tname = strings.ReplaceAll(name, \":\", \"__\")\n\tWriteStringAndCheck(buf, fmt.Sprintf(\"__start_%s()\\n\", name))\n\tWriteStringAndCheck(buf, fmt.Sprintf(`{\n    local cur prev words cword split\n    declare -A flaghash 2>/dev/null || :\n    declare -A aliashash 2>/dev/null || :\n    if declare -F _init_completion >/dev/null 2>&1; then\n        _init_completion -s || return\n    else\n        __%[1]s_init_completion -n \"=\" || return\n    fi\n\n    local c=0\n    local flag_parsing_disabled=\n    local flags=()\n    local two_word_flags=()\n    local local_nonpersistent_flags=()\n    local flags_with_completion=()\n    local flags_completion=()\n    local commands=(\"%[1]s\")\n    local command_aliases=()\n    local must_have_one_flag=()\n    local must_have_one_noun=()\n    local has_completion_function=\"\"\n    local last_command=\"\"\n    local nouns=()\n    local noun_aliases=()\n\n    __%[1]s_handle_word\n}\n\n`, name))\n\tWriteStringAndCheck(buf, fmt.Sprintf(`if [[ $(type -t compopt) = \"builtin\" ]]; then\n    complete -o default -F __start_%s %s\nelse\n    complete -o default -o nospace -F __start_%s %s\nfi\n\n`, name, name, name, name))\n\tWriteStringAndCheck(buf, \"# ex: ts=4 sw=4 et filetype=sh\\n\")\n}",
    "importString": "",
    "lineNum": 41,
    "relativeDocumentPath": "bash_completions.go"
  },
  {
    "symbolName": "writeCommands",
    "sourceCode": "func writeCommands(buf io.StringWriter, cmd *Command) {\n\tWriteStringAndCheck(buf, \"    commands=()\\n\")\n\tfor _, c := range cmd.Commands() {\n\t\tif !c.IsAvailableCommand() && c != cmd.helpCommand {\n\t\t\tcontinue\n\t\t}\n\t\tWriteStringAndCheck(buf, fmt.Sprintf(\"    commands+=(%q)\\n\", c.Name()))\n\t\twriteCmdAliases(buf, c)\n\t}\n\tWriteStringAndCheck(buf, \"\\n\")\n}",
    "importString": "",
    "lineNum": 10,
    "relativeDocumentPath": "bash_completions.go"
  },
  {
    "symbolName": "writeFlagHandler",
    "sourceCode": "func writeFlagHandler(buf io.StringWriter, name string, annotations map[string][]string, cmd *Command) {\n\tfor key, value := range annotations {\n\t\tswitch key {\n\t\tcase BashCompFilenameExt:\n\t\t\tWriteStringAndCheck(buf, fmt.Sprintf(\"    flags_with_completion+=(%q)\\n\", name))\n\n\t\t\tvar ext string\n\t\t\tif len(value) > 0 {\n\t\t\t\text = fmt.Sprintf(\"__%s_handle_filename_extension_flag \", cmd.Root().Name()) + strings.Join(value, \"|\")\n\t\t\t} else {\n\t\t\t\text = \"_filedir\"\n\t\t\t}\n\t\t\tWriteStringAndCheck(buf, fmt.Sprintf(\"    flags_completion+=(%q)\\n\", ext))\n\t\tcase BashCompCustom:\n\t\t\tWriteStringAndCheck(buf, fmt.Sprintf(\"    flags_with_completion+=(%q)\\n\", name))\n\n\t\t\tif len(value) > 0 {\n\t\t\t\thandlers := strings.Join(value, \"; \")\n\t\t\t\tWriteStringAndCheck(buf, fmt.Sprintf(\"    flags_completion+=(%q)\\n\", handlers))\n\t\t\t} else {\n\t\t\t\tWriteStringAndCheck(buf, \"    flags_completion+=(:)\\n\")\n\t\t\t}\n\t\tcase BashCompSubdirsInDir:\n\t\t\tWriteStringAndCheck(buf, fmt.Sprintf(\"    flags_with_completion+=(%q)\\n\", name))\n\n\t\t\tvar ext string\n\t\t\tif len(value) == 1 {\n\t\t\t\text = fmt.Sprintf(\"__%s_handle_subdirs_in_dir_flag \", cmd.Root().Name()) + value[0]\n\t\t\t} else {\n\t\t\t\text = \"_filedir -d\"\n\t\t\t}\n\t\t\tWriteStringAndCheck(buf, fmt.Sprintf(\"    flags_completion+=(%q)\\n\", ext))\n\t\t}\n\t}\n}",
    "importString": "",
    "lineNum": 34,
    "relativeDocumentPath": "bash_completions.go"
  },
  {
    "symbolName": "writeFlag",
    "sourceCode": "func writeFlag(buf io.StringWriter, flag *pflag.Flag, cmd *Command) {\n\tname := flag.Name\n\tformat := \"    flags+=(\\\"--%s\"\n\tif len(flag.NoOptDefVal) == 0 {\n\t\tformat += \"=\"\n\t}\n\tformat += cbn\n\tWriteStringAndCheck(buf, fmt.Sprintf(format, name))\n\tif len(flag.NoOptDefVal) == 0 {\n\t\tformat = \"    two_word_flags+=(\\\"--%s\" + cbn\n\t\tWriteStringAndCheck(buf, fmt.Sprintf(format, name))\n\t}\n\twriteFlagHandler(buf, \"--\"+name, flag.Annotations, cmd)\n}",
    "importString": "",
    "lineNum": 13,
    "relativeDocumentPath": "bash_completions.go"
  },
  {
    "symbolName": "writeLocalNonPersistentFlag",
    "sourceCode": "func writeLocalNonPersistentFlag(buf io.StringWriter, flag *pflag.Flag) {\n\tname := flag.Name\n\tformat := \"    local_nonpersistent_flags+=(\\\"--%[1]s\" + cbn\n\tif len(flag.NoOptDefVal) == 0 {\n\t\tformat += \"    local_nonpersistent_flags+=(\\\"--%[1]s=\" + cbn\n\t}\n\tWriteStringAndCheck(buf, fmt.Sprintf(format, name))\n\tif len(flag.Shorthand) > 0 {\n\t\tWriteStringAndCheck(buf, fmt.Sprintf(\"    local_nonpersistent_flags+=(\\\"-%s\\\")\\n\", flag.Shorthand))\n\t}\n}",
    "importString": "",
    "lineNum": 10,
    "relativeDocumentPath": "bash_completions.go"
  },
  {
    "symbolName": "prepareCustomAnnotationsForFlags",
    "sourceCode": "func prepareCustomAnnotationsForFlags(cmd *Command) {\n\tflagCompletionMutex.RLock()\n\tdefer flagCompletionMutex.RUnlock()\n\tfor flag := range flagCompletionFunctions {\n\t\t// Make sure the completion script calls the __*_go_custom_completion function for\n\t\t// every registered flag.  We need to do this here (and not when the flag was registered\n\t\t// for completion) so that we can know the root command name for the prefix\n\t\t// of __<prefix>_go_custom_completion\n\t\tif flag.Annotations == nil {\n\t\t\tflag.Annotations = map[string][]string{}\n\t\t}\n\t\tflag.Annotations[BashCompCustom] = []string{fmt.Sprintf(\"__%[1]s_handle_go_custom_completion\", cmd.Root().Name())}\n\t}\n}",
    "importString": "",
    "lineNum": 13,
    "relativeDocumentPath": "bash_completions.go"
  },
  {
    "symbolName": "writeFlags",
    "sourceCode": "func writeFlags(buf io.StringWriter, cmd *Command) {\n\tprepareCustomAnnotationsForFlags(cmd)\n\tWriteStringAndCheck(buf, `    flags=()\n    two_word_flags=()\n    local_nonpersistent_flags=()\n    flags_with_completion=()\n    flags_completion=()\n\n`)\n\n\tif cmd.DisableFlagParsing {\n\t\tWriteStringAndCheck(buf, \"    flag_parsing_disabled=1\\n\")\n\t}\n\n\tlocalNonPersistentFlags := cmd.LocalNonPersistentFlags()\n\tcmd.NonInheritedFlags().VisitAll(func(flag *pflag.Flag) {\n\t\tif nonCompletableFlag(flag) {\n\t\t\treturn\n\t\t}\n\t\twriteFlag(buf, flag, cmd)\n\t\tif len(flag.Shorthand) > 0 {\n\t\t\twriteShortFlag(buf, flag, cmd)\n\t\t}\n\t\t// localNonPersistentFlags are used to stop the completion of subcommands when one is set\n\t\t// if TraverseChildren is true we should allow to complete subcommands\n\t\tif localNonPersistentFlags.Lookup(flag.Name) != nil && !cmd.Root().TraverseChildren {\n\t\t\twriteLocalNonPersistentFlag(buf, flag)\n\t\t}\n\t})\n\tcmd.InheritedFlags().VisitAll(func(flag *pflag.Flag) {\n\t\tif nonCompletableFlag(flag) {\n\t\t\treturn\n\t\t}\n\t\twriteFlag(buf, flag, cmd)\n\t\tif len(flag.Shorthand) > 0 {\n\t\t\twriteShortFlag(buf, flag, cmd)\n\t\t}\n\t})\n\n\tWriteStringAndCheck(buf, \"\\n\")\n}",
    "importString": "",
    "lineNum": 40,
    "relativeDocumentPath": "bash_completions.go"
  },
  {
    "symbolName": "writeRequiredFlag",
    "sourceCode": "func writeRequiredFlag(buf io.StringWriter, cmd *Command) {\n\tWriteStringAndCheck(buf, \"    must_have_one_flag=()\\n\")\n\tflags := cmd.NonInheritedFlags()\n\tflags.VisitAll(func(flag *pflag.Flag) {\n\t\tif nonCompletableFlag(flag) {\n\t\t\treturn\n\t\t}\n\t\tif _, ok := flag.Annotations[BashCompOneRequiredFlag]; ok {\n\t\t\tformat := \"    must_have_one_flag+=(\\\"--%s\"\n\t\t\tif flag.Value.Type() != \"bool\" {\n\t\t\t\tformat += \"=\"\n\t\t\t}\n\t\t\tformat += cbn\n\t\t\tWriteStringAndCheck(buf, fmt.Sprintf(format, flag.Name))\n\n\t\t\tif len(flag.Shorthand) > 0 {\n\t\t\t\tWriteStringAndCheck(buf, fmt.Sprintf(\"    must_have_one_flag+=(\\\"-%s\"+cbn, flag.Shorthand))\n\t\t\t}\n\t\t}\n\t})\n}",
    "importString": "",
    "lineNum": 20,
    "relativeDocumentPath": "bash_completions.go"
  },
  {
    "symbolName": "writeRequiredNouns",
    "sourceCode": "func writeRequiredNouns(buf io.StringWriter, cmd *Command) {\n\tWriteStringAndCheck(buf, \"    must_have_one_noun=()\\n\")\n\tsort.Strings(cmd.ValidArgs)\n\tfor _, value := range cmd.ValidArgs {\n\t\t// Remove any description that may be included following a tab character.\n\t\t// Descriptions are not supported by bash completion.\n\t\tvalue = strings.SplitN(value, \"\\t\", 2)[0]\n\t\tWriteStringAndCheck(buf, fmt.Sprintf(\"    must_have_one_noun+=(%q)\\n\", value))\n\t}\n\tif cmd.ValidArgsFunction != nil {\n\t\tWriteStringAndCheck(buf, \"    has_completion_function=1\\n\")\n\t}\n}",
    "importString": "",
    "lineNum": 12,
    "relativeDocumentPath": "bash_completions.go"
  },
  {
    "symbolName": "writeCmdAliases",
    "sourceCode": "func writeCmdAliases(buf io.StringWriter, cmd *Command) {\n\tif len(cmd.Aliases) == 0 {\n\t\treturn\n\t}\n\n\tsort.Strings(cmd.Aliases)\n\n\tWriteStringAndCheck(buf, fmt.Sprint(`    if [[ -z \"${BASH_VERSION:-}\" || \"${BASH_VERSINFO[0]:-}\" -gt 3 ]]; then`, \"\\n\"))\n\tfor _, value := range cmd.Aliases {\n\t\tWriteStringAndCheck(buf, fmt.Sprintf(\"        command_aliases+=(%q)\\n\", value))\n\t\tWriteStringAndCheck(buf, fmt.Sprintf(\"        aliashash[%q]=%q\\n\", value, cmd.Name()))\n\t}\n\tWriteStringAndCheck(buf, `    fi`)\n\tWriteStringAndCheck(buf, \"\\n\")\n}",
    "importString": "",
    "lineNum": 14,
    "relativeDocumentPath": "bash_completions.go"
  },
  {
    "symbolName": "gen",
    "sourceCode": "func gen(buf io.StringWriter, cmd *Command) {\n\tfor _, c := range cmd.Commands() {\n\t\tif !c.IsAvailableCommand() && c != cmd.helpCommand {\n\t\t\tcontinue\n\t\t}\n\t\tgen(buf, c)\n\t}\n\tcommandName := cmd.CommandPath()\n\tcommandName = strings.ReplaceAll(commandName, \" \", \"_\")\n\tcommandName = strings.ReplaceAll(commandName, \":\", \"__\")\n\n\tif cmd.Root() == cmd {\n\t\tWriteStringAndCheck(buf, fmt.Sprintf(\"_%s_root_command()\\n{\\n\", commandName))\n\t} else {\n\t\tWriteStringAndCheck(buf, fmt.Sprintf(\"_%s()\\n{\\n\", commandName))\n\t}\n\n\tWriteStringAndCheck(buf, fmt.Sprintf(\"    last_command=%q\\n\", commandName))\n\tWriteStringAndCheck(buf, \"\\n\")\n\tWriteStringAndCheck(buf, \"    command_aliases=()\\n\")\n\tWriteStringAndCheck(buf, \"\\n\")\n\n\twriteCommands(buf, cmd)\n\twriteFlags(buf, cmd)\n\twriteRequiredFlag(buf, cmd)\n\twriteRequiredNouns(buf, cmd)\n\twriteArgAliases(buf, cmd)\n\tWriteStringAndCheck(buf, \"}\\n\\n\")\n}",
    "importString": "",
    "lineNum": 28,
    "relativeDocumentPath": "bash_completions.go"
  },
  {
    "symbolName": "(*Command).GenBashCompletion",
    "sourceCode": "func (c *Command) GenBashCompletion(w io.Writer) error {\n\tbuf := new(bytes.Buffer)\n\twritePreamble(buf, c.Name())\n\tif len(c.BashCompletionFunction) > 0 {\n\t\tbuf.WriteString(c.BashCompletionFunction + \"\\n\")\n\t}\n\tgen(buf, c)\n\twritePostscript(buf, c.Name())\n\n\t_, err := buf.WriteTo(w)\n\treturn err\n}",
    "importString": "",
    "lineNum": 11,
    "relativeDocumentPath": "bash_completions.go"
  },
  {
    "symbolName": "genBashComp",
    "sourceCode": "func genBashComp(buf io.StringWriter, name string, includeDesc bool) {\n\tcompCmd := ShellCompRequestCmd\n\tif !includeDesc {\n\t\tcompCmd = ShellCompNoDescRequestCmd\n\t}\n\n\tWriteStringAndCheck(buf, fmt.Sprintf(`# bash completion V2 for %-36[1]s -*- shell-script -*-\n\n__%[1]s_debug()\n{\n    if [[ -n ${BASH_COMP_DEBUG_FILE-} ]]; then\n        echo \"$*\" >> \"${BASH_COMP_DEBUG_FILE}\"\n    fi\n}\n\n# Macs have bash3 for which the bash-completion package doesn't include\n# _init_completion. This is a minimal version of that function.\n__%[1]s_init_completion()\n{\n    COMPREPLY=()\n    _get_comp_words_by_ref \"$@\" cur prev words cword\n}\n\n# This function calls the %[1]s program to obtain the completion\n# results and the directive.  It fills the 'out' and 'directive' vars.\n__%[1]s_get_completion_results() {\n    local requestComp lastParam lastChar args\n\n    # Prepare the command to request completions for the program.\n    # Calling ${words[0]} instead of directly %[1]s allows handling aliases\n    args=(\"${words[@]:1}\")\n    requestComp=\"${words[0]} %[2]s ${args[*]}\"\n\n    lastParam=${words[$((${#words[@]}-1))]}\n    lastChar=${lastParam:$((${#lastParam}-1)):1}\n    __%[1]s_debug \"lastParam ${lastParam}, lastChar ${lastChar}\"\n\n    if [[ -z ${cur} && ${lastChar} != = ]]; then\n        # If the last parameter is complete (there is a space following it)\n        # We add an extra empty parameter so we can indicate this to the go method.\n        __%[1]s_debug \"Adding extra empty parameter\"\n        requestComp=\"${requestComp} ''\"\n    fi\n\n    # When completing a flag with an = (e.g., %[1]s -n=<TAB>)\n    # bash focuses on the part after the =, so we need to remove\n    # the flag part from $cur\n    if [[ ${cur} == -*=* ]]; then\n        cur=\"${cur#*=}\"\n    fi\n\n    __%[1]s_debug \"Calling ${requestComp}\"\n    # Use eval to handle any environment variables and such\n    out=$(eval \"${requestComp}\" 2>/dev/null)\n\n    # Extract the directive integer at the very end of the output following a colon (:)\n    directive=${out##*:}\n    # Remove the directive\n    out=${out%%:*}\n    if [[ ${directive} == \"${out}\" ]]; then\n        # There is not directive specified\n        directive=0\n    fi\n    __%[1]s_debug \"The completion directive is: ${directive}\"\n    __%[1]s_debug \"The completions are: ${out}\"\n}\n\n__%[1]s_process_completion_results() {\n    local shellCompDirectiveError=%[3]d\n    local shellCompDirectiveNoSpace=%[4]d\n    local shellCompDirectiveNoFileComp=%[5]d\n    local shellCompDirectiveFilterFileExt=%[6]d\n    local shellCompDirectiveFilterDirs=%[7]d\n    local shellCompDirectiveKeepOrder=%[8]d\n\n    if (((directive & shellCompDirectiveError) != 0)); then\n        # Error code.  No completion.\n        __%[1]s_debug \"Received error from custom completion go code\"\n        return\n    else\n        if (((directive & shellCompDirectiveNoSpace) != 0)); then\n            if [[ $(type -t compopt) == builtin ]]; then\n                __%[1]s_debug \"Activating no space\"\n                compopt -o nospace\n            else\n                __%[1]s_debug \"No space directive not supported in this version of bash\"\n            fi\n        fi\n        if (((directive & shellCompDirectiveKeepOrder) != 0)); then\n            if [[ $(type -t compopt) == builtin ]]; then\n                # no sort isn't supported for bash less than < 4.4\n                if [[ ${BASH_VERSINFO[0]} -lt 4 || ( ${BASH_VERSINFO[0]} -eq 4 && ${BASH_VERSINFO[1]} -lt 4 ) ]]; then\n                    __%[1]s_debug \"No sort directive not supported in this version of bash\"\n                else\n                    __%[1]s_debug \"Activating keep order\"\n                    compopt -o nosort\n                fi\n            else\n                __%[1]s_debug \"No sort directive not supported in this version of bash\"\n            fi\n        fi\n        if (((directive & shellCompDirectiveNoFileComp) != 0)); then\n            if [[ $(type -t compopt) == builtin ]]; then\n                __%[1]s_debug \"Activating no file completion\"\n                compopt +o default\n            else\n                __%[1]s_debug \"No file completion directive not supported in this version of bash\"\n            fi\n        fi\n    fi\n\n    # Separate activeHelp from normal completions\n    local completions=()\n    local activeHelp=()\n    __%[1]s_extract_activeHelp\n\n    if (((directive & shellCompDirectiveFilterFileExt) != 0)); then\n        # File extension filtering\n        local fullFilter=\"\" filter filteringCmd\n\n        # Do not use quotes around the $completions variable or else newline\n        # characters will be kept.\n        for filter in ${completions[*]}; do\n            fullFilter+=\"$filter|\"\n        done\n\n        filteringCmd=\"_filedir $fullFilter\"\n        __%[1]s_debug \"File filtering command: $filteringCmd\"\n        $filteringCmd\n    elif (((directive & shellCompDirectiveFilterDirs) != 0)); then\n        # File completion for directories only\n\n        local subdir\n        subdir=${completions[0]}\n        if [[ -n $subdir ]]; then\n            __%[1]s_debug \"Listing directories in $subdir\"\n            pushd \"$subdir\" >/dev/null 2>&1 && _filedir -d && popd >/dev/null 2>&1 || return\n        else\n            __%[1]s_debug \"Listing directories in .\"\n            _filedir -d\n        fi\n    else\n        __%[1]s_handle_completion_types\n    fi\n\n    __%[1]s_handle_special_char \"$cur\" :\n    __%[1]s_handle_special_char \"$cur\" =\n\n    # Print the activeHelp statements before we finish\n    __%[1]s_handle_activeHelp\n}\n\n__%[1]s_handle_activeHelp() {\n    # Print the activeHelp statements\n    if ((${#activeHelp[*]} != 0)); then\n        if [ -z $COMP_TYPE ]; then\n            # Bash v3 does not set the COMP_TYPE variable.\n            printf \"\\n\";\n            printf \"%%s\\n\" \"${activeHelp[@]}\"\n            printf \"\\n\"\n            __%[1]s_reprint_commandLine\n            return\n        fi\n\n        # Only print ActiveHelp on the second TAB press\n        if [ $COMP_TYPE -eq 63 ]; then\n            printf \"\\n\"\n            printf \"%%s\\n\" \"${activeHelp[@]}\"\n\n            if ((${#COMPREPLY[*]} == 0)); then\n                # When there are no completion choices from the program, file completion\n                # may kick in if the program has not disabled it; in such a case, we want\n                # to know if any files will match what the user typed, so that we know if\n                # there will be completions presented, so that we know how to handle ActiveHelp.\n                # To find out, we actually trigger the file completion ourselves;\n                # the call to _filedir will fill COMPREPLY if files match.\n                if (((directive & shellCompDirectiveNoFileComp) == 0)); then\n                    __%[1]s_debug \"Listing files\"\n                    _filedir\n                fi\n            fi\n\n            if ((${#COMPREPLY[*]} != 0)); then\n                # If there are completion choices to be shown, print a delimiter.\n                # Re-printing the command-line will automatically be done\n                # by the shell when it prints the completion choices.\n                printf -- \"--\"\n            else\n                # When there are no completion choices at all, we need\n                # to re-print the command-line since the shell will\n                # not be doing it itself.\n                __%[1]s_reprint_commandLine\n            fi\n        elif [ $COMP_TYPE -eq 37 ] || [ $COMP_TYPE -eq 42 ]; then\n            # For completion type: menu-complete/menu-complete-backward and insert-completions\n            # the completions are immediately inserted into the command-line, so we first\n            # print the activeHelp message and reprint the command-line since the shell won't.\n            printf \"\\n\"\n            printf \"%%s\\n\" \"${activeHelp[@]}\"\n\n            __%[1]s_reprint_commandLine\n        fi\n    fi\n}\n\n__%[1]s_reprint_commandLine() {\n    # The prompt format is only available from bash 4.4.\n    # We test if it is available before using it.\n    if (x=${PS1@P}) 2> /dev/null; then\n        printf \"%%s\" \"${PS1@P}${COMP_LINE[@]}\"\n    else\n        # Can't print the prompt.  Just print the\n        # text the user had typed, it is workable enough.\n        printf \"%%s\" \"${COMP_LINE[@]}\"\n    fi\n}\n\n# Separate activeHelp lines from real completions.\n# Fills the $activeHelp and $completions arrays.\n__%[1]s_extract_activeHelp() {\n    local activeHelpMarker=\"%[9]s\"\n    local endIndex=${#activeHelpMarker}\n\n    while IFS='' read -r comp; do\n        [[ -z $comp ]] && continue\n\n        if [[ ${comp:0:endIndex} == $activeHelpMarker ]]; then\n            comp=${comp:endIndex}\n            __%[1]s_debug \"ActiveHelp found: $comp\"\n            if [[ -n $comp ]]; then\n                activeHelp+=(\"$comp\")\n            fi\n        else\n            # Not an activeHelp line but a normal completion\n            completions+=(\"$comp\")\n        fi\n    done <<<\"${out}\"\n}\n\n__%[1]s_handle_completion_types() {\n    __%[1]s_debug \"__%[1]s_handle_completion_types: COMP_TYPE is $COMP_TYPE\"\n\n    case $COMP_TYPE in\n    37|42)\n        # Type: menu-complete/menu-complete-backward and insert-completions\n        # If the user requested inserting one completion at a time, or all\n        # completions at once on the command-line we must remove the descriptions.\n        # https://github.com/spf13/cobra/issues/1508\n\n        # If there are no completions, we don't need to do anything\n        (( ${#completions[@]} == 0 )) && return 0\n\n        local tab=$'\\t'\n\n        # Strip any description and escape the completion to handled special characters\n        IFS=$'\\n' read -ra completions -d '' < <(printf \"%%q\\n\" \"${completions[@]%%%%$tab*}\")\n\n        # Only consider the completions that match\n        IFS=$'\\n' read -ra COMPREPLY -d '' < <(IFS=$'\\n'; compgen -W \"${completions[*]}\" -- \"${cur}\")\n\n        # compgen looses the escaping so we need to escape all completions again since they will\n        # all be inserted on the command-line.\n        IFS=$'\\n' read -ra COMPREPLY -d '' < <(printf \"%%q\\n\" \"${COMPREPLY[@]}\")\n        ;;\n\n    *)\n        # Type: complete (normal completion)\n        __%[1]s_handle_standard_completion_case\n        ;;\n    esac\n}\n\n__%[1]s_handle_standard_completion_case() {\n    local tab=$'\\t'\n\n    # If there are no completions, we don't need to do anything\n    (( ${#completions[@]} == 0 )) && return 0\n\n    # Short circuit to optimize if we don't have descriptions\n    if [[ \"${completions[*]}\" != *$tab* ]]; then\n        # First, escape the completions to handle special characters\n        IFS=$'\\n' read -ra completions -d '' < <(printf \"%%q\\n\" \"${completions[@]}\")\n        # Only consider the completions that match what the user typed\n        IFS=$'\\n' read -ra COMPREPLY -d '' < <(IFS=$'\\n'; compgen -W \"${completions[*]}\" -- \"${cur}\")\n\n        # compgen looses the escaping so, if there is only a single completion, we need to\n        # escape it again because it will be inserted on the command-line.  If there are multiple\n        # completions, we don't want to escape them because they will be printed in a list\n        # and we don't want to show escape characters in that list.\n        if (( ${#COMPREPLY[@]} == 1 )); then\n            COMPREPLY[0]=$(printf \"%%q\" \"${COMPREPLY[0]}\")\n        fi\n        return 0\n    fi\n\n    local longest=0\n    local compline\n    # Look for the longest completion so that we can format things nicely\n    while IFS='' read -r compline; do\n        [[ -z $compline ]] && continue\n\n        # Before checking if the completion matches what the user typed,\n        # we need to strip any description and escape the completion to handle special\n        # characters because those escape characters are part of what the user typed.\n        # Don't call \"printf\" in a sub-shell because it will be much slower\n        # since we are in a loop.\n        printf -v comp \"%%q\" \"${compline%%%%$tab*}\" &>/dev/null || comp=$(printf \"%%q\" \"${compline%%%%$tab*}\")\n\n        # Only consider the completions that match\n        [[ $comp == \"$cur\"* ]] || continue\n\n        # The completions matches.  Add it to the list of full completions including\n        # its description.  We don't escape the completion because it may get printed\n        # in a list if there are more than one and we don't want show escape characters\n        # in that list.\n        COMPREPLY+=(\"$compline\")\n\n        # Strip any description before checking the length, and again, don't escape\n        # the completion because this length is only used when printing the completions\n        # in a list and we don't want show escape characters in that list.\n        comp=${compline%%%%$tab*}\n        if ((${#comp}>longest)); then\n            longest=${#comp}\n        fi\n    done < <(printf \"%%s\\n\" \"${completions[@]}\")\n\n    # If there is a single completion left, remove the description text and escape any special characters\n    if ((${#COMPREPLY[*]} == 1)); then\n        __%[1]s_debug \"COMPREPLY[0]: ${COMPREPLY[0]}\"\n        COMPREPLY[0]=$(printf \"%%q\" \"${COMPREPLY[0]%%%%$tab*}\")\n        __%[1]s_debug \"Removed description from single completion, which is now: ${COMPREPLY[0]}\"\n    else\n        # Format the descriptions\n        __%[1]s_format_comp_descriptions $longest\n    fi\n}\n\n__%[1]s_handle_special_char()\n{\n    local comp=\"$1\"\n    local char=$2\n    if [[ \"$comp\" == *${char}* && \"$COMP_WORDBREAKS\" == *${char}* ]]; then\n        local word=${comp%%\"${comp##*${char}}\"}\n        local idx=${#COMPREPLY[*]}\n        while ((--idx >= 0)); do\n            COMPREPLY[idx]=${COMPREPLY[idx]#\"$word\"}\n        done\n    fi\n}\n\n__%[1]s_format_comp_descriptions()\n{\n    local tab=$'\\t'\n    local comp desc maxdesclength\n    local longest=$1\n\n    local i ci\n    for ci in ${!COMPREPLY[*]}; do\n        comp=${COMPREPLY[ci]}\n        # Properly format the description string which follows a tab character if there is one\n        if [[ \"$comp\" == *$tab* ]]; then\n            __%[1]s_debug \"Original comp: $comp\"\n            desc=${comp#*$tab}\n            comp=${comp%%%%$tab*}\n\n            # $COLUMNS stores the current shell width.\n            # Remove an extra 4 because we add 2 spaces and 2 parentheses.\n            maxdesclength=$(( COLUMNS - longest - 4 ))\n\n            # Make sure we can fit a description of at least 8 characters\n            # if we are to align the descriptions.\n            if ((maxdesclength > 8)); then\n                # Add the proper number of spaces to align the descriptions\n                for ((i = ${#comp} ; i < longest ; i++)); do\n                    comp+=\" \"\n                done\n            else\n                # Don't pad the descriptions so we can fit more text after the completion\n                maxdesclength=$(( COLUMNS - ${#comp} - 4 ))\n            fi\n\n            # If there is enough space for any description text,\n            # truncate the descriptions that are too long for the shell width\n            if ((maxdesclength > 0)); then\n                if ((${#desc} > maxdesclength)); then\n                    desc=${desc:0:$(( maxdesclength - 1 ))}\n                    desc+=\"…\"\n                fi\n                comp+=\"  ($desc)\"\n            fi\n            COMPREPLY[ci]=$comp\n            __%[1]s_debug \"Final comp: $comp\"\n        fi\n    done\n}\n\n__start_%[1]s()\n{\n    local cur prev words cword split\n\n    COMPREPLY=()\n\n    # Call _init_completion from the bash-completion package\n    # to prepare the arguments properly\n    if declare -F _init_completion >/dev/null 2>&1; then\n        _init_completion -n =: || return\n    else\n        __%[1]s_init_completion -n =: || return\n    fi\n\n    __%[1]s_debug\n    __%[1]s_debug \"========= starting completion logic ==========\"\n    __%[1]s_debug \"cur is ${cur}, words[*] is ${words[*]}, #words[@] is ${#words[@]}, cword is $cword\"\n\n    # The user could have moved the cursor backwards on the command-line.\n    # We need to trigger completion from the $cword location, so we need\n    # to truncate the command-line ($words) up to the $cword location.\n    words=(\"${words[@]:0:$cword+1}\")\n    __%[1]s_debug \"Truncated words[*]: ${words[*]},\"\n\n    local out directive\n    __%[1]s_get_completion_results\n    __%[1]s_process_completion_results\n}\n\nif [[ $(type -t compopt) = \"builtin\" ]]; then\n    complete -o default -F __start_%[1]s %[1]s\nelse\n    complete -o default -o nospace -F __start_%[1]s %[1]s\nfi\n\n# ex: ts=4 sw=4 et filetype=sh\n`, name, compCmd,\n\t\tShellCompDirectiveError, ShellCompDirectiveNoSpace, ShellCompDirectiveNoFileComp,\n\t\tShellCompDirectiveFilterFileExt, ShellCompDirectiveFilterDirs, ShellCompDirectiveKeepOrder,\n\t\tactiveHelpMarker))\n}",
    "importString": "",
    "lineNum": 436,
    "relativeDocumentPath": "bash_completionsV2.go"
  },
  {
    "symbolName": "Gt",
    "sourceCode": "func Gt(a interface{}, b interface{}) bool {\n\tvar left, right int64\n\tav := reflect.ValueOf(a)\n\n\tswitch av.Kind() {\n\tcase reflect.Array, reflect.Chan, reflect.Map, reflect.Slice:\n\t\tleft = int64(av.Len())\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\tleft = av.Int()\n\tcase reflect.String:\n\t\tleft, _ = strconv.ParseInt(av.String(), 10, 64)\n\t}\n\n\tbv := reflect.ValueOf(b)\n\n\tswitch bv.Kind() {\n\tcase reflect.Array, reflect.Chan, reflect.Map, reflect.Slice:\n\t\tright = int64(bv.Len())\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\tright = bv.Int()\n\tcase reflect.String:\n\t\tright, _ = strconv.ParseInt(bv.String(), 10, 64)\n\t}\n\n\treturn left > right\n}",
    "importString": "",
    "lineNum": 25,
    "relativeDocumentPath": "cobra.go"
  },
  {
    "symbolName": "Eq",
    "sourceCode": "func Eq(a interface{}, b interface{}) bool {\n\tav := reflect.ValueOf(a)\n\tbv := reflect.ValueOf(b)\n\n\tswitch av.Kind() {\n\tcase reflect.Array, reflect.Chan, reflect.Map, reflect.Slice:\n\t\tpanic(\"Eq called on unsupported type\")\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn av.Int() == bv.Int()\n\tcase reflect.String:\n\t\treturn av.String() == bv.String()\n\t}\n\treturn false\n}",
    "importString": "",
    "lineNum": 13,
    "relativeDocumentPath": "cobra.go"
  },
  {
    "symbolName": "tmpl",
    "sourceCode": "func tmpl(text string) *tmplFunc {\n\treturn &tmplFunc{\n\t\ttmpl: text,\n\t\tfn: func(w io.Writer, data interface{}) error {\n\t\t\tt := template.New(\"top\")\n\t\t\tt.Funcs(templateFuncs)\n\t\t\ttemplate.Must(t.Parse(text))\n\t\t\treturn t.Execute(w, data)\n\t\t},\n\t}\n}",
    "importString": "",
    "lineNum": 10,
    "relativeDocumentPath": "cobra.go"
  },
  {
    "symbolName": "ld",
    "sourceCode": "func ld(s, t string, ignoreCase bool) int {\n\tif ignoreCase {\n\t\ts = strings.ToLower(s)\n\t\tt = strings.ToLower(t)\n\t}\n\td := make([][]int, len(s)+1)\n\tfor i := range d {\n\t\td[i] = make([]int, len(t)+1)\n\t\td[i][0] = i\n\t}\n\tfor j := range d[0] {\n\t\td[0][j] = j\n\t}\n\tfor j := 1; j <= len(t); j++ {\n\t\tfor i := 1; i <= len(s); i++ {\n\t\t\tif s[i-1] == t[j-1] {\n\t\t\t\td[i][j] = d[i-1][j-1]\n\t\t\t} else {\n\t\t\t\tmin := d[i-1][j]\n\t\t\t\tif d[i][j-1] < min {\n\t\t\t\t\tmin = d[i][j-1]\n\t\t\t\t}\n\t\t\t\tif d[i-1][j-1] < min {\n\t\t\t\t\tmin = d[i-1][j-1]\n\t\t\t\t}\n\t\t\t\td[i][j] = min + 1\n\t\t\t}\n\t\t}\n\n\t}\n\treturn d[len(s)][len(t)]\n}",
    "importString": "",
    "lineNum": 31,
    "relativeDocumentPath": "cobra.go"
  },
  {
    "symbolName": "(*Command).UsageFunc",
    "sourceCode": "func (c *Command) UsageFunc() (f func(*Command) error) {\n\tif c.usageFunc != nil {\n\t\treturn c.usageFunc\n\t}\n\tif c.HasParent() {\n\t\treturn c.Parent().UsageFunc()\n\t}\n\treturn func(c *Command) error {\n\t\tc.mergePersistentFlags()\n\t\tfn := c.getUsageTemplateFunc()\n\t\terr := fn(c.OutOrStderr(), c)\n\t\tif err != nil {\n\t\t\tc.PrintErrln(err)\n\t\t}\n\t\treturn err\n\t}\n}",
    "importString": "",
    "lineNum": 16,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "(*Command).HelpFunc",
    "sourceCode": "func (c *Command) HelpFunc() func(*Command, []string) {\n\tif c.helpFunc != nil {\n\t\treturn c.helpFunc\n\t}\n\tif c.HasParent() {\n\t\treturn c.Parent().HelpFunc()\n\t}\n\treturn func(c *Command, a []string) {\n\t\tc.mergePersistentFlags()\n\t\tfn := c.getHelpTemplateFunc()\n\t\t// The help should be sent to stdout\n\t\t// See https://github.com/spf13/cobra/issues/1002\n\t\terr := fn(c.OutOrStdout(), c)\n\t\tif err != nil {\n\t\t\tc.PrintErrln(err)\n\t\t}\n\t}\n}",
    "importString": "",
    "lineNum": 17,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "(*Command).getHelpTemplateFunc",
    "sourceCode": "func (c *Command) getHelpTemplateFunc() func(w io.Writer, data interface{}) error {\n\tif c.helpTemplate != nil {\n\t\treturn c.helpTemplate.fn\n\t}\n\n\tif c.HasParent() {\n\t\treturn c.parent.getHelpTemplateFunc()\n\t}\n\n\treturn defaultHelpFunc\n}",
    "importString": "",
    "lineNum": 10,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "(*Command).UsageString",
    "sourceCode": "func (c *Command) UsageString() string {\n\t// Storing normal writers\n\ttmpOutput := c.outWriter\n\ttmpErr := c.errWriter\n\n\tbb := new(bytes.Buffer)\n\tc.outWriter = bb\n\tc.errWriter = bb\n\n\tCheckErr(c.Usage())\n\n\t// Setting things back to normal\n\tc.outWriter = tmpOutput\n\tc.errWriter = tmpErr\n\n\treturn bb.String()\n}",
    "importString": "",
    "lineNum": 16,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "(*Command).FlagErrorFunc",
    "sourceCode": "func (c *Command) FlagErrorFunc() (f func(*Command, error) error) {\n\tif c.flagErrorFunc != nil {\n\t\treturn c.flagErrorFunc\n\t}\n\n\tif c.HasParent() {\n\t\treturn c.parent.FlagErrorFunc()\n\t}\n\treturn func(c *Command, err error) error {\n\t\treturn err\n\t}\n}",
    "importString": "",
    "lineNum": 11,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "shortHasNoOptDefVal",
    "sourceCode": "func shortHasNoOptDefVal(name string, fs *flag.FlagSet) bool {\n\tif len(name) == 0 {\n\t\treturn false\n\t}\n\n\tflag := fs.ShorthandLookup(name[:1])\n\tif flag == nil {\n\t\treturn false\n\t}\n\treturn flag.NoOptDefVal != \"\"\n}",
    "importString": "",
    "lineNum": 10,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "stripFlags",
    "sourceCode": "func stripFlags(args []string, c *Command) []string {\n\tif len(args) == 0 {\n\t\treturn args\n\t}\n\tc.mergePersistentFlags()\n\n\tcommands := []string{}\n\tflags := c.Flags()\n\nLoop:\n\tfor len(args) > 0 {\n\t\ts := args[0]\n\t\targs = args[1:]\n\t\tswitch {\n\t\tcase s == \"--\":\n\t\t\t// \"--\" terminates the flags\n\t\t\tbreak Loop\n\t\tcase strings.HasPrefix(s, \"--\") && !strings.Contains(s, \"=\") && !hasNoOptDefVal(s[2:], flags):\n\t\t\t// If '--flag arg' then\n\t\t\t// delete arg from args.\n\t\t\tfallthrough // (do the same as below)\n\t\tcase strings.HasPrefix(s, \"-\") && !strings.Contains(s, \"=\") && len(s) == 2 && !shortHasNoOptDefVal(s[1:], flags):\n\t\t\t// If '-f arg' then\n\t\t\t// delete 'arg' from args or break the loop if len(args) <= 1.\n\t\t\tif len(args) <= 1 {\n\t\t\t\tbreak Loop\n\t\t\t} else {\n\t\t\t\targs = args[1:]\n\t\t\t\tcontinue\n\t\t\t}\n\t\tcase s != \"\" && !strings.HasPrefix(s, \"-\"):\n\t\t\tcommands = append(commands, s)\n\t\t}\n\t}\n\n\treturn commands\n}",
    "importString": "",
    "lineNum": 36,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "(*Command).argsMinusFirstX",
    "sourceCode": "func (c *Command) argsMinusFirstX(args []string, x string) []string {\n\tif len(args) == 0 {\n\t\treturn args\n\t}\n\tc.mergePersistentFlags()\n\tflags := c.Flags()\n\nLoop:\n\tfor pos := 0; pos < len(args); pos++ {\n\t\ts := args[pos]\n\t\tswitch {\n\t\tcase s == \"--\":\n\t\t\t// -- means we have reached the end of the parseable args. Break out of the loop now.\n\t\t\tbreak Loop\n\t\tcase strings.HasPrefix(s, \"--\") && !strings.Contains(s, \"=\") && !hasNoOptDefVal(s[2:], flags):\n\t\t\tfallthrough\n\t\tcase strings.HasPrefix(s, \"-\") && !strings.Contains(s, \"=\") && len(s) == 2 && !shortHasNoOptDefVal(s[1:], flags):\n\t\t\t// This is a flag without a default value, and an equal sign is not used. Increment pos in order to skip\n\t\t\t// over the next arg, because that is the value of this flag.\n\t\t\tpos++\n\t\t\tcontinue\n\t\tcase !strings.HasPrefix(s, \"-\"):\n\t\t\t// This is not a flag or a flag value. Check to see if it matches what we're looking for, and if so,\n\t\t\t// return the args, excluding the one at this position.\n\t\t\tif s == x {\n\t\t\t\tret := make([]string, 0, len(args)-1)\n\t\t\t\tret = append(ret, args[:pos]...)\n\t\t\t\tret = append(ret, args[pos+1:]...)\n\t\t\t\treturn ret\n\t\t\t}\n\t\t}\n\t}\n\treturn args\n}",
    "importString": "",
    "lineNum": 33,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "(*Command).Find",
    "sourceCode": "func (c *Command) Find(args []string) (*Command, []string, error) {\n\tvar innerfind func(*Command, []string) (*Command, []string)\n\n\tinnerfind = func(c *Command, innerArgs []string) (*Command, []string) {\n\t\targsWOflags := stripFlags(innerArgs, c)\n\t\tif len(argsWOflags) == 0 {\n\t\t\treturn c, innerArgs\n\t\t}\n\t\tnextSubCmd := argsWOflags[0]\n\n\t\tcmd := c.findNext(nextSubCmd)\n\t\tif cmd != nil {\n\t\t\treturn innerfind(cmd, c.argsMinusFirstX(innerArgs, nextSubCmd))\n\t\t}\n\t\treturn c, innerArgs\n\t}\n\n\tcommandFound, a := innerfind(c, args)\n\tif commandFound.Args == nil {\n\t\treturn commandFound, a, legacyArgs(commandFound, stripFlags(a, commandFound))\n\t}\n\treturn commandFound, a, nil\n}",
    "importString": "",
    "lineNum": 22,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "(*Command).findSuggestions",
    "sourceCode": "func (c *Command) findSuggestions(arg string) string {\n\tif c.DisableSuggestions {\n\t\treturn \"\"\n\t}\n\tif c.SuggestionsMinimumDistance <= 0 {\n\t\tc.SuggestionsMinimumDistance = 2\n\t}\n\tvar sb strings.Builder\n\tif suggestions := c.SuggestionsFor(arg); len(suggestions) > 0 {\n\t\tsb.WriteString(\"\\n\\nDid you mean this?\\n\")\n\t\tfor _, s := range suggestions {\n\t\t\t_, _ = fmt.Fprintf(&sb, \"\\t%v\\n\", s)\n\t\t}\n\t}\n\treturn sb.String()\n}",
    "importString": "",
    "lineNum": 15,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "(*Command).findNext",
    "sourceCode": "func (c *Command) findNext(next string) *Command {\n\tmatches := make([]*Command, 0)\n\tfor _, cmd := range c.commands {\n\t\tif commandNameMatches(cmd.Name(), next) || cmd.HasAlias(next) {\n\t\t\tcmd.commandCalledAs.name = next\n\t\t\treturn cmd\n\t\t}\n\t\tif EnablePrefixMatching && cmd.hasNameOrAliasPrefix(next) {\n\t\t\tmatches = append(matches, cmd)\n\t\t}\n\t}\n\n\tif len(matches) == 1 {\n\t\t// Temporarily disable gosec G602, which produces a false positive.\n\t\t// See https://github.com/securego/gosec/issues/1005.\n\t\treturn matches[0] // #nosec G602\n\t}\n\n\treturn nil\n}",
    "importString": "",
    "lineNum": 19,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "(*Command).Traverse",
    "sourceCode": "func (c *Command) Traverse(args []string) (*Command, []string, error) {\n\tflags := []string{}\n\tinFlag := false\n\n\tfor i, arg := range args {\n\t\tswitch {\n\t\t// A long flag with a space separated value\n\t\tcase strings.HasPrefix(arg, \"--\") && !strings.Contains(arg, \"=\"):\n\t\t\t// TODO: this isn't quite right, we should really check ahead for 'true' or 'false'\n\t\t\tinFlag = !hasNoOptDefVal(arg[2:], c.Flags())\n\t\t\tflags = append(flags, arg)\n\t\t\tcontinue\n\t\t// A short flag with a space separated value\n\t\tcase strings.HasPrefix(arg, \"-\") && !strings.Contains(arg, \"=\") && len(arg) == 2 && !shortHasNoOptDefVal(arg[1:], c.Flags()):\n\t\t\tinFlag = true\n\t\t\tflags = append(flags, arg)\n\t\t\tcontinue\n\t\t// The value for a flag\n\t\tcase inFlag:\n\t\t\tinFlag = false\n\t\t\tflags = append(flags, arg)\n\t\t\tcontinue\n\t\t// A flag without a value, or with an `=` separated value\n\t\tcase isFlagArg(arg):\n\t\t\tflags = append(flags, arg)\n\t\t\tcontinue\n\t\t}\n\n\t\tcmd := c.findNext(arg)\n\t\tif cmd == nil {\n\t\t\treturn c, args, nil\n\t\t}\n\n\t\tif err := c.ParseFlags(flags); err != nil {\n\t\t\treturn nil, args, err\n\t\t}\n\t\treturn cmd.Traverse(args[i+1:])\n\t}\n\treturn c, args, nil\n}",
    "importString": "",
    "lineNum": 39,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "(*Command).SuggestionsFor",
    "sourceCode": "func (c *Command) SuggestionsFor(typedName string) []string {\n\tsuggestions := []string{}\n\tfor _, cmd := range c.commands {\n\t\tif cmd.IsAvailableCommand() {\n\t\t\tlevenshteinDistance := ld(typedName, cmd.Name(), true)\n\t\t\tsuggestByLevenshtein := levenshteinDistance <= c.SuggestionsMinimumDistance\n\t\t\tsuggestByPrefix := strings.HasPrefix(strings.ToLower(cmd.Name()), strings.ToLower(typedName))\n\t\t\tif suggestByLevenshtein || suggestByPrefix {\n\t\t\t\tsuggestions = append(suggestions, cmd.Name())\n\t\t\t}\n\t\t\tfor _, explicitSuggestion := range cmd.SuggestFor {\n\t\t\t\tif strings.EqualFold(typedName, explicitSuggestion) {\n\t\t\t\t\tsuggestions = append(suggestions, cmd.Name())\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn suggestions\n}",
    "importString": "",
    "lineNum": 18,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "(*Command).execute",
    "sourceCode": "func (c *Command) execute(a []string) (err error) {\n\tif c == nil {\n\t\treturn fmt.Errorf(\"called Execute() on a nil Command\")\n\t}\n\n\tif len(c.Deprecated) > 0 {\n\t\tc.Printf(\"Command %q is deprecated, %s\\n\", c.Name(), c.Deprecated)\n\t}\n\n\t// initialize help and version flag at the last point possible to allow for user\n\t// overriding\n\tc.InitDefaultHelpFlag()\n\tc.InitDefaultVersionFlag()\n\n\terr = c.ParseFlags(a)\n\tif err != nil {\n\t\treturn c.FlagErrorFunc()(c, err)\n\t}\n\n\t// If help is called, regardless of other flags, return we want help.\n\t// Also say we need help if the command isn't runnable.\n\thelpVal, err := c.Flags().GetBool(helpFlagName)\n\tif err != nil {\n\t\t// should be impossible to get here as we always declare a help\n\t\t// flag in InitDefaultHelpFlag()\n\t\tc.Println(\"\\\"help\\\" flag declared as non-bool. Please correct your code\")\n\t\treturn err\n\t}\n\n\tif helpVal {\n\t\treturn flag.ErrHelp\n\t}\n\n\t// for back-compat, only add version flag behavior if version is defined\n\tif c.Version != \"\" {\n\t\tversionVal, err := c.Flags().GetBool(\"version\")\n\t\tif err != nil {\n\t\t\tc.Println(\"\\\"version\\\" flag declared as non-bool. Please correct your code\")\n\t\t\treturn err\n\t\t}\n\t\tif versionVal {\n\t\t\tfn := c.getVersionTemplateFunc()\n\t\t\terr := fn(c.OutOrStdout(), c)\n\t\t\tif err != nil {\n\t\t\t\tc.Println(err)\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif !c.Runnable() {\n\t\treturn flag.ErrHelp\n\t}\n\n\tc.preRun()\n\n\tdefer c.postRun()\n\n\targWoFlags := c.Flags().Args()\n\tif c.DisableFlagParsing {\n\t\targWoFlags = a\n\t}\n\n\tif err := c.ValidateArgs(argWoFlags); err != nil {\n\t\treturn err\n\t}\n\n\tparents := make([]*Command, 0, 5)\n\tfor p := c; p != nil; p = p.Parent() {\n\t\tif EnableTraverseRunHooks {\n\t\t\t// When EnableTraverseRunHooks is set:\n\t\t\t// - Execute all persistent pre-runs from the root parent till this command.\n\t\t\t// - Execute all persistent post-runs from this command till the root parent.\n\t\t\tparents = append([]*Command{p}, parents...)\n\t\t} else {\n\t\t\t// Otherwise, execute only the first found persistent hook.\n\t\t\tparents = append(parents, p)\n\t\t}\n\t}\n\tfor _, p := range parents {\n\t\tif p.PersistentPreRunE != nil {\n\t\t\tif err := p.PersistentPreRunE(c, argWoFlags); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif !EnableTraverseRunHooks {\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else if p.PersistentPreRun != nil {\n\t\t\tp.PersistentPreRun(c, argWoFlags)\n\t\t\tif !EnableTraverseRunHooks {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\tif c.PreRunE != nil {\n\t\tif err := c.PreRunE(c, argWoFlags); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else if c.PreRun != nil {\n\t\tc.PreRun(c, argWoFlags)\n\t}\n\n\tif err := c.ValidateRequiredFlags(); err != nil {\n\t\treturn err\n\t}\n\tif err := c.ValidateFlagGroups(); err != nil {\n\t\treturn err\n\t}\n\n\tif c.RunE != nil {\n\t\tif err := c.RunE(c, argWoFlags); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tc.Run(c, argWoFlags)\n\t}\n\tif c.PostRunE != nil {\n\t\tif err := c.PostRunE(c, argWoFlags); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else if c.PostRun != nil {\n\t\tc.PostRun(c, argWoFlags)\n\t}\n\tfor p := c; p != nil; p = p.Parent() {\n\t\tif p.PersistentPostRunE != nil {\n\t\t\tif err := p.PersistentPostRunE(c, argWoFlags); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif !EnableTraverseRunHooks {\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else if p.PersistentPostRun != nil {\n\t\t\tp.PersistentPostRun(c, argWoFlags)\n\t\t\tif !EnableTraverseRunHooks {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}",
    "importString": "",
    "lineNum": 140,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "(*Command).ExecuteC",
    "sourceCode": "func (c *Command) ExecuteC() (cmd *Command, err error) {\n\tif c.ctx == nil {\n\t\tc.ctx = context.Background()\n\t}\n\n\t// Regardless of what command execute is called on, run on Root only\n\tif c.HasParent() {\n\t\treturn c.Root().ExecuteC()\n\t}\n\n\t// windows hook\n\tif preExecHookFn != nil {\n\t\tpreExecHookFn(c)\n\t}\n\n\t// initialize help at the last point to allow for user overriding\n\tc.InitDefaultHelpCmd()\n\n\targs := c.args\n\n\t// Workaround FAIL with \"go test -v\" or \"cobra.test -test.v\", see #155\n\tif c.args == nil && filepath.Base(os.Args[0]) != \"cobra.test\" {\n\t\targs = os.Args[1:]\n\t}\n\n\t// initialize the __complete command to be used for shell completion\n\tc.initCompleteCmd(args)\n\n\t// initialize the default completion command\n\tc.InitDefaultCompletionCmd(args...)\n\n\t// Now that all commands have been created, let's make sure all groups\n\t// are properly created also\n\tc.checkCommandGroups()\n\n\tvar flags []string\n\tif c.TraverseChildren {\n\t\tcmd, flags, err = c.Traverse(args)\n\t} else {\n\t\tcmd, flags, err = c.Find(args)\n\t}\n\tif err != nil {\n\t\t// If found parse to a subcommand and then failed, talk about the subcommand\n\t\tif cmd != nil {\n\t\t\tc = cmd\n\t\t}\n\t\tif !c.SilenceErrors {\n\t\t\tc.PrintErrln(c.ErrPrefix(), err.Error())\n\t\t\tc.PrintErrf(\"Run '%v --help' for usage.\\n\", c.CommandPath())\n\t\t}\n\t\treturn c, err\n\t}\n\n\tcmd.commandCalledAs.called = true\n\tif cmd.commandCalledAs.name == \"\" {\n\t\tcmd.commandCalledAs.name = cmd.Name()\n\t}\n\n\t// We have to pass global context to children command\n\t// if context is present on the parent command.\n\tif cmd.ctx == nil {\n\t\tcmd.ctx = c.ctx\n\t}\n\n\terr = cmd.execute(flags)\n\tif err != nil {\n\t\t// Always show help if requested, even if SilenceErrors is in\n\t\t// effect\n\t\tif errors.Is(err, flag.ErrHelp) {\n\t\t\tcmd.HelpFunc()(cmd, args)\n\t\t\treturn cmd, nil\n\t\t}\n\n\t\t// If root command has SilenceErrors flagged,\n\t\t// all subcommands should respect it\n\t\tif !cmd.SilenceErrors && !c.SilenceErrors {\n\t\t\tc.PrintErrln(cmd.ErrPrefix(), err.Error())\n\t\t}\n\n\t\t// If root command has SilenceUsage flagged,\n\t\t// all subcommands should respect it\n\t\tif !cmd.SilenceUsage && !c.SilenceUsage {\n\t\t\tc.Println(cmd.UsageString())\n\t\t}\n\t}\n\treturn cmd, err\n}",
    "importString": "",
    "lineNum": 86,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "(*Command).ValidateRequiredFlags",
    "sourceCode": "func (c *Command) ValidateRequiredFlags() error {\n\tif c.DisableFlagParsing {\n\t\treturn nil\n\t}\n\n\tflags := c.Flags()\n\tmissingFlagNames := []string{}\n\tflags.VisitAll(func(pflag *flag.Flag) {\n\t\trequiredAnnotation, found := pflag.Annotations[BashCompOneRequiredFlag]\n\t\tif !found {\n\t\t\treturn\n\t\t}\n\t\tif (requiredAnnotation[0] == \"true\") && !pflag.Changed {\n\t\t\tmissingFlagNames = append(missingFlagNames, pflag.Name)\n\t\t}\n\t})\n\n\tif len(missingFlagNames) > 0 {\n\t\treturn fmt.Errorf(`required flag(s) \"%s\" not set`, strings.Join(missingFlagNames, `\", \"`))\n\t}\n\treturn nil\n}",
    "importString": "",
    "lineNum": 21,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "(*Command).InitDefaultHelpFlag",
    "sourceCode": "func (c *Command) InitDefaultHelpFlag() {\n\tc.mergePersistentFlags()\n\tif c.Flags().Lookup(helpFlagName) == nil {\n\t\tusage := \"help for \"\n\t\tname := c.DisplayName()\n\t\tif name == \"\" {\n\t\t\tusage += \"this command\"\n\t\t} else {\n\t\t\tusage += name\n\t\t}\n\t\tc.Flags().BoolP(helpFlagName, \"h\", false, usage)\n\t\t_ = c.Flags().SetAnnotation(helpFlagName, FlagSetByCobraAnnotation, []string{\"true\"})\n\t}\n}",
    "importString": "",
    "lineNum": 13,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "(*Command).InitDefaultVersionFlag",
    "sourceCode": "func (c *Command) InitDefaultVersionFlag() {\n\tif c.Version == \"\" {\n\t\treturn\n\t}\n\n\tc.mergePersistentFlags()\n\tif c.Flags().Lookup(\"version\") == nil {\n\t\tusage := \"version for \"\n\t\tif c.Name() == \"\" {\n\t\t\tusage += \"this command\"\n\t\t} else {\n\t\t\tusage += c.DisplayName()\n\t\t}\n\t\tif c.Flags().ShorthandLookup(\"v\") == nil {\n\t\t\tc.Flags().BoolP(\"version\", \"v\", false, usage)\n\t\t} else {\n\t\t\tc.Flags().Bool(\"version\", false, usage)\n\t\t}\n\t\t_ = c.Flags().SetAnnotation(\"version\", FlagSetByCobraAnnotation, []string{\"true\"})\n\t}\n}",
    "importString": "",
    "lineNum": 20,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "(*Command).InitDefaultHelpCmd",
    "sourceCode": "func (c *Command) InitDefaultHelpCmd() {\n\tif !c.HasSubCommands() {\n\t\treturn\n\t}\n\n\tif c.helpCommand == nil {\n\t\tc.helpCommand = &Command{\n\t\t\tUse:   \"help [command]\",\n\t\t\tShort: \"Help about any command\",\n\t\t\tLong: `Help provides help for any command in the application.\nSimply type ` + c.DisplayName() + ` help [path to command] for full details.`,\n\t\t\tValidArgsFunction: func(c *Command, args []string, toComplete string) ([]Completion, ShellCompDirective) {\n\t\t\t\tvar completions []Completion\n\t\t\t\tcmd, _, e := c.Root().Find(args)\n\t\t\t\tif e != nil {\n\t\t\t\t\treturn nil, ShellCompDirectiveNoFileComp\n\t\t\t\t}\n\t\t\t\tif cmd == nil {\n\t\t\t\t\t// Root help command.\n\t\t\t\t\tcmd = c.Root()\n\t\t\t\t}\n\t\t\t\tfor _, subCmd := range cmd.Commands() {\n\t\t\t\t\tif subCmd.IsAvailableCommand() || subCmd == cmd.helpCommand {\n\t\t\t\t\t\tif strings.HasPrefix(subCmd.Name(), toComplete) {\n\t\t\t\t\t\t\tcompletions = append(completions, CompletionWithDesc(subCmd.Name(), subCmd.Short))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn completions, ShellCompDirectiveNoFileComp\n\t\t\t},\n\t\t\tRun: func(c *Command, args []string) {\n\t\t\t\tcmd, _, e := c.Root().Find(args)\n\t\t\t\tif cmd == nil || e != nil {\n\t\t\t\t\tc.Printf(\"Unknown help topic %#q\\n\", args)\n\t\t\t\t\tCheckErr(c.Root().Usage())\n\t\t\t\t} else {\n\t\t\t\t\t// FLow the context down to be used in help text\n\t\t\t\t\tif cmd.ctx == nil {\n\t\t\t\t\t\tcmd.ctx = c.ctx\n\t\t\t\t\t}\n\n\t\t\t\t\tcmd.InitDefaultHelpFlag()    // make possible 'help' flag to be shown\n\t\t\t\t\tcmd.InitDefaultVersionFlag() // make possible 'version' flag to be shown\n\t\t\t\t\tCheckErr(cmd.Help())\n\t\t\t\t}\n\t\t\t},\n\t\t\tGroupID: c.helpCommandGroupID,\n\t\t}\n\t}\n\tc.RemoveCommand(c.helpCommand)\n\tc.AddCommand(c.helpCommand)\n}",
    "importString": "",
    "lineNum": 51,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "(*Command).AddCommand",
    "sourceCode": "func (c *Command) AddCommand(cmds ...*Command) {\n\tfor i, x := range cmds {\n\t\tif cmds[i] == c {\n\t\t\tpanic(\"Command can't be a child of itself\")\n\t\t}\n\t\tcmds[i].parent = c\n\t\t// update max lengths\n\t\tusageLen := len(x.Use)\n\t\tif usageLen > c.commandsMaxUseLen {\n\t\t\tc.commandsMaxUseLen = usageLen\n\t\t}\n\t\tcommandPathLen := len(x.CommandPath())\n\t\tif commandPathLen > c.commandsMaxCommandPathLen {\n\t\t\tc.commandsMaxCommandPathLen = commandPathLen\n\t\t}\n\t\tnameLen := len(x.Name())\n\t\tif nameLen > c.commandsMaxNameLen {\n\t\t\tc.commandsMaxNameLen = nameLen\n\t\t}\n\t\t// If global normalization function exists, update all children\n\t\tif c.globNormFunc != nil {\n\t\t\tx.SetGlobalNormalizationFunc(c.globNormFunc)\n\t\t}\n\t\tc.commands = append(c.commands, x)\n\t\tc.commandsAreSorted = false\n\t}\n}",
    "importString": "",
    "lineNum": 26,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "(*Command).RemoveCommand",
    "sourceCode": "func (c *Command) RemoveCommand(cmds ...*Command) {\n\tcommands := []*Command{}\nmain:\n\tfor _, command := range c.commands {\n\t\tfor _, cmd := range cmds {\n\t\t\tif command == cmd {\n\t\t\t\tcommand.parent = nil\n\t\t\t\tcontinue main\n\t\t\t}\n\t\t}\n\t\tcommands = append(commands, command)\n\t}\n\tc.commands = commands\n\t// recompute all lengths\n\tc.commandsMaxUseLen = 0\n\tc.commandsMaxCommandPathLen = 0\n\tc.commandsMaxNameLen = 0\n\tfor _, command := range c.commands {\n\t\tusageLen := len(command.Use)\n\t\tif usageLen > c.commandsMaxUseLen {\n\t\t\tc.commandsMaxUseLen = usageLen\n\t\t}\n\t\tcommandPathLen := len(command.CommandPath())\n\t\tif commandPathLen > c.commandsMaxCommandPathLen {\n\t\t\tc.commandsMaxCommandPathLen = commandPathLen\n\t\t}\n\t\tnameLen := len(command.Name())\n\t\tif nameLen > c.commandsMaxNameLen {\n\t\t\tc.commandsMaxNameLen = nameLen\n\t\t}\n\t}\n}",
    "importString": "",
    "lineNum": 31,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "(*Command).UseLine",
    "sourceCode": "func (c *Command) UseLine() string {\n\tvar useline string\n\tuse := strings.Replace(c.Use, c.Name(), c.DisplayName(), 1)\n\tif c.HasParent() {\n\t\tuseline = c.parent.CommandPath() + \" \" + use\n\t} else {\n\t\tuseline = use\n\t}\n\tif c.DisableFlagsInUseLine {\n\t\treturn useline\n\t}\n\tif c.HasAvailableFlags() && !strings.Contains(useline, \"[flags]\") {\n\t\tuseline += \" [flags]\"\n\t}\n\treturn useline\n}",
    "importString": "",
    "lineNum": 15,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "(*Command).DebugFlags",
    "sourceCode": "func (c *Command) DebugFlags() {\n\tc.Println(\"DebugFlags called on\", c.Name())\n\tvar debugflags func(*Command)\n\n\tdebugflags = func(x *Command) {\n\t\tif x.HasFlags() || x.HasPersistentFlags() {\n\t\t\tc.Println(x.Name())\n\t\t}\n\t\tif x.HasFlags() {\n\t\t\tx.flags.VisitAll(func(f *flag.Flag) {\n\t\t\t\tif x.HasPersistentFlags() && x.persistentFlag(f.Name) != nil {\n\t\t\t\t\tc.Println(\"  -\"+f.Shorthand+\",\", \"--\"+f.Name, \"[\"+f.DefValue+\"]\", \"\", f.Value, \"  [LP]\")\n\t\t\t\t} else {\n\t\t\t\t\tc.Println(\"  -\"+f.Shorthand+\",\", \"--\"+f.Name, \"[\"+f.DefValue+\"]\", \"\", f.Value, \"  [L]\")\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t\tif x.HasPersistentFlags() {\n\t\t\tx.pflags.VisitAll(func(f *flag.Flag) {\n\t\t\t\tif x.HasFlags() {\n\t\t\t\t\tif x.flags.Lookup(f.Name) == nil {\n\t\t\t\t\t\tc.Println(\"  -\"+f.Shorthand+\",\", \"--\"+f.Name, \"[\"+f.DefValue+\"]\", \"\", f.Value, \"  [P]\")\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tc.Println(\"  -\"+f.Shorthand+\",\", \"--\"+f.Name, \"[\"+f.DefValue+\"]\", \"\", f.Value, \"  [P]\")\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t\tc.Println(x.flagErrorBuf)\n\t\tif x.HasSubCommands() {\n\t\t\tfor _, y := range x.commands {\n\t\t\t\tdebugflags(y)\n\t\t\t}\n\t\t}\n\t}\n\n\tdebugflags(c)\n}",
    "importString": "",
    "lineNum": 37,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "(*Command).hasNameOrAliasPrefix",
    "sourceCode": "func (c *Command) hasNameOrAliasPrefix(prefix string) bool {\n\tif strings.HasPrefix(c.Name(), prefix) {\n\t\tc.commandCalledAs.name = c.Name()\n\t\treturn true\n\t}\n\tfor _, alias := range c.Aliases {\n\t\tif strings.HasPrefix(alias, prefix) {\n\t\t\tc.commandCalledAs.name = alias\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}",
    "importString": "",
    "lineNum": 12,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "(*Command).IsAvailableCommand",
    "sourceCode": "func (c *Command) IsAvailableCommand() bool {\n\tif len(c.Deprecated) != 0 || c.Hidden {\n\t\treturn false\n\t}\n\n\tif c.HasParent() && c.Parent().helpCommand == c {\n\t\treturn false\n\t}\n\n\tif c.Runnable() || c.HasAvailableSubCommands() {\n\t\treturn true\n\t}\n\n\treturn false\n}",
    "importString": "",
    "lineNum": 14,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "(*Command).IsAdditionalHelpTopicCommand",
    "sourceCode": "func (c *Command) IsAdditionalHelpTopicCommand() bool {\n\t// if a command is runnable, deprecated, or hidden it is not a 'help' command\n\tif c.Runnable() || len(c.Deprecated) != 0 || c.Hidden {\n\t\treturn false\n\t}\n\n\t// if any non-help sub commands are found, the command is not a 'help' command\n\tfor _, sub := range c.commands {\n\t\tif !sub.IsAdditionalHelpTopicCommand() {\n\t\t\treturn false\n\t\t}\n\t}\n\n\t// the command either has no sub commands, or no non-help sub commands\n\treturn true\n}",
    "importString": "",
    "lineNum": 15,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "(*Command).HasHelpSubCommands",
    "sourceCode": "func (c *Command) HasHelpSubCommands() bool {\n\t// return true on the first found available 'help' sub command\n\tfor _, sub := range c.commands {\n\t\tif sub.IsAdditionalHelpTopicCommand() {\n\t\t\treturn true\n\t\t}\n\t}\n\n\t// the command either has no sub commands, or no available 'help' sub commands\n\treturn false\n}",
    "importString": "",
    "lineNum": 10,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "(*Command).HasAvailableSubCommands",
    "sourceCode": "func (c *Command) HasAvailableSubCommands() bool {\n\t// return true on the first found available (non deprecated/help/hidden)\n\t// sub command\n\tfor _, sub := range c.commands {\n\t\tif sub.IsAvailableCommand() {\n\t\t\treturn true\n\t\t}\n\t}\n\n\t// the command either has no sub commands, or no available (non deprecated/help/hidden)\n\t// sub commands\n\treturn false\n}",
    "importString": "",
    "lineNum": 12,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "(*Command).Flags",
    "sourceCode": "func (c *Command) Flags() *flag.FlagSet {\n\tif c.flags == nil {\n\t\tc.flags = flag.NewFlagSet(c.DisplayName(), flag.ContinueOnError)\n\t\tif c.flagErrorBuf == nil {\n\t\t\tc.flagErrorBuf = new(bytes.Buffer)\n\t\t}\n\t\tc.flags.SetOutput(c.flagErrorBuf)\n\t}\n\n\treturn c.flags\n}",
    "importString": "",
    "lineNum": 10,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "(*Command).LocalNonPersistentFlags",
    "sourceCode": "func (c *Command) LocalNonPersistentFlags() *flag.FlagSet {\n\tpersistentFlags := c.PersistentFlags()\n\n\tout := flag.NewFlagSet(c.DisplayName(), flag.ContinueOnError)\n\tc.LocalFlags().VisitAll(func(f *flag.Flag) {\n\t\tif persistentFlags.Lookup(f.Name) == nil {\n\t\t\tout.AddFlag(f)\n\t\t}\n\t})\n\treturn out\n}",
    "importString": "",
    "lineNum": 10,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "(*Command).LocalFlags",
    "sourceCode": "func (c *Command) LocalFlags() *flag.FlagSet {\n\tc.mergePersistentFlags()\n\n\tif c.lflags == nil {\n\t\tc.lflags = flag.NewFlagSet(c.DisplayName(), flag.ContinueOnError)\n\t\tif c.flagErrorBuf == nil {\n\t\t\tc.flagErrorBuf = new(bytes.Buffer)\n\t\t}\n\t\tc.lflags.SetOutput(c.flagErrorBuf)\n\t}\n\tc.lflags.SortFlags = c.Flags().SortFlags\n\tif c.globNormFunc != nil {\n\t\tc.lflags.SetNormalizeFunc(c.globNormFunc)\n\t}\n\n\taddToLocal := func(f *flag.Flag) {\n\t\t// Add the flag if it is not a parent PFlag, or it shadows a parent PFlag\n\t\tif c.lflags.Lookup(f.Name) == nil && f != c.parentsPflags.Lookup(f.Name) {\n\t\t\tc.lflags.AddFlag(f)\n\t\t}\n\t}\n\tc.Flags().VisitAll(addToLocal)\n\tc.PersistentFlags().VisitAll(addToLocal)\n\treturn c.lflags\n}",
    "importString": "",
    "lineNum": 24,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "(*Command).InheritedFlags",
    "sourceCode": "func (c *Command) InheritedFlags() *flag.FlagSet {\n\tc.mergePersistentFlags()\n\n\tif c.iflags == nil {\n\t\tc.iflags = flag.NewFlagSet(c.DisplayName(), flag.ContinueOnError)\n\t\tif c.flagErrorBuf == nil {\n\t\t\tc.flagErrorBuf = new(bytes.Buffer)\n\t\t}\n\t\tc.iflags.SetOutput(c.flagErrorBuf)\n\t}\n\n\tlocal := c.LocalFlags()\n\tif c.globNormFunc != nil {\n\t\tc.iflags.SetNormalizeFunc(c.globNormFunc)\n\t}\n\n\tc.parentsPflags.VisitAll(func(f *flag.Flag) {\n\t\tif c.iflags.Lookup(f.Name) == nil && local.Lookup(f.Name) == nil {\n\t\t\tc.iflags.AddFlag(f)\n\t\t}\n\t})\n\treturn c.iflags\n}",
    "importString": "",
    "lineNum": 22,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "(*Command).ResetFlags",
    "sourceCode": "func (c *Command) ResetFlags() {\n\tc.flagErrorBuf = new(bytes.Buffer)\n\tc.flagErrorBuf.Reset()\n\tc.flags = flag.NewFlagSet(c.DisplayName(), flag.ContinueOnError)\n\tc.flags.SetOutput(c.flagErrorBuf)\n\tc.pflags = flag.NewFlagSet(c.DisplayName(), flag.ContinueOnError)\n\tc.pflags.SetOutput(c.flagErrorBuf)\n\n\tc.lflags = nil\n\tc.iflags = nil\n\tc.parentsPflags = nil\n}",
    "importString": "",
    "lineNum": 11,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "(*Command).persistentFlag",
    "sourceCode": "func (c *Command) persistentFlag(name string) (flag *flag.Flag) {\n\tif c.HasPersistentFlags() {\n\t\tflag = c.PersistentFlags().Lookup(name)\n\t}\n\n\tif flag == nil {\n\t\tc.updateParentsPflags()\n\t\tflag = c.parentsPflags.Lookup(name)\n\t}\n\treturn\n}",
    "importString": "",
    "lineNum": 10,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "(*Command).ParseFlags",
    "sourceCode": "func (c *Command) ParseFlags(args []string) error {\n\tif c.DisableFlagParsing {\n\t\treturn nil\n\t}\n\n\tif c.flagErrorBuf == nil {\n\t\tc.flagErrorBuf = new(bytes.Buffer)\n\t}\n\tbeforeErrorBufLen := c.flagErrorBuf.Len()\n\tc.mergePersistentFlags()\n\n\t// do it here after merging all flags and just before parse\n\tc.Flags().ParseErrorsWhitelist = flag.ParseErrorsWhitelist(c.FParseErrWhitelist)\n\n\terr := c.Flags().Parse(args)\n\t// Print warnings if they occurred (e.g. deprecated flag messages).\n\tif c.flagErrorBuf.Len()-beforeErrorBufLen > 0 && err == nil {\n\t\tc.Print(c.flagErrorBuf.String())\n\t}\n\n\treturn err\n}",
    "importString": "",
    "lineNum": 21,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "(*Command).updateParentsPflags",
    "sourceCode": "func (c *Command) updateParentsPflags() {\n\tif c.parentsPflags == nil {\n\t\tc.parentsPflags = flag.NewFlagSet(c.DisplayName(), flag.ContinueOnError)\n\t\tc.parentsPflags.SetOutput(c.flagErrorBuf)\n\t\tc.parentsPflags.SortFlags = false\n\t}\n\n\tif c.globNormFunc != nil {\n\t\tc.parentsPflags.SetNormalizeFunc(c.globNormFunc)\n\t}\n\n\tc.Root().PersistentFlags().AddFlagSet(flag.CommandLine)\n\n\tc.VisitParents(func(parent *Command) {\n\t\tc.parentsPflags.AddFlagSet(parent.PersistentFlags())\n\t})\n}",
    "importString": "",
    "lineNum": 16,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "defaultUsageFunc",
    "sourceCode": "func defaultUsageFunc(w io.Writer, in interface{}) error {\n\tc := in.(*Command)\n\tfmt.Fprint(w, \"Usage:\")\n\tif c.Runnable() {\n\t\tfmt.Fprintf(w, \"\\n  %s\", c.UseLine())\n\t}\n\tif c.HasAvailableSubCommands() {\n\t\tfmt.Fprintf(w, \"\\n  %s [command]\", c.CommandPath())\n\t}\n\tif len(c.Aliases) > 0 {\n\t\tfmt.Fprintf(w, \"\\n\\nAliases:\\n\")\n\t\tfmt.Fprintf(w, \"  %s\", c.NameAndAliases())\n\t}\n\tif c.HasExample() {\n\t\tfmt.Fprintf(w, \"\\n\\nExamples:\\n\")\n\t\tfmt.Fprintf(w, \"%s\", c.Example)\n\t}\n\tif c.HasAvailableSubCommands() {\n\t\tcmds := c.Commands()\n\t\tif len(c.Groups()) == 0 {\n\t\t\tfmt.Fprintf(w, \"\\n\\nAvailable Commands:\")\n\t\t\tfor _, subcmd := range cmds {\n\t\t\t\tif subcmd.IsAvailableCommand() || subcmd.Name() == helpCommandName {\n\t\t\t\t\tfmt.Fprintf(w, \"\\n  %s %s\", rpad(subcmd.Name(), subcmd.NamePadding()), subcmd.Short)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor _, group := range c.Groups() {\n\t\t\t\tfmt.Fprintf(w, \"\\n\\n%s\", group.Title)\n\t\t\t\tfor _, subcmd := range cmds {\n\t\t\t\t\tif subcmd.GroupID == group.ID && (subcmd.IsAvailableCommand() || subcmd.Name() == helpCommandName) {\n\t\t\t\t\t\tfmt.Fprintf(w, \"\\n  %s %s\", rpad(subcmd.Name(), subcmd.NamePadding()), subcmd.Short)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !c.AllChildCommandsHaveGroup() {\n\t\t\t\tfmt.Fprintf(w, \"\\n\\nAdditional Commands:\")\n\t\t\t\tfor _, subcmd := range cmds {\n\t\t\t\t\tif subcmd.GroupID == \"\" && (subcmd.IsAvailableCommand() || subcmd.Name() == helpCommandName) {\n\t\t\t\t\t\tfmt.Fprintf(w, \"\\n  %s %s\", rpad(subcmd.Name(), subcmd.NamePadding()), subcmd.Short)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif c.HasAvailableLocalFlags() {\n\t\tfmt.Fprintf(w, \"\\n\\nFlags:\\n\")\n\t\tfmt.Fprint(w, trimRightSpace(c.LocalFlags().FlagUsages()))\n\t}\n\tif c.HasAvailableInheritedFlags() {\n\t\tfmt.Fprintf(w, \"\\n\\nGlobal Flags:\\n\")\n\t\tfmt.Fprint(w, trimRightSpace(c.InheritedFlags().FlagUsages()))\n\t}\n\tif c.HasHelpSubCommands() {\n\t\tfmt.Fprintf(w, \"\\n\\nAdditional help topics:\")\n\t\tfor _, subcmd := range c.Commands() {\n\t\t\tif subcmd.IsAdditionalHelpTopicCommand() {\n\t\t\t\tfmt.Fprintf(w, \"\\n  %s %s\", rpad(subcmd.CommandPath(), subcmd.CommandPathPadding()), subcmd.Short)\n\t\t\t}\n\t\t}\n\t}\n\tif c.HasAvailableSubCommands() {\n\t\tfmt.Fprintf(w, \"\\n\\nUse \\\"%s [command] --help\\\" for more information about a command.\", c.CommandPath())\n\t}\n\tfmt.Fprintln(w)\n\treturn nil\n}",
    "importString": "",
    "lineNum": 66,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "defaultHelpFunc",
    "sourceCode": "func defaultHelpFunc(w io.Writer, in interface{}) error {\n\tc := in.(*Command)\n\tusage := c.Long\n\tif usage == \"\" {\n\t\tusage = c.Short\n\t}\n\tusage = trimRightSpace(usage)\n\tif usage != \"\" {\n\t\tfmt.Fprintln(w, usage)\n\t\tfmt.Fprintln(w)\n\t}\n\tif c.Runnable() || c.HasSubCommands() {\n\t\tfmt.Fprint(w, c.UsageString())\n\t}\n\treturn nil\n}",
    "importString": "",
    "lineNum": 15,
    "relativeDocumentPath": "command.go"
  },
  {
    "symbolName": "preExecHook",
    "sourceCode": "func preExecHook(c *Command) {\n\tif MousetrapHelpText != \"\" && mousetrap.StartedByExplorer() {\n\t\tc.Print(MousetrapHelpText)\n\t\tif MousetrapDisplayDuration > 0 {\n\t\t\ttime.Sleep(MousetrapDisplayDuration)\n\t\t} else {\n\t\t\tc.Println(\"Press return to continue...\")\n\t\t\tfmt.Scanln()\n\t\t}\n\t\tos.Exit(1)\n\t}\n}",
    "importString": "",
    "lineNum": 11,
    "relativeDocumentPath": "command_win.go"
  },
  {
    "symbolName": "(*Command).RegisterFlagCompletionFunc",
    "sourceCode": "func (c *Command) RegisterFlagCompletionFunc(flagName string, f CompletionFunc) error {\n\tflag := c.Flag(flagName)\n\tif flag == nil {\n\t\treturn fmt.Errorf(\"RegisterFlagCompletionFunc: flag '%s' does not exist\", flagName)\n\t}\n\tflagCompletionMutex.Lock()\n\tdefer flagCompletionMutex.Unlock()\n\n\tif _, exists := flagCompletionFunctions[flag]; exists {\n\t\treturn fmt.Errorf(\"RegisterFlagCompletionFunc: flag '%s' already registered\", flagName)\n\t}\n\tflagCompletionFunctions[flag] = f\n\treturn nil\n}",
    "importString": "",
    "lineNum": 13,
    "relativeDocumentPath": "completions.go"
  },
  {
    "symbolName": "(*Command).GetFlagCompletionFunc",
    "sourceCode": "func (c *Command) GetFlagCompletionFunc(flagName string) (CompletionFunc, bool) {\n\tflag := c.Flag(flagName)\n\tif flag == nil {\n\t\treturn nil, false\n\t}\n\n\tflagCompletionMutex.RLock()\n\tdefer flagCompletionMutex.RUnlock()\n\n\tcompletionFunc, exists := flagCompletionFunctions[flag]\n\treturn completionFunc, exists\n}",
    "importString": "",
    "lineNum": 11,
    "relativeDocumentPath": "completions.go"
  },
  {
    "symbolName": "(ShellCompDirective).string",
    "sourceCode": "func (d ShellCompDirective) string() string {\n\tvar directives []string\n\tif d&ShellCompDirectiveError != 0 {\n\t\tdirectives = append(directives, \"ShellCompDirectiveError\")\n\t}\n\tif d&ShellCompDirectiveNoSpace != 0 {\n\t\tdirectives = append(directives, \"ShellCompDirectiveNoSpace\")\n\t}\n\tif d&ShellCompDirectiveNoFileComp != 0 {\n\t\tdirectives = append(directives, \"ShellCompDirectiveNoFileComp\")\n\t}\n\tif d&ShellCompDirectiveFilterFileExt != 0 {\n\t\tdirectives = append(directives, \"ShellCompDirectiveFilterFileExt\")\n\t}\n\tif d&ShellCompDirectiveFilterDirs != 0 {\n\t\tdirectives = append(directives, \"ShellCompDirectiveFilterDirs\")\n\t}\n\tif d&ShellCompDirectiveKeepOrder != 0 {\n\t\tdirectives = append(directives, \"ShellCompDirectiveKeepOrder\")\n\t}\n\tif len(directives) == 0 {\n\t\tdirectives = append(directives, \"ShellCompDirectiveDefault\")\n\t}\n\n\tif d >= shellCompDirectiveMaxValue {\n\t\treturn fmt.Sprintf(\"ERROR: unexpected ShellCompDirective value: %d\", d)\n\t}\n\treturn strings.Join(directives, \", \")\n}",
    "importString": "",
    "lineNum": 28,
    "relativeDocumentPath": "completions.go"
  },
  {
    "symbolName": "(*Command).initCompleteCmd",
    "sourceCode": "func (c *Command) initCompleteCmd(args []string) {\n\tcompleteCmd := &Command{\n\t\tUse:                   fmt.Sprintf(\"%s [command-line]\", ShellCompRequestCmd),\n\t\tAliases:               []string{ShellCompNoDescRequestCmd},\n\t\tDisableFlagsInUseLine: true,\n\t\tHidden:                true,\n\t\tDisableFlagParsing:    true,\n\t\tArgs:                  MinimumNArgs(1),\n\t\tShort:                 \"Request shell completion choices for the specified command-line\",\n\t\tLong: fmt.Sprintf(\"%[2]s is a special command that is used by the shell completion logic\\n%[1]s\",\n\t\t\t\"to request completion choices for the specified command-line.\", ShellCompRequestCmd),\n\t\tRun: func(cmd *Command, args []string) {\n\t\t\tfinalCmd, completions, directive, err := cmd.getCompletions(args)\n\t\t\tif err != nil {\n\t\t\t\tCompErrorln(err.Error())\n\t\t\t\t// Keep going for multiple reasons:\n\t\t\t\t// 1- There could be some valid completions even though there was an error\n\t\t\t\t// 2- Even without completions, we need to print the directive\n\t\t\t}\n\n\t\t\tnoDescriptions := cmd.CalledAs() == ShellCompNoDescRequestCmd\n\t\t\tif !noDescriptions {\n\t\t\t\tif doDescriptions, err := strconv.ParseBool(getEnvConfig(cmd, configEnvVarSuffixDescriptions)); err == nil {\n\t\t\t\t\tnoDescriptions = !doDescriptions\n\t\t\t\t}\n\t\t\t}\n\t\t\tnoActiveHelp := GetActiveHelpConfig(finalCmd) == activeHelpGlobalDisable\n\t\t\tout := finalCmd.OutOrStdout()\n\t\t\tfor _, comp := range completions {\n\t\t\t\tif noActiveHelp && strings.HasPrefix(comp, activeHelpMarker) {\n\t\t\t\t\t// Remove all activeHelp entries if it's disabled.\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif noDescriptions {\n\t\t\t\t\t// Remove any description that may be included following a tab character.\n\t\t\t\t\tcomp = strings.SplitN(comp, \"\\t\", 2)[0]\n\t\t\t\t}\n\n\t\t\t\t// Make sure we only write the first line to the output.\n\t\t\t\t// This is needed if a description contains a linebreak.\n\t\t\t\t// Otherwise the shell scripts will interpret the other lines as new flags\n\t\t\t\t// and could therefore provide a wrong completion.\n\t\t\t\tcomp = strings.SplitN(comp, \"\\n\", 2)[0]\n\n\t\t\t\t// Finally trim the completion.  This is especially important to get rid\n\t\t\t\t// of a trailing tab when there are no description following it.\n\t\t\t\t// For example, a sub-command without a description should not be completed\n\t\t\t\t// with a tab at the end (or else zsh will show a -- following it\n\t\t\t\t// although there is no description).\n\t\t\t\tcomp = strings.TrimSpace(comp)\n\n\t\t\t\t// Print each possible completion to the output for the completion script to consume.\n\t\t\t\tfmt.Fprintln(out, comp)\n\t\t\t}\n\n\t\t\t// As the last printout, print the completion directive for the completion script to parse.\n\t\t\t// The directive integer must be that last character following a single colon (:).\n\t\t\t// The completion script expects :<directive>\n\t\t\tfmt.Fprintf(out, \":%d\\n\", directive)\n\n\t\t\t// Print some helpful info to stderr for the user to understand.\n\t\t\t// Output from stderr must be ignored by the completion script.\n\t\t\tfmt.Fprintf(finalCmd.ErrOrStderr(), \"Completion ended with directive: %s\\n\", directive.string())\n\t\t},\n\t}\n\tc.AddCommand(completeCmd)\n\tsubCmd, _, err := c.Find(args)\n\tif err != nil || subCmd.Name() != ShellCompRequestCmd {\n\t\t// Only create this special command if it is actually being called.\n\t\t// This reduces possible side-effects of creating such a command;\n\t\t// for example, having this command would cause problems to a\n\t\t// cobra program that only consists of the root command, since this\n\t\t// command would cause the root command to suddenly have a subcommand.\n\t\tc.RemoveCommand(completeCmd)\n\t}\n}",
    "importString": "",
    "lineNum": 75,
    "relativeDocumentPath": "completions.go"
  },
  {
    "symbolName": "(*Command).getCompletions",
    "sourceCode": "func (c *Command) getCompletions(args []string) (*Command, []Completion, ShellCompDirective, error) {\n\t// The last argument, which is not completely typed by the user,\n\t// should not be part of the list of arguments\n\ttoComplete := args[len(args)-1]\n\ttrimmedArgs := args[:len(args)-1]\n\n\tvar finalCmd *Command\n\tvar finalArgs []string\n\tvar err error\n\t// Find the real command for which completion must be performed\n\t// check if we need to traverse here to parse local flags on parent commands\n\tif c.Root().TraverseChildren {\n\t\tfinalCmd, finalArgs, err = c.Root().Traverse(trimmedArgs)\n\t} else {\n\t\t// For Root commands that don't specify any value for their Args fields, when we call\n\t\t// Find(), if those Root commands don't have any sub-commands, they will accept arguments.\n\t\t// However, because we have added the __complete sub-command in the current code path, the\n\t\t// call to Find() -> legacyArgs() will return an error if there are any arguments.\n\t\t// To avoid this, we first remove the __complete command to get back to having no sub-commands.\n\t\trootCmd := c.Root()\n\t\tif len(rootCmd.Commands()) == 1 {\n\t\t\trootCmd.RemoveCommand(c)\n\t\t}\n\n\t\tfinalCmd, finalArgs, err = rootCmd.Find(trimmedArgs)\n\t}\n\tif err != nil {\n\t\t// Unable to find the real command. E.g., <program> someInvalidCmd <TAB>\n\t\treturn c, []Completion{}, ShellCompDirectiveDefault, fmt.Errorf(\"unable to find a command for arguments: %v\", trimmedArgs)\n\t}\n\tfinalCmd.ctx = c.ctx\n\n\t// These flags are normally added when `execute()` is called on `finalCmd`,\n\t// however, when doing completion, we don't call `finalCmd.execute()`.\n\t// Let's add the --help and --version flag ourselves but only if the finalCmd\n\t// has not disabled flag parsing; if flag parsing is disabled, it is up to the\n\t// finalCmd itself to handle the completion of *all* flags.\n\tif !finalCmd.DisableFlagParsing {\n\t\tfinalCmd.InitDefaultHelpFlag()\n\t\tfinalCmd.InitDefaultVersionFlag()\n\t}\n\n\t// Check if we are doing flag value completion before parsing the flags.\n\t// This is important because if we are completing a flag value, we need to also\n\t// remove the flag name argument from the list of finalArgs or else the parsing\n\t// could fail due to an invalid value (incomplete) for the flag.\n\tflag, finalArgs, toComplete, flagErr := checkIfFlagCompletion(finalCmd, finalArgs, toComplete)\n\n\t// Check if interspersed is false or -- was set on a previous arg.\n\t// This works by counting the arguments. Normally -- is not counted as arg but\n\t// if -- was already set or interspersed is false and there is already one arg then\n\t// the extra added -- is counted as arg.\n\tflagCompletion := true\n\t_ = finalCmd.ParseFlags(append(finalArgs, \"--\"))\n\tnewArgCount := finalCmd.Flags().NArg()\n\n\t// Parse the flags early so we can check if required flags are set\n\tif err = finalCmd.ParseFlags(finalArgs); err != nil {\n\t\treturn finalCmd, []Completion{}, ShellCompDirectiveDefault, fmt.Errorf(\"Error while parsing flags from args %v: %s\", finalArgs, err.Error())\n\t}\n\n\trealArgCount := finalCmd.Flags().NArg()\n\tif newArgCount > realArgCount {\n\t\t// don't do flag completion (see above)\n\t\tflagCompletion = false\n\t}\n\t// Error while attempting to parse flags\n\tif flagErr != nil {\n\t\t// If error type is flagCompError and we don't want flagCompletion we should ignore the error\n\t\tif _, ok := flagErr.(*flagCompError); !(ok && !flagCompletion) {\n\t\t\treturn finalCmd, []Completion{}, ShellCompDirectiveDefault, flagErr\n\t\t}\n\t}\n\n\t// Look for the --help or --version flags.  If they are present,\n\t// there should be no further completions.\n\tif helpOrVersionFlagPresent(finalCmd) {\n\t\treturn finalCmd, []Completion{}, ShellCompDirectiveNoFileComp, nil\n\t}\n\n\t// We only remove the flags from the arguments if DisableFlagParsing is not set.\n\t// This is important for commands which have requested to do their own flag completion.\n\tif !finalCmd.DisableFlagParsing {\n\t\tfinalArgs = finalCmd.Flags().Args()\n\t}\n\n\tif flag != nil && flagCompletion {\n\t\t// Check if we are completing a flag value subject to annotations\n\t\tif validExts, present := flag.Annotations[BashCompFilenameExt]; present {\n\t\t\tif len(validExts) != 0 {\n\t\t\t\t// File completion filtered by extensions\n\t\t\t\treturn finalCmd, validExts, ShellCompDirectiveFilterFileExt, nil\n\t\t\t}\n\n\t\t\t// The annotation requests simple file completion.  There is no reason to do\n\t\t\t// that since it is the default behavior anyway.  Let's ignore this annotation\n\t\t\t// in case the program also registered a completion function for this flag.\n\t\t\t// Even though it is a mistake on the program's side, let's be nice when we can.\n\t\t}\n\n\t\tif subDir, present := flag.Annotations[BashCompSubdirsInDir]; present {\n\t\t\tif len(subDir) == 1 {\n\t\t\t\t// Directory completion from within a directory\n\t\t\t\treturn finalCmd, subDir, ShellCompDirectiveFilterDirs, nil\n\t\t\t}\n\t\t\t// Directory completion\n\t\t\treturn finalCmd, []Completion{}, ShellCompDirectiveFilterDirs, nil\n\t\t}\n\t}\n\n\tvar completions []Completion\n\tvar directive ShellCompDirective\n\n\t// Enforce flag groups before doing flag completions\n\tfinalCmd.enforceFlagGroupsForCompletion()\n\n\t// Note that we want to perform flagname completion even if finalCmd.DisableFlagParsing==true;\n\t// doing this allows for completion of persistent flag names even for commands that disable flag parsing.\n\t//\n\t// When doing completion of a flag name, as soon as an argument starts with\n\t// a '-' we know it is a flag.  We cannot use isFlagArg() here as it requires\n\t// the flag name to be complete\n\tif flag == nil && len(toComplete) > 0 && toComplete[0] == '-' && !strings.Contains(toComplete, \"=\") && flagCompletion {\n\t\t// First check for required flags\n\t\tcompletions = completeRequireFlags(finalCmd, toComplete)\n\n\t\t// If we have not found any required flags, only then can we show regular flags\n\t\tif len(completions) == 0 {\n\t\t\tdoCompleteFlags := func(flag *pflag.Flag) {\n\t\t\t\t_, acceptsMultiple := flag.Value.(SliceValue)\n\t\t\t\tacceptsMultiple = acceptsMultiple ||\n\t\t\t\t\tstrings.Contains(flag.Value.Type(), \"Slice\") ||\n\t\t\t\t\tstrings.Contains(flag.Value.Type(), \"Array\") ||\n\t\t\t\t\tstrings.HasPrefix(flag.Value.Type(), \"stringTo\")\n\n\t\t\t\tif !flag.Changed || acceptsMultiple {\n\t\t\t\t\t// If the flag is not already present, or if it can be specified multiple times (Array, Slice, or stringTo)\n\t\t\t\t\t// we suggest it as a completion\n\t\t\t\t\tcompletions = append(completions, getFlagNameCompletions(flag, toComplete)...)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// We cannot use finalCmd.Flags() because we may not have called ParsedFlags() for commands\n\t\t\t// that have set DisableFlagParsing; it is ParseFlags() that merges the inherited and\n\t\t\t// non-inherited flags.\n\t\t\tfinalCmd.InheritedFlags().VisitAll(func(flag *pflag.Flag) {\n\t\t\t\tdoCompleteFlags(flag)\n\t\t\t})\n\t\t\t// Try to complete non-inherited flags even if DisableFlagParsing==true.\n\t\t\t// This allows programs to tell Cobra about flags for completion even\n\t\t\t// if the actual parsing of flags is not done by Cobra.\n\t\t\t// For instance, Helm uses this to provide flag name completion for\n\t\t\t// some of its plugins.\n\t\t\tfinalCmd.NonInheritedFlags().VisitAll(func(flag *pflag.Flag) {\n\t\t\t\tdoCompleteFlags(flag)\n\t\t\t})\n\t\t}\n\n\t\tdirective = ShellCompDirectiveNoFileComp\n\t\tif len(completions) == 1 && strings.HasSuffix(completions[0], \"=\") {\n\t\t\t// If there is a single completion, the shell usually adds a space\n\t\t\t// after the completion.  We don't want that if the flag ends with an =\n\t\t\tdirective = ShellCompDirectiveNoSpace\n\t\t}\n\n\t\tif !finalCmd.DisableFlagParsing {\n\t\t\t// If DisableFlagParsing==false, we have completed the flags as known by Cobra;\n\t\t\t// we can return what we found.\n\t\t\t// If DisableFlagParsing==true, Cobra may not be aware of all flags, so we\n\t\t\t// let the logic continue to see if ValidArgsFunction needs to be called.\n\t\t\treturn finalCmd, completions, directive, nil\n\t\t}\n\t} else {\n\t\tdirective = ShellCompDirectiveDefault\n\t\tif flag == nil {\n\t\t\tfoundLocalNonPersistentFlag := false\n\t\t\t// If TraverseChildren is true on the root command we don't check for\n\t\t\t// local flags because we can use a local flag on a parent command\n\t\t\tif !finalCmd.Root().TraverseChildren {\n\t\t\t\t// Check if there are any local, non-persistent flags on the command-line\n\t\t\t\tlocalNonPersistentFlags := finalCmd.LocalNonPersistentFlags()\n\t\t\t\tfinalCmd.NonInheritedFlags().VisitAll(func(flag *pflag.Flag) {\n\t\t\t\t\tif localNonPersistentFlags.Lookup(flag.Name) != nil && flag.Changed {\n\t\t\t\t\t\tfoundLocalNonPersistentFlag = true\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\n\t\t\t// Complete subcommand names, including the help command\n\t\t\tif len(finalArgs) == 0 && !foundLocalNonPersistentFlag {\n\t\t\t\t// We only complete sub-commands if:\n\t\t\t\t// - there are no arguments on the command-line and\n\t\t\t\t// - there are no local, non-persistent flags on the command-line or TraverseChildren is true\n\t\t\t\tfor _, subCmd := range finalCmd.Commands() {\n\t\t\t\t\tif subCmd.IsAvailableCommand() || subCmd == finalCmd.helpCommand {\n\t\t\t\t\t\tif strings.HasPrefix(subCmd.Name(), toComplete) {\n\t\t\t\t\t\t\tcompletions = append(completions, CompletionWithDesc(subCmd.Name(), subCmd.Short))\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdirective = ShellCompDirectiveNoFileComp\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Complete required flags even without the '-' prefix\n\t\t\tcompletions = append(completions, completeRequireFlags(finalCmd, toComplete)...)\n\n\t\t\t// Always complete ValidArgs, even if we are completing a subcommand name.\n\t\t\t// This is for commands that have both subcommands and ValidArgs.\n\t\t\tif len(finalCmd.ValidArgs) > 0 {\n\t\t\t\tif len(finalArgs) == 0 {\n\t\t\t\t\t// ValidArgs are only for the first argument\n\t\t\t\t\tfor _, validArg := range finalCmd.ValidArgs {\n\t\t\t\t\t\tif strings.HasPrefix(validArg, toComplete) {\n\t\t\t\t\t\t\tcompletions = append(completions, validArg)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdirective = ShellCompDirectiveNoFileComp\n\n\t\t\t\t\t// If no completions were found within commands or ValidArgs,\n\t\t\t\t\t// see if there are any ArgAliases that should be completed.\n\t\t\t\t\tif len(completions) == 0 {\n\t\t\t\t\t\tfor _, argAlias := range finalCmd.ArgAliases {\n\t\t\t\t\t\t\tif strings.HasPrefix(argAlias, toComplete) {\n\t\t\t\t\t\t\t\tcompletions = append(completions, argAlias)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If there are ValidArgs specified (even if they don't match), we stop completion.\n\t\t\t\t// Only one of ValidArgs or ValidArgsFunction can be used for a single command.\n\t\t\t\treturn finalCmd, completions, directive, nil\n\t\t\t}\n\n\t\t\t// Let the logic continue so as to add any ValidArgsFunction completions,\n\t\t\t// even if we already found sub-commands.\n\t\t\t// This is for commands that have subcommands but also specify a ValidArgsFunction.\n\t\t}\n\t}\n\n\t// Find the completion function for the flag or command\n\tvar completionFn CompletionFunc\n\tif flag != nil && flagCompletion {\n\t\tflagCompletionMutex.RLock()\n\t\tcompletionFn = flagCompletionFunctions[flag]\n\t\tflagCompletionMutex.RUnlock()\n\t} else {\n\t\tcompletionFn = finalCmd.ValidArgsFunction\n\t}\n\tif completionFn != nil {\n\t\t// Go custom completion defined for this flag or command.\n\t\t// Call the registered completion function to get the completions.\n\t\tvar comps []Completion\n\t\tcomps, directive = completionFn(finalCmd, finalArgs, toComplete)\n\t\tcompletions = append(completions, comps...)\n\t}\n\n\treturn finalCmd, completions, directive, nil\n}",
    "importString": "",
    "lineNum": 258,
    "relativeDocumentPath": "completions.go"
  },
  {
    "symbolName": "helpOrVersionFlagPresent",
    "sourceCode": "func helpOrVersionFlagPresent(cmd *Command) bool {\n\tif versionFlag := cmd.Flags().Lookup(\"version\"); versionFlag != nil &&\n\t\tlen(versionFlag.Annotations[FlagSetByCobraAnnotation]) > 0 && versionFlag.Changed {\n\t\treturn true\n\t}\n\tif helpFlag := cmd.Flags().Lookup(helpFlagName); helpFlag != nil &&\n\t\tlen(helpFlag.Annotations[FlagSetByCobraAnnotation]) > 0 && helpFlag.Changed {\n\t\treturn true\n\t}\n\treturn false\n}",
    "importString": "",
    "lineNum": 10,
    "relativeDocumentPath": "completions.go"
  },
  {
    "symbolName": "getFlagNameCompletions",
    "sourceCode": "func getFlagNameCompletions(flag *pflag.Flag, toComplete string) []Completion {\n\tif nonCompletableFlag(flag) {\n\t\treturn []Completion{}\n\t}\n\n\tvar completions []Completion\n\tflagName := \"--\" + flag.Name\n\tif strings.HasPrefix(flagName, toComplete) {\n\t\t// Flag without the =\n\t\tcompletions = append(completions, CompletionWithDesc(flagName, flag.Usage))\n\n\t\t// Why suggest both long forms: --flag and --flag= ?\n\t\t// This forces the user to *always* have to type either an = or a space after the flag name.\n\t\t// Let's be nice and avoid making users have to do that.\n\t\t// Since boolean flags and shortname flags don't show the = form, let's go that route and never show it.\n\t\t// The = form will still work, we just won't suggest it.\n\t\t// This also makes the list of suggested flags shorter as we avoid all the = forms.\n\t\t//\n\t\t// if len(flag.NoOptDefVal) == 0 {\n\t\t// \t// Flag requires a value, so it can be suffixed with =\n\t\t// \tflagName += \"=\"\n\t\t// \tcompletions = append(completions, CompletionWithDesc(flagName, flag.Usage))\n\t\t// }\n\t}\n\n\tflagName = \"-\" + flag.Shorthand\n\tif len(flag.Shorthand) > 0 && strings.HasPrefix(flagName, toComplete) {\n\t\tcompletions = append(completions, CompletionWithDesc(flagName, flag.Usage))\n\t}\n\n\treturn completions\n}",
    "importString": "",
    "lineNum": 31,
    "relativeDocumentPath": "completions.go"
  },
  {
    "symbolName": "completeRequireFlags",
    "sourceCode": "func completeRequireFlags(finalCmd *Command, toComplete string) []Completion {\n\tvar completions []Completion\n\n\tdoCompleteRequiredFlags := func(flag *pflag.Flag) {\n\t\tif _, present := flag.Annotations[BashCompOneRequiredFlag]; present {\n\t\t\tif !flag.Changed {\n\t\t\t\t// If the flag is not already present, we suggest it as a completion\n\t\t\t\tcompletions = append(completions, getFlagNameCompletions(flag, toComplete)...)\n\t\t\t}\n\t\t}\n\t}\n\n\t// We cannot use finalCmd.Flags() because we may not have called ParsedFlags() for commands\n\t// that have set DisableFlagParsing; it is ParseFlags() that merges the inherited and\n\t// non-inherited flags.\n\tfinalCmd.InheritedFlags().VisitAll(func(flag *pflag.Flag) {\n\t\tdoCompleteRequiredFlags(flag)\n\t})\n\tfinalCmd.NonInheritedFlags().VisitAll(func(flag *pflag.Flag) {\n\t\tdoCompleteRequiredFlags(flag)\n\t})\n\n\treturn completions\n}",
    "importString": "",
    "lineNum": 23,
    "relativeDocumentPath": "completions.go"
  },
  {
    "symbolName": "checkIfFlagCompletion",
    "sourceCode": "func checkIfFlagCompletion(finalCmd *Command, args []string, lastArg string) (*pflag.Flag, []string, string, error) {\n\tif finalCmd.DisableFlagParsing {\n\t\t// We only do flag completion if we are allowed to parse flags\n\t\t// This is important for commands which have requested to do their own flag completion.\n\t\treturn nil, args, lastArg, nil\n\t}\n\n\tvar flagName string\n\ttrimmedArgs := args\n\tflagWithEqual := false\n\torgLastArg := lastArg\n\n\t// When doing completion of a flag name, as soon as an argument starts with\n\t// a '-' we know it is a flag.  We cannot use isFlagArg() here as that function\n\t// requires the flag name to be complete\n\tif len(lastArg) > 0 && lastArg[0] == '-' {\n\t\tif index := strings.Index(lastArg, \"=\"); index >= 0 {\n\t\t\t// Flag with an =\n\t\t\tif strings.HasPrefix(lastArg[:index], \"--\") {\n\t\t\t\t// Flag has full name\n\t\t\t\tflagName = lastArg[2:index]\n\t\t\t} else {\n\t\t\t\t// Flag is shorthand\n\t\t\t\t// We have to get the last shorthand flag name\n\t\t\t\t// e.g. `-asd` => d to provide the correct completion\n\t\t\t\t// https://github.com/spf13/cobra/issues/1257\n\t\t\t\tflagName = lastArg[index-1 : index]\n\t\t\t}\n\t\t\tlastArg = lastArg[index+1:]\n\t\t\tflagWithEqual = true\n\t\t} else {\n\t\t\t// Normal flag completion\n\t\t\treturn nil, args, lastArg, nil\n\t\t}\n\t}\n\n\tif len(flagName) == 0 {\n\t\tif len(args) > 0 {\n\t\t\tprevArg := args[len(args)-1]\n\t\t\tif isFlagArg(prevArg) {\n\t\t\t\t// Only consider the case where the flag does not contain an =.\n\t\t\t\t// If the flag contains an = it means it has already been fully processed,\n\t\t\t\t// so we don't need to deal with it here.\n\t\t\t\tif index := strings.Index(prevArg, \"=\"); index < 0 {\n\t\t\t\t\tif strings.HasPrefix(prevArg, \"--\") {\n\t\t\t\t\t\t// Flag has full name\n\t\t\t\t\t\tflagName = prevArg[2:]\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Flag is shorthand\n\t\t\t\t\t\t// We have to get the last shorthand flag name\n\t\t\t\t\t\t// e.g. `-asd` => d to provide the correct completion\n\t\t\t\t\t\t// https://github.com/spf13/cobra/issues/1257\n\t\t\t\t\t\tflagName = prevArg[len(prevArg)-1:]\n\t\t\t\t\t}\n\t\t\t\t\t// Remove the uncompleted flag or else there could be an error created\n\t\t\t\t\t// for an invalid value for that flag\n\t\t\t\t\ttrimmedArgs = args[:len(args)-1]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(flagName) == 0 {\n\t\t// Not doing flag completion\n\t\treturn nil, trimmedArgs, lastArg, nil\n\t}\n\n\tflag := findFlag(finalCmd, flagName)\n\tif flag == nil {\n\t\t// Flag not supported by this command, the interspersed option might be set so return the original args\n\t\treturn nil, args, orgLastArg, &flagCompError{subCommand: finalCmd.Name(), flagName: flagName}\n\t}\n\n\tif !flagWithEqual {\n\t\tif len(flag.NoOptDefVal) != 0 {\n\t\t\t// We had assumed dealing with a two-word flag but the flag is a boolean flag.\n\t\t\t// In that case, there is no value following it, so we are not really doing flag completion.\n\t\t\t// Reset everything to do noun completion.\n\t\t\ttrimmedArgs = args\n\t\t\tflag = nil\n\t\t}\n\t}\n\n\treturn flag, trimmedArgs, lastArg, nil\n}",
    "importString": "",
    "lineNum": 84,
    "relativeDocumentPath": "completions.go"
  },
  {
    "symbolName": "(*Command).InitDefaultCompletionCmd",
    "sourceCode": "func (c *Command) InitDefaultCompletionCmd(args ...string) {\n\tif c.CompletionOptions.DisableDefaultCmd {\n\t\treturn\n\t}\n\n\tfor _, cmd := range c.commands {\n\t\tif cmd.Name() == compCmdName || cmd.HasAlias(compCmdName) {\n\t\t\t// A completion command is already available\n\t\t\treturn\n\t\t}\n\t}\n\n\thaveNoDescFlag := !c.CompletionOptions.DisableNoDescFlag && !c.CompletionOptions.DisableDescriptions\n\n\t// Special case to know if there are sub-commands or not.\n\thasSubCommands := false\n\tfor _, cmd := range c.commands {\n\t\tif cmd.Name() != ShellCompRequestCmd && cmd.Name() != helpCommandName {\n\t\t\t// We found a real sub-command (not 'help' or '__complete')\n\t\t\thasSubCommands = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tcompletionCmd := &Command{\n\t\tUse:   compCmdName,\n\t\tShort: \"Generate the autocompletion script for the specified shell\",\n\t\tLong: fmt.Sprintf(`Generate the autocompletion script for %[1]s for the specified shell.\nSee each sub-command's help for details on how to use the generated script.\n`, c.Root().Name()),\n\t\tArgs:              NoArgs,\n\t\tValidArgsFunction: NoFileCompletions,\n\t\tHidden:            c.CompletionOptions.HiddenDefaultCmd,\n\t\tGroupID:           c.completionCommandGroupID,\n\t}\n\tc.AddCommand(completionCmd)\n\n\tif !hasSubCommands {\n\t\t// If the 'completion' command will be the only sub-command,\n\t\t// we only create it if it is actually being called.\n\t\t// This avoids breaking programs that would suddenly find themselves with\n\t\t// a subcommand, which would prevent them from accepting arguments.\n\t\t// We also create the 'completion' command if the user is triggering\n\t\t// shell completion for it (prog __complete completion '')\n\t\tsubCmd, cmdArgs, err := c.Find(args)\n\t\tif err != nil || subCmd.Name() != compCmdName &&\n\t\t\t!(subCmd.Name() == ShellCompRequestCmd && len(cmdArgs) > 1 && cmdArgs[0] == compCmdName) {\n\t\t\t// The completion command is not being called or being completed so we remove it.\n\t\t\tc.RemoveCommand(completionCmd)\n\t\t\treturn\n\t\t}\n\t}\n\n\tout := c.OutOrStdout()\n\tnoDesc := c.CompletionOptions.DisableDescriptions\n\tshortDesc := \"Generate the autocompletion script for %s\"\n\tbash := &Command{\n\t\tUse:   \"bash\",\n\t\tShort: fmt.Sprintf(shortDesc, \"bash\"),\n\t\tLong: fmt.Sprintf(`Generate the autocompletion script for the bash shell.\n\nThis script depends on the 'bash-completion' package.\nIf it is not installed already, you can install it via your OS's package manager.\n\nTo load completions in your current shell session:\n\n\tsource <(%[1]s completion bash)\n\nTo load completions for every new session, execute once:\n\n#### Linux:\n\n\t%[1]s completion bash > /etc/bash_completion.d/%[1]s\n\n#### macOS:\n\n\t%[1]s completion bash > $(brew --prefix)/etc/bash_completion.d/%[1]s\n\nYou will need to start a new shell for this setup to take effect.\n`, c.Root().Name()),\n\t\tArgs:                  NoArgs,\n\t\tDisableFlagsInUseLine: true,\n\t\tValidArgsFunction:     NoFileCompletions,\n\t\tRunE: func(cmd *Command, args []string) error {\n\t\t\treturn cmd.Root().GenBashCompletionV2(out, !noDesc)\n\t\t},\n\t}\n\tif haveNoDescFlag {\n\t\tbash.Flags().BoolVar(&noDesc, compCmdNoDescFlagName, compCmdNoDescFlagDefault, compCmdNoDescFlagDesc)\n\t}\n\n\tzsh := &Command{\n\t\tUse:   \"zsh\",\n\t\tShort: fmt.Sprintf(shortDesc, \"zsh\"),\n\t\tLong: fmt.Sprintf(`Generate the autocompletion script for the zsh shell.\n\nIf shell completion is not already enabled in your environment you will need\nto enable it.  You can execute the following once:\n\n\techo \"autoload -U compinit; compinit\" >> ~/.zshrc\n\nTo load completions in your current shell session:\n\n\tsource <(%[1]s completion zsh)\n\nTo load completions for every new session, execute once:\n\n#### Linux:\n\n\t%[1]s completion zsh > \"${fpath[1]}/_%[1]s\"\n\n#### macOS:\n\n\t%[1]s completion zsh > $(brew --prefix)/share/zsh/site-functions/_%[1]s\n\nYou will need to start a new shell for this setup to take effect.\n`, c.Root().Name()),\n\t\tArgs:              NoArgs,\n\t\tValidArgsFunction: NoFileCompletions,\n\t\tRunE: func(cmd *Command, args []string) error {\n\t\t\tif noDesc {\n\t\t\t\treturn cmd.Root().GenZshCompletionNoDesc(out)\n\t\t\t}\n\t\t\treturn cmd.Root().GenZshCompletion(out)\n\t\t},\n\t}\n\tif haveNoDescFlag {\n\t\tzsh.Flags().BoolVar(&noDesc, compCmdNoDescFlagName, compCmdNoDescFlagDefault, compCmdNoDescFlagDesc)\n\t}\n\n\tfish := &Command{\n\t\tUse:   \"fish\",\n\t\tShort: fmt.Sprintf(shortDesc, \"fish\"),\n\t\tLong: fmt.Sprintf(`Generate the autocompletion script for the fish shell.\n\nTo load completions in your current shell session:\n\n\t%[1]s completion fish | source\n\nTo load completions for every new session, execute once:\n\n\t%[1]s completion fish > ~/.config/fish/completions/%[1]s.fish\n\nYou will need to start a new shell for this setup to take effect.\n`, c.Root().Name()),\n\t\tArgs:              NoArgs,\n\t\tValidArgsFunction: NoFileCompletions,\n\t\tRunE: func(cmd *Command, args []string) error {\n\t\t\treturn cmd.Root().GenFishCompletion(out, !noDesc)\n\t\t},\n\t}\n\tif haveNoDescFlag {\n\t\tfish.Flags().BoolVar(&noDesc, compCmdNoDescFlagName, compCmdNoDescFlagDefault, compCmdNoDescFlagDesc)\n\t}\n\n\tpowershell := &Command{\n\t\tUse:   \"powershell\",\n\t\tShort: fmt.Sprintf(shortDesc, \"powershell\"),\n\t\tLong: fmt.Sprintf(`Generate the autocompletion script for powershell.\n\nTo load completions in your current shell session:\n\n\t%[1]s completion powershell | Out-String | Invoke-Expression\n\nTo load completions for every new session, add the output of the above command\nto your powershell profile.\n`, c.Root().Name()),\n\t\tArgs:              NoArgs,\n\t\tValidArgsFunction: NoFileCompletions,\n\t\tRunE: func(cmd *Command, args []string) error {\n\t\t\tif noDesc {\n\t\t\t\treturn cmd.Root().GenPowerShellCompletion(out)\n\t\t\t}\n\t\t\treturn cmd.Root().GenPowerShellCompletionWithDesc(out)\n\n\t\t},\n\t}\n\tif haveNoDescFlag {\n\t\tpowershell.Flags().BoolVar(&noDesc, compCmdNoDescFlagName, compCmdNoDescFlagDefault, compCmdNoDescFlagDesc)\n\t}\n\n\tcompletionCmd.AddCommand(bash, zsh, fish, powershell)\n}",
    "importString": "",
    "lineNum": 182,
    "relativeDocumentPath": "completions.go"
  },
  {
    "symbolName": "findFlag",
    "sourceCode": "func findFlag(cmd *Command, name string) *pflag.Flag {\n\tflagSet := cmd.Flags()\n\tif len(name) == 1 {\n\t\t// First convert the short flag into a long flag\n\t\t// as the cmd.Flag() search only accepts long flags\n\t\tif short := flagSet.ShorthandLookup(name); short != nil {\n\t\t\tname = short.Name\n\t\t} else {\n\t\t\tset := cmd.InheritedFlags()\n\t\t\tif short = set.ShorthandLookup(name); short != nil {\n\t\t\t\tname = short.Name\n\t\t\t} else {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n\treturn cmd.Flag(name)\n}",
    "importString": "",
    "lineNum": 17,
    "relativeDocumentPath": "completions.go"
  },
  {
    "symbolName": "CompDebug",
    "sourceCode": "func CompDebug(msg string, printToStdErr bool) {\n\tmsg = fmt.Sprintf(\"[Debug] %s\", msg)\n\n\t// Such logs are only printed when the user has set the environment\n\t// variable BASH_COMP_DEBUG_FILE to the path of some file to be used.\n\tif path := os.Getenv(\"BASH_COMP_DEBUG_FILE\"); path != \"\" {\n\t\tf, err := os.OpenFile(path,\n\t\t\tos.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)\n\t\tif err == nil {\n\t\t\tdefer f.Close()\n\t\t\tWriteStringAndCheck(f, msg)\n\t\t}\n\t}\n\n\tif printToStdErr {\n\t\t// Must print to stderr for this not to be read by the completion script.\n\t\tfmt.Fprint(os.Stderr, msg)\n\t}\n}",
    "importString": "",
    "lineNum": 18,
    "relativeDocumentPath": "completions.go"
  },
  {
    "symbolName": "GenManTreeFromOpts",
    "sourceCode": "func GenManTreeFromOpts(cmd *cobra.Command, opts GenManTreeOptions) error {\n\theader := opts.Header\n\tif header == nil {\n\t\theader = &GenManHeader{}\n\t}\n\tfor _, c := range cmd.Commands() {\n\t\tif !c.IsAvailableCommand() || c.IsAdditionalHelpTopicCommand() {\n\t\t\tcontinue\n\t\t}\n\t\tif err := GenManTreeFromOpts(c, opts); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tsection := \"1\"\n\tif header.Section != \"\" {\n\t\tsection = header.Section\n\t}\n\n\tseparator := \"_\"\n\tif opts.CommandSeparator != \"\" {\n\t\tseparator = opts.CommandSeparator\n\t}\n\tbasename := strings.ReplaceAll(cmd.CommandPath(), \" \", separator)\n\tfilename := filepath.Join(opts.Path, basename+\".\"+section)\n\tf, err := os.Create(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\n\theaderCopy := *header\n\treturn GenMan(cmd, &headerCopy, f)\n}",
    "importString": "",
    "lineNum": 32,
    "relativeDocumentPath": "doc/man_docs.go"
  },
  {
    "symbolName": "GenMan",
    "sourceCode": "func GenMan(cmd *cobra.Command, header *GenManHeader, w io.Writer) error {\n\tif header == nil {\n\t\theader = &GenManHeader{}\n\t}\n\tif err := fillHeader(header, cmd.CommandPath(), cmd.DisableAutoGenTag); err != nil {\n\t\treturn err\n\t}\n\n\tb := genMan(cmd, header)\n\t_, err := w.Write(md2man.Render(b))\n\treturn err\n}",
    "importString": "",
    "lineNum": 11,
    "relativeDocumentPath": "doc/man_docs.go"
  },
  {
    "symbolName": "fillHeader",
    "sourceCode": "func fillHeader(header *GenManHeader, name string, disableAutoGen bool) error {\n\tif header.Title == \"\" {\n\t\theader.Title = strings.ToUpper(strings.ReplaceAll(name, \" \", \"\\\\-\"))\n\t}\n\tif header.Section == \"\" {\n\t\theader.Section = \"1\"\n\t}\n\tif header.Date == nil {\n\t\tnow := time.Now()\n\t\tif epoch := os.Getenv(\"SOURCE_DATE_EPOCH\"); epoch != \"\" {\n\t\t\tunixEpoch, err := strconv.ParseInt(epoch, 10, 64)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"invalid SOURCE_DATE_EPOCH: %v\", err)\n\t\t\t}\n\t\t\tnow = time.Unix(unixEpoch, 0)\n\t\t}\n\t\theader.Date = &now\n\t}\n\theader.date = header.Date.Format(\"Jan 2006\")\n\tif header.Source == \"\" && !disableAutoGen {\n\t\theader.Source = \"Auto generated by spf13/cobra\"\n\t}\n\treturn nil\n}",
    "importString": "",
    "lineNum": 23,
    "relativeDocumentPath": "doc/man_docs.go"
  },
  {
    "symbolName": "manPreamble",
    "sourceCode": "func manPreamble(buf io.StringWriter, header *GenManHeader, cmd *cobra.Command, dashedName string) {\n\tdescription := cmd.Long\n\tif len(description) == 0 {\n\t\tdescription = cmd.Short\n\t}\n\n\tcobra.WriteStringAndCheck(buf, fmt.Sprintf(`%% \"%s\" \"%s\" \"%s\" \"%s\" \"%s\"\n# NAME\n`, header.Title, header.Section, header.date, header.Source, header.Manual))\n\tcobra.WriteStringAndCheck(buf, fmt.Sprintf(\"%s \\\\- %s\\n\\n\", dashedName, cmd.Short))\n\tcobra.WriteStringAndCheck(buf, \"# SYNOPSIS\\n\")\n\tcobra.WriteStringAndCheck(buf, fmt.Sprintf(\"**%s**\\n\\n\", cmd.UseLine()))\n\tcobra.WriteStringAndCheck(buf, \"# DESCRIPTION\\n\")\n\tcobra.WriteStringAndCheck(buf, description+\"\\n\\n\")\n}",
    "importString": "",
    "lineNum": 14,
    "relativeDocumentPath": "doc/man_docs.go"
  },
  {
    "symbolName": "manPrintFlags",
    "sourceCode": "func manPrintFlags(buf io.StringWriter, flags *pflag.FlagSet) {\n\tflags.VisitAll(func(flag *pflag.Flag) {\n\t\tif len(flag.Deprecated) > 0 || flag.Hidden {\n\t\t\treturn\n\t\t}\n\t\tformat := \"\"\n\t\tif len(flag.Shorthand) > 0 && len(flag.ShorthandDeprecated) == 0 {\n\t\t\tformat = fmt.Sprintf(\"**-%s**, **--%s**\", flag.Shorthand, flag.Name)\n\t\t} else {\n\t\t\tformat = fmt.Sprintf(\"**--%s**\", flag.Name)\n\t\t}\n\t\tif len(flag.NoOptDefVal) > 0 {\n\t\t\tformat += \"[\"\n\t\t}\n\t\tif flag.Value.Type() == \"string\" {\n\t\t\t// put quotes on the value\n\t\t\tformat += \"=%q\"\n\t\t} else {\n\t\t\tformat += \"=%s\"\n\t\t}\n\t\tif len(flag.NoOptDefVal) > 0 {\n\t\t\tformat += \"]\"\n\t\t}\n\t\tformat += \"\\n\\t%s\\n\\n\"\n\t\tcobra.WriteStringAndCheck(buf, fmt.Sprintf(format, flag.DefValue, flag.Usage))\n\t})\n}",
    "importString": "",
    "lineNum": 26,
    "relativeDocumentPath": "doc/man_docs.go"
  },
  {
    "symbolName": "manPrintOptions",
    "sourceCode": "func manPrintOptions(buf io.StringWriter, command *cobra.Command) {\n\tflags := command.NonInheritedFlags()\n\tif flags.HasAvailableFlags() {\n\t\tcobra.WriteStringAndCheck(buf, \"# OPTIONS\\n\")\n\t\tmanPrintFlags(buf, flags)\n\t\tcobra.WriteStringAndCheck(buf, \"\\n\")\n\t}\n\tflags = command.InheritedFlags()\n\tif flags.HasAvailableFlags() {\n\t\tcobra.WriteStringAndCheck(buf, \"# OPTIONS INHERITED FROM PARENT COMMANDS\\n\")\n\t\tmanPrintFlags(buf, flags)\n\t\tcobra.WriteStringAndCheck(buf, \"\\n\")\n\t}\n}",
    "importString": "",
    "lineNum": 13,
    "relativeDocumentPath": "doc/man_docs.go"
  },
  {
    "symbolName": "genMan",
    "sourceCode": "func genMan(cmd *cobra.Command, header *GenManHeader) []byte {\n\tcmd.InitDefaultHelpCmd()\n\tcmd.InitDefaultHelpFlag()\n\n\t// something like `rootcmd-subcmd1-subcmd2`\n\tdashCommandName := strings.ReplaceAll(cmd.CommandPath(), \" \", \"-\")\n\n\tbuf := new(bytes.Buffer)\n\n\tmanPreamble(buf, header, cmd, dashCommandName)\n\tmanPrintOptions(buf, cmd)\n\tif len(cmd.Example) > 0 {\n\t\tbuf.WriteString(\"# EXAMPLE\\n\")\n\t\tbuf.WriteString(fmt.Sprintf(\"```\\n%s\\n```\\n\", cmd.Example))\n\t}\n\tif hasSeeAlso(cmd) {\n\t\tbuf.WriteString(\"# SEE ALSO\\n\")\n\t\tseealsos := make([]string, 0)\n\t\tif cmd.HasParent() {\n\t\t\tparentPath := cmd.Parent().CommandPath()\n\t\t\tdashParentPath := strings.ReplaceAll(parentPath, \" \", \"-\")\n\t\t\tseealso := fmt.Sprintf(\"**%s(%s)**\", dashParentPath, header.Section)\n\t\t\tseealsos = append(seealsos, seealso)\n\t\t\tcmd.VisitParents(func(c *cobra.Command) {\n\t\t\t\tif c.DisableAutoGenTag {\n\t\t\t\t\tcmd.DisableAutoGenTag = c.DisableAutoGenTag\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t\tchildren := cmd.Commands()\n\t\tsort.Sort(byName(children))\n\t\tfor _, c := range children {\n\t\t\tif !c.IsAvailableCommand() || c.IsAdditionalHelpTopicCommand() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tseealso := fmt.Sprintf(\"**%s-%s(%s)**\", dashCommandName, c.Name(), header.Section)\n\t\t\tseealsos = append(seealsos, seealso)\n\t\t}\n\t\tbuf.WriteString(strings.Join(seealsos, \", \") + \"\\n\")\n\t}\n\tif !cmd.DisableAutoGenTag {\n\t\tbuf.WriteString(fmt.Sprintf(\"# HISTORY\\n%s Auto generated by spf13/cobra\\n\", header.Date.Format(\"2-Jan-2006\")))\n\t}\n\treturn buf.Bytes()\n}",
    "importString": "",
    "lineNum": 44,
    "relativeDocumentPath": "doc/man_docs.go"
  },
  {
    "symbolName": "printOptions",
    "sourceCode": "func printOptions(buf *bytes.Buffer, cmd *cobra.Command, name string) error {\n\tflags := cmd.NonInheritedFlags()\n\tflags.SetOutput(buf)\n\tif flags.HasAvailableFlags() {\n\t\tbuf.WriteString(\"### Options\\n\\n```\\n\")\n\t\tflags.PrintDefaults()\n\t\tbuf.WriteString(\"```\\n\\n\")\n\t}\n\n\tparentFlags := cmd.InheritedFlags()\n\tparentFlags.SetOutput(buf)\n\tif parentFlags.HasAvailableFlags() {\n\t\tbuf.WriteString(\"### Options inherited from parent commands\\n\\n```\\n\")\n\t\tparentFlags.PrintDefaults()\n\t\tbuf.WriteString(\"```\\n\\n\")\n\t}\n\treturn nil\n}",
    "importString": "",
    "lineNum": 17,
    "relativeDocumentPath": "doc/md_docs.go"
  },
  {
    "symbolName": "GenMarkdownCustom",
    "sourceCode": "func GenMarkdownCustom(cmd *cobra.Command, w io.Writer, linkHandler func(string) string) error {\n\tcmd.InitDefaultHelpCmd()\n\tcmd.InitDefaultHelpFlag()\n\n\tbuf := new(bytes.Buffer)\n\tname := cmd.CommandPath()\n\n\tbuf.WriteString(\"## \" + name + \"\\n\\n\")\n\tbuf.WriteString(cmd.Short + \"\\n\\n\")\n\tif len(cmd.Long) > 0 {\n\t\tbuf.WriteString(\"### Synopsis\\n\\n\")\n\t\tbuf.WriteString(cmd.Long + \"\\n\\n\")\n\t}\n\n\tif cmd.Runnable() {\n\t\tbuf.WriteString(fmt.Sprintf(\"```\\n%s\\n```\\n\\n\", cmd.UseLine()))\n\t}\n\n\tif len(cmd.Example) > 0 {\n\t\tbuf.WriteString(\"### Examples\\n\\n\")\n\t\tbuf.WriteString(fmt.Sprintf(\"```\\n%s\\n```\\n\\n\", cmd.Example))\n\t}\n\n\tif err := printOptions(buf, cmd, name); err != nil {\n\t\treturn err\n\t}\n\tif hasSeeAlso(cmd) {\n\t\tbuf.WriteString(\"### SEE ALSO\\n\\n\")\n\t\tif cmd.HasParent() {\n\t\t\tparent := cmd.Parent()\n\t\t\tpname := parent.CommandPath()\n\t\t\tlink := pname + markdownExtension\n\t\t\tlink = strings.ReplaceAll(link, \" \", \"_\")\n\t\t\tbuf.WriteString(fmt.Sprintf(\"* [%s](%s)\\t - %s\\n\", pname, linkHandler(link), parent.Short))\n\t\t\tcmd.VisitParents(func(c *cobra.Command) {\n\t\t\t\tif c.DisableAutoGenTag {\n\t\t\t\t\tcmd.DisableAutoGenTag = c.DisableAutoGenTag\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\tchildren := cmd.Commands()\n\t\tsort.Sort(byName(children))\n\n\t\tfor _, child := range children {\n\t\t\tif !child.IsAvailableCommand() || child.IsAdditionalHelpTopicCommand() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tcname := name + \" \" + child.Name()\n\t\t\tlink := cname + markdownExtension\n\t\t\tlink = strings.ReplaceAll(link, \" \", \"_\")\n\t\t\tbuf.WriteString(fmt.Sprintf(\"* [%s](%s)\\t - %s\\n\", cname, linkHandler(link), child.Short))\n\t\t}\n\t\tbuf.WriteString(\"\\n\")\n\t}\n\tif !cmd.DisableAutoGenTag {\n\t\tbuf.WriteString(\"###### Auto generated by spf13/cobra on \" + time.Now().Format(\"2-Jan-2006\") + \"\\n\")\n\t}\n\t_, err := buf.WriteTo(w)\n\treturn err\n}",
    "importString": "",
    "lineNum": 60,
    "relativeDocumentPath": "doc/md_docs.go"
  },
  {
    "symbolName": "GenMarkdownTreeCustom",
    "sourceCode": "func GenMarkdownTreeCustom(cmd *cobra.Command, dir string, filePrepender, linkHandler func(string) string) error {\n\tfor _, c := range cmd.Commands() {\n\t\tif !c.IsAvailableCommand() || c.IsAdditionalHelpTopicCommand() {\n\t\t\tcontinue\n\t\t}\n\t\tif err := GenMarkdownTreeCustom(c, dir, filePrepender, linkHandler); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tbasename := strings.ReplaceAll(cmd.CommandPath(), \" \", \"_\") + markdownExtension\n\tfilename := filepath.Join(dir, basename)\n\tf, err := os.Create(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\n\tif _, err := io.WriteString(f, filePrepender(filename)); err != nil {\n\t\treturn err\n\t}\n\tif err := GenMarkdownCustom(cmd, f, linkHandler); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}",
    "importString": "",
    "lineNum": 25,
    "relativeDocumentPath": "doc/md_docs.go"
  },
  {
    "symbolName": "printOptionsReST",
    "sourceCode": "func printOptionsReST(buf *bytes.Buffer, cmd *cobra.Command, name string) error {\n\tflags := cmd.NonInheritedFlags()\n\tflags.SetOutput(buf)\n\tif flags.HasAvailableFlags() {\n\t\tbuf.WriteString(\"Options\\n\")\n\t\tbuf.WriteString(\"~~~~~~~\\n\\n::\\n\\n\")\n\t\tflags.PrintDefaults()\n\t\tbuf.WriteString(\"\\n\")\n\t}\n\n\tparentFlags := cmd.InheritedFlags()\n\tparentFlags.SetOutput(buf)\n\tif parentFlags.HasAvailableFlags() {\n\t\tbuf.WriteString(\"Options inherited from parent commands\\n\")\n\t\tbuf.WriteString(\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\\n::\\n\\n\")\n\t\tparentFlags.PrintDefaults()\n\t\tbuf.WriteString(\"\\n\")\n\t}\n\treturn nil\n}",
    "importString": "",
    "lineNum": 19,
    "relativeDocumentPath": "doc/rest_docs.go"
  },
  {
    "symbolName": "GenReSTCustom",
    "sourceCode": "func GenReSTCustom(cmd *cobra.Command, w io.Writer, linkHandler func(string, string) string) error {\n\tcmd.InitDefaultHelpCmd()\n\tcmd.InitDefaultHelpFlag()\n\n\tbuf := new(bytes.Buffer)\n\tname := cmd.CommandPath()\n\n\tshort := cmd.Short\n\tlong := cmd.Long\n\tif len(long) == 0 {\n\t\tlong = short\n\t}\n\tref := strings.ReplaceAll(name, \" \", \"_\")\n\n\tbuf.WriteString(\".. _\" + ref + \":\\n\\n\")\n\tbuf.WriteString(name + \"\\n\")\n\tbuf.WriteString(strings.Repeat(\"-\", len(name)) + \"\\n\\n\")\n\tbuf.WriteString(short + \"\\n\\n\")\n\tbuf.WriteString(\"Synopsis\\n\")\n\tbuf.WriteString(\"~~~~~~~~\\n\\n\")\n\tbuf.WriteString(\"\\n\" + long + \"\\n\\n\")\n\n\tif cmd.Runnable() {\n\t\tbuf.WriteString(fmt.Sprintf(\"::\\n\\n  %s\\n\\n\", cmd.UseLine()))\n\t}\n\n\tif len(cmd.Example) > 0 {\n\t\tbuf.WriteString(\"Examples\\n\")\n\t\tbuf.WriteString(\"~~~~~~~~\\n\\n\")\n\t\tbuf.WriteString(fmt.Sprintf(\"::\\n\\n%s\\n\\n\", indentString(cmd.Example, \"  \")))\n\t}\n\n\tif err := printOptionsReST(buf, cmd, name); err != nil {\n\t\treturn err\n\t}\n\tif hasSeeAlso(cmd) {\n\t\tbuf.WriteString(\"SEE ALSO\\n\")\n\t\tbuf.WriteString(\"~~~~~~~~\\n\\n\")\n\t\tif cmd.HasParent() {\n\t\t\tparent := cmd.Parent()\n\t\t\tpname := parent.CommandPath()\n\t\t\tref = strings.ReplaceAll(pname, \" \", \"_\")\n\t\t\tbuf.WriteString(fmt.Sprintf(\"* %s \\t - %s\\n\", linkHandler(pname, ref), parent.Short))\n\t\t\tcmd.VisitParents(func(c *cobra.Command) {\n\t\t\t\tif c.DisableAutoGenTag {\n\t\t\t\t\tcmd.DisableAutoGenTag = c.DisableAutoGenTag\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\tchildren := cmd.Commands()\n\t\tsort.Sort(byName(children))\n\n\t\tfor _, child := range children {\n\t\t\tif !child.IsAvailableCommand() || child.IsAdditionalHelpTopicCommand() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tcname := name + \" \" + child.Name()\n\t\t\tref = strings.ReplaceAll(cname, \" \", \"_\")\n\t\t\tbuf.WriteString(fmt.Sprintf(\"* %s \\t - %s\\n\", linkHandler(cname, ref), child.Short))\n\t\t}\n\t\tbuf.WriteString(\"\\n\")\n\t}\n\tif !cmd.DisableAutoGenTag {\n\t\tbuf.WriteString(\"*Auto generated by spf13/cobra on \" + time.Now().Format(\"2-Jan-2006\") + \"*\\n\")\n\t}\n\t_, err := buf.WriteTo(w)\n\treturn err\n}",
    "importString": "",
    "lineNum": 68,
    "relativeDocumentPath": "doc/rest_docs.go"
  },
  {
    "symbolName": "GenReSTTreeCustom",
    "sourceCode": "func GenReSTTreeCustom(cmd *cobra.Command, dir string, filePrepender func(string) string, linkHandler func(string, string) string) error {\n\tfor _, c := range cmd.Commands() {\n\t\tif !c.IsAvailableCommand() || c.IsAdditionalHelpTopicCommand() {\n\t\t\tcontinue\n\t\t}\n\t\tif err := GenReSTTreeCustom(c, dir, filePrepender, linkHandler); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tbasename := strings.ReplaceAll(cmd.CommandPath(), \" \", \"_\") + \".rst\"\n\tfilename := filepath.Join(dir, basename)\n\tf, err := os.Create(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\n\tif _, err := io.WriteString(f, filePrepender(filename)); err != nil {\n\t\treturn err\n\t}\n\tif err := GenReSTCustom(cmd, f, linkHandler); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}",
    "importString": "",
    "lineNum": 25,
    "relativeDocumentPath": "doc/rest_docs.go"
  },
  {
    "symbolName": "indentString",
    "sourceCode": "func indentString(s, p string) string {\n\tvar res []byte\n\tb := []byte(s)\n\tprefix := []byte(p)\n\tbol := true\n\tfor _, c := range b {\n\t\tif bol && c != '\\n' {\n\t\t\tres = append(res, prefix...)\n\t\t}\n\t\tres = append(res, c)\n\t\tbol = c == '\\n'\n\t}\n\treturn string(res)\n}",
    "importString": "",
    "lineNum": 13,
    "relativeDocumentPath": "doc/rest_docs.go"
  },
  {
    "symbolName": "hasSeeAlso",
    "sourceCode": "func hasSeeAlso(cmd *cobra.Command) bool {\n\tif cmd.HasParent() {\n\t\treturn true\n\t}\n\tfor _, c := range cmd.Commands() {\n\t\tif !c.IsAvailableCommand() || c.IsAdditionalHelpTopicCommand() {\n\t\t\tcontinue\n\t\t}\n\t\treturn true\n\t}\n\treturn false\n}",
    "importString": "",
    "lineNum": 11,
    "relativeDocumentPath": "doc/util.go"
  },
  {
    "symbolName": "GenYamlTreeCustom",
    "sourceCode": "func GenYamlTreeCustom(cmd *cobra.Command, dir string, filePrepender, linkHandler func(string) string) error {\n\tfor _, c := range cmd.Commands() {\n\t\tif !c.IsAvailableCommand() || c.IsAdditionalHelpTopicCommand() {\n\t\t\tcontinue\n\t\t}\n\t\tif err := GenYamlTreeCustom(c, dir, filePrepender, linkHandler); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tbasename := strings.ReplaceAll(cmd.CommandPath(), \" \", \"_\") + \".yaml\"\n\tfilename := filepath.Join(dir, basename)\n\tf, err := os.Create(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\n\tif _, err := io.WriteString(f, filePrepender(filename)); err != nil {\n\t\treturn err\n\t}\n\tif err := GenYamlCustom(cmd, f, linkHandler); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}",
    "importString": "",
    "lineNum": 25,
    "relativeDocumentPath": "doc/yaml_docs.go"
  },
  {
    "symbolName": "GenYamlCustom",
    "sourceCode": "func GenYamlCustom(cmd *cobra.Command, w io.Writer, linkHandler func(string) string) error {\n\tcmd.InitDefaultHelpCmd()\n\tcmd.InitDefaultHelpFlag()\n\n\tyamlDoc := cmdDoc{}\n\tyamlDoc.Name = cmd.CommandPath()\n\n\tyamlDoc.Synopsis = forceMultiLine(cmd.Short)\n\tyamlDoc.Description = forceMultiLine(cmd.Long)\n\n\tif cmd.Runnable() {\n\t\tyamlDoc.Usage = cmd.UseLine()\n\t}\n\n\tif len(cmd.Example) > 0 {\n\t\tyamlDoc.Example = cmd.Example\n\t}\n\n\tflags := cmd.NonInheritedFlags()\n\tif flags.HasFlags() {\n\t\tyamlDoc.Options = genFlagResult(flags)\n\t}\n\tflags = cmd.InheritedFlags()\n\tif flags.HasFlags() {\n\t\tyamlDoc.InheritedOptions = genFlagResult(flags)\n\t}\n\n\tif hasSeeAlso(cmd) {\n\t\tresult := []string{}\n\t\tif cmd.HasParent() {\n\t\t\tparent := cmd.Parent()\n\t\t\tresult = append(result, parent.CommandPath()+\" - \"+parent.Short)\n\t\t}\n\t\tchildren := cmd.Commands()\n\t\tsort.Sort(byName(children))\n\t\tfor _, child := range children {\n\t\t\tif !child.IsAvailableCommand() || child.IsAdditionalHelpTopicCommand() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tresult = append(result, child.CommandPath()+\" - \"+child.Short)\n\t\t}\n\t\tyamlDoc.SeeAlso = result\n\t}\n\n\tfinal, err := yaml.Marshal(&yamlDoc)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n\n\tif _, err := w.Write(final); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}",
    "importString": "",
    "lineNum": 54,
    "relativeDocumentPath": "doc/yaml_docs.go"
  },
  {
    "symbolName": "genFlagResult",
    "sourceCode": "func genFlagResult(flags *pflag.FlagSet) []cmdOption {\n\tvar result []cmdOption\n\n\tflags.VisitAll(func(flag *pflag.Flag) {\n\t\t// Todo, when we mark a shorthand is deprecated, but specify an empty message.\n\t\t// The flag.ShorthandDeprecated is empty as the shorthand is deprecated.\n\t\t// Using len(flag.ShorthandDeprecated) > 0 can't handle this, others are ok.\n\t\tif !(len(flag.ShorthandDeprecated) > 0) && len(flag.Shorthand) > 0 {\n\t\t\topt := cmdOption{\n\t\t\t\tflag.Name,\n\t\t\t\tflag.Shorthand,\n\t\t\t\tflag.DefValue,\n\t\t\t\tforceMultiLine(flag.Usage),\n\t\t\t}\n\t\t\tresult = append(result, opt)\n\t\t} else {\n\t\t\topt := cmdOption{\n\t\t\t\tName:         flag.Name,\n\t\t\t\tDefaultValue: forceMultiLine(flag.DefValue),\n\t\t\t\tUsage:        forceMultiLine(flag.Usage),\n\t\t\t}\n\t\t\tresult = append(result, opt)\n\t\t}\n\t})\n\n\treturn result\n}",
    "importString": "",
    "lineNum": 26,
    "relativeDocumentPath": "doc/yaml_docs.go"
  },
  {
    "symbolName": "genFishComp",
    "sourceCode": "func genFishComp(buf io.StringWriter, name string, includeDesc bool) {\n\t// Variables should not contain a '-' or ':' character\n\tnameForVar := name\n\tnameForVar = strings.ReplaceAll(nameForVar, \"-\", \"_\")\n\tnameForVar = strings.ReplaceAll(nameForVar, \":\", \"_\")\n\n\tcompCmd := ShellCompRequestCmd\n\tif !includeDesc {\n\t\tcompCmd = ShellCompNoDescRequestCmd\n\t}\n\tWriteStringAndCheck(buf, fmt.Sprintf(\"# fish completion for %-36s -*- shell-script -*-\\n\", name))\n\tWriteStringAndCheck(buf, fmt.Sprintf(`\nfunction __%[1]s_debug\n    set -l file \"$BASH_COMP_DEBUG_FILE\"\n    if test -n \"$file\"\n        echo \"$argv\" >> $file\n    end\nend\n\nfunction __%[1]s_perform_completion\n    __%[1]s_debug \"Starting __%[1]s_perform_completion\"\n\n    # Extract all args except the last one\n    set -l args (commandline -opc)\n    # Extract the last arg and escape it in case it is a space\n    set -l lastArg (string escape -- (commandline -ct))\n\n    __%[1]s_debug \"args: $args\"\n    __%[1]s_debug \"last arg: $lastArg\"\n\n    # Disable ActiveHelp which is not supported for fish shell\n    set -l requestComp \"%[10]s=0 $args[1] %[3]s $args[2..-1] $lastArg\"\n\n    __%[1]s_debug \"Calling $requestComp\"\n    set -l results (eval $requestComp 2> /dev/null)\n\n    # Some programs may output extra empty lines after the directive.\n    # Let's ignore them or else it will break completion.\n    # Ref: https://github.com/spf13/cobra/issues/1279\n    for line in $results[-1..1]\n        if test (string trim -- $line) = \"\"\n            # Found an empty line, remove it\n            set results $results[1..-2]\n        else\n            # Found non-empty line, we have our proper output\n            break\n        end\n    end\n\n    set -l comps $results[1..-2]\n    set -l directiveLine $results[-1]\n\n    # For Fish, when completing a flag with an = (e.g., <program> -n=<TAB>)\n    # completions must be prefixed with the flag\n    set -l flagPrefix (string match -r -- '-.*=' \"$lastArg\")\n\n    __%[1]s_debug \"Comps: $comps\"\n    __%[1]s_debug \"DirectiveLine: $directiveLine\"\n    __%[1]s_debug \"flagPrefix: $flagPrefix\"\n\n    for comp in $comps\n        printf \"%%s%%s\\n\" \"$flagPrefix\" \"$comp\"\n    end\n\n    printf \"%%s\\n\" \"$directiveLine\"\nend\n\n# this function limits calls to __%[1]s_perform_completion, by caching the result behind $__%[1]s_perform_completion_once_result\nfunction __%[1]s_perform_completion_once\n    __%[1]s_debug \"Starting __%[1]s_perform_completion_once\"\n\n    if test -n \"$__%[1]s_perform_completion_once_result\"\n        __%[1]s_debug \"Seems like a valid result already exists, skipping __%[1]s_perform_completion\"\n        return 0\n    end\n\n    set --global __%[1]s_perform_completion_once_result (__%[1]s_perform_completion)\n    if test -z \"$__%[1]s_perform_completion_once_result\"\n        __%[1]s_debug \"No completions, probably due to a failure\"\n        return 1\n    end\n\n    __%[1]s_debug \"Performed completions and set __%[1]s_perform_completion_once_result\"\n    return 0\nend\n\n# this function is used to clear the $__%[1]s_perform_completion_once_result variable after completions are run\nfunction __%[1]s_clear_perform_completion_once_result\n    __%[1]s_debug \"\"\n    __%[1]s_debug \"========= clearing previously set __%[1]s_perform_completion_once_result variable ==========\"\n    set --erase __%[1]s_perform_completion_once_result\n    __%[1]s_debug \"Successfully erased the variable __%[1]s_perform_completion_once_result\"\nend\n\nfunction __%[1]s_requires_order_preservation\n    __%[1]s_debug \"\"\n    __%[1]s_debug \"========= checking if order preservation is required ==========\"\n\n    __%[1]s_perform_completion_once\n    if test -z \"$__%[1]s_perform_completion_once_result\"\n        __%[1]s_debug \"Error determining if order preservation is required\"\n        return 1\n    end\n\n    set -l directive (string sub --start 2 $__%[1]s_perform_completion_once_result[-1])\n    __%[1]s_debug \"Directive is: $directive\"\n\n    set -l shellCompDirectiveKeepOrder %[9]d\n    set -l keeporder (math (math --scale 0 $directive / $shellCompDirectiveKeepOrder) %% 2)\n    __%[1]s_debug \"Keeporder is: $keeporder\"\n\n    if test $keeporder -ne 0\n        __%[1]s_debug \"This does require order preservation\"\n        return 0\n    end\n\n    __%[1]s_debug \"This doesn't require order preservation\"\n    return 1\nend\n\n\n# This function does two things:\n# - Obtain the completions and store them in the global __%[1]s_comp_results\n# - Return false if file completion should be performed\nfunction __%[1]s_prepare_completions\n    __%[1]s_debug \"\"\n    __%[1]s_debug \"========= starting completion logic ==========\"\n\n    # Start fresh\n    set --erase __%[1]s_comp_results\n\n    __%[1]s_perform_completion_once\n    __%[1]s_debug \"Completion results: $__%[1]s_perform_completion_once_result\"\n\n    if test -z \"$__%[1]s_perform_completion_once_result\"\n        __%[1]s_debug \"No completion, probably due to a failure\"\n        # Might as well do file completion, in case it helps\n        return 1\n    end\n\n    set -l directive (string sub --start 2 $__%[1]s_perform_completion_once_result[-1])\n    set --global __%[1]s_comp_results $__%[1]s_perform_completion_once_result[1..-2]\n\n    __%[1]s_debug \"Completions are: $__%[1]s_comp_results\"\n    __%[1]s_debug \"Directive is: $directive\"\n\n    set -l shellCompDirectiveError %[4]d\n    set -l shellCompDirectiveNoSpace %[5]d\n    set -l shellCompDirectiveNoFileComp %[6]d\n    set -l shellCompDirectiveFilterFileExt %[7]d\n    set -l shellCompDirectiveFilterDirs %[8]d\n\n    if test -z \"$directive\"\n        set directive 0\n    end\n\n    set -l compErr (math (math --scale 0 $directive / $shellCompDirectiveError) %% 2)\n    if test $compErr -eq 1\n        __%[1]s_debug \"Received error directive: aborting.\"\n        # Might as well do file completion, in case it helps\n        return 1\n    end\n\n    set -l filefilter (math (math --scale 0 $directive / $shellCompDirectiveFilterFileExt) %% 2)\n    set -l dirfilter (math (math --scale 0 $directive / $shellCompDirectiveFilterDirs) %% 2)\n    if test $filefilter -eq 1; or test $dirfilter -eq 1\n        __%[1]s_debug \"File extension filtering or directory filtering not supported\"\n        # Do full file completion instead\n        return 1\n    end\n\n    set -l nospace (math (math --scale 0 $directive / $shellCompDirectiveNoSpace) %% 2)\n    set -l nofiles (math (math --scale 0 $directive / $shellCompDirectiveNoFileComp) %% 2)\n\n    __%[1]s_debug \"nospace: $nospace, nofiles: $nofiles\"\n\n    # If we want to prevent a space, or if file completion is NOT disabled,\n    # we need to count the number of valid completions.\n    # To do so, we will filter on prefix as the completions we have received\n    # may not already be filtered so as to allow fish to match on different\n    # criteria than the prefix.\n    if test $nospace -ne 0; or test $nofiles -eq 0\n        set -l prefix (commandline -t | string escape --style=regex)\n        __%[1]s_debug \"prefix: $prefix\"\n\n        set -l completions (string match -r -- \"^$prefix.*\" $__%[1]s_comp_results)\n        set --global __%[1]s_comp_results $completions\n        __%[1]s_debug \"Filtered completions are: $__%[1]s_comp_results\"\n\n        # Important not to quote the variable for count to work\n        set -l numComps (count $__%[1]s_comp_results)\n        __%[1]s_debug \"numComps: $numComps\"\n\n        if test $numComps -eq 1; and test $nospace -ne 0\n            # We must first split on \\t to get rid of the descriptions to be\n            # able to check what the actual completion will be.\n            # We don't need descriptions anyway since there is only a single\n            # real completion which the shell will expand immediately.\n            set -l split (string split --max 1 \\t $__%[1]s_comp_results[1])\n\n            # Fish won't add a space if the completion ends with any\n            # of the following characters: @=/:.,\n            set -l lastChar (string sub -s -1 -- $split)\n            if not string match -r -q \"[@=/:.,]\" -- \"$lastChar\"\n                # In other cases, to support the \"nospace\" directive we trick the shell\n                # by outputting an extra, longer completion.\n                __%[1]s_debug \"Adding second completion to perform nospace directive\"\n                set --global __%[1]s_comp_results $split[1] $split[1].\n                __%[1]s_debug \"Completions are now: $__%[1]s_comp_results\"\n            end\n        end\n\n        if test $numComps -eq 0; and test $nofiles -eq 0\n            # To be consistent with bash and zsh, we only trigger file\n            # completion when there are no other completions\n            __%[1]s_debug \"Requesting file completion\"\n            return 1\n        end\n    end\n\n    return 0\nend\n\n# Since Fish completions are only loaded once the user triggers them, we trigger them ourselves\n# so we can properly delete any completions provided by another script.\n# Only do this if the program can be found, or else fish may print some errors; besides,\n# the existing completions will only be loaded if the program can be found.\nif type -q \"%[2]s\"\n    # The space after the program name is essential to trigger completion for the program\n    # and not completion of the program name itself.\n    # Also, we use '> /dev/null 2>&1' since '&>' is not supported in older versions of fish.\n    complete --do-complete \"%[2]s \" > /dev/null 2>&1\nend\n\n# Remove any pre-existing completions for the program since we will be handling all of them.\ncomplete -c %[2]s -e\n\n# this will get called after the two calls below and clear the $__%[1]s_perform_completion_once_result global\ncomplete -c %[2]s -n '__%[1]s_clear_perform_completion_once_result'\n# The call to __%[1]s_prepare_completions will setup __%[1]s_comp_results\n# which provides the program's completion choices.\n# If this doesn't require order preservation, we don't use the -k flag\ncomplete -c %[2]s -n 'not __%[1]s_requires_order_preservation && __%[1]s_prepare_completions' -f -a '$__%[1]s_comp_results'\n# otherwise we use the -k flag\ncomplete -k -c %[2]s -n '__%[1]s_requires_order_preservation && __%[1]s_prepare_completions' -f -a '$__%[1]s_comp_results'\n`, nameForVar, name, compCmd,\n\t\tShellCompDirectiveError, ShellCompDirectiveNoSpace, ShellCompDirectiveNoFileComp,\n\t\tShellCompDirectiveFilterFileExt, ShellCompDirectiveFilterDirs, ShellCompDirectiveKeepOrder, activeHelpEnvVar(name)))\n}",
    "importString": "",
    "lineNum": 248,
    "relativeDocumentPath": "fish_completions.go"
  },
  {
    "symbolName": "(*Command).MarkFlagsRequiredTogether",
    "sourceCode": "func (c *Command) MarkFlagsRequiredTogether(flagNames ...string) {\n\tc.mergePersistentFlags()\n\tfor _, v := range flagNames {\n\t\tf := c.Flags().Lookup(v)\n\t\tif f == nil {\n\t\t\tpanic(fmt.Sprintf(\"Failed to find flag %q and mark it as being required in a flag group\", v))\n\t\t}\n\t\tif err := c.Flags().SetAnnotation(v, requiredAsGroupAnnotation, append(f.Annotations[requiredAsGroupAnnotation], strings.Join(flagNames, \" \"))); err != nil {\n\t\t\t// Only errs if the flag isn't found.\n\t\t\tpanic(err)\n\t\t}\n\t}\n}",
    "importString": "",
    "lineNum": 12,
    "relativeDocumentPath": "flag_groups.go"
  },
  {
    "symbolName": "(*Command).MarkFlagsOneRequired",
    "sourceCode": "func (c *Command) MarkFlagsOneRequired(flagNames ...string) {\n\tc.mergePersistentFlags()\n\tfor _, v := range flagNames {\n\t\tf := c.Flags().Lookup(v)\n\t\tif f == nil {\n\t\t\tpanic(fmt.Sprintf(\"Failed to find flag %q and mark it as being in a one-required flag group\", v))\n\t\t}\n\t\tif err := c.Flags().SetAnnotation(v, oneRequiredAnnotation, append(f.Annotations[oneRequiredAnnotation], strings.Join(flagNames, \" \"))); err != nil {\n\t\t\t// Only errs if the flag isn't found.\n\t\t\tpanic(err)\n\t\t}\n\t}\n}",
    "importString": "",
    "lineNum": 12,
    "relativeDocumentPath": "flag_groups.go"
  },
  {
    "symbolName": "(*Command).MarkFlagsMutuallyExclusive",
    "sourceCode": "func (c *Command) MarkFlagsMutuallyExclusive(flagNames ...string) {\n\tc.mergePersistentFlags()\n\tfor _, v := range flagNames {\n\t\tf := c.Flags().Lookup(v)\n\t\tif f == nil {\n\t\t\tpanic(fmt.Sprintf(\"Failed to find flag %q and mark it as being in a mutually exclusive flag group\", v))\n\t\t}\n\t\t// Each time this is called is a single new entry; this allows it to be a member of multiple groups if needed.\n\t\tif err := c.Flags().SetAnnotation(v, mutuallyExclusiveAnnotation, append(f.Annotations[mutuallyExclusiveAnnotation], strings.Join(flagNames, \" \"))); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}",
    "importString": "",
    "lineNum": 12,
    "relativeDocumentPath": "flag_groups.go"
  },
  {
    "symbolName": "(*Command).ValidateFlagGroups",
    "sourceCode": "func (c *Command) ValidateFlagGroups() error {\n\tif c.DisableFlagParsing {\n\t\treturn nil\n\t}\n\n\tflags := c.Flags()\n\n\t// groupStatus format is the list of flags as a unique ID,\n\t// then a map of each flag name and whether it is set or not.\n\tgroupStatus := map[string]map[string]bool{}\n\toneRequiredGroupStatus := map[string]map[string]bool{}\n\tmutuallyExclusiveGroupStatus := map[string]map[string]bool{}\n\tflags.VisitAll(func(pflag *flag.Flag) {\n\t\tprocessFlagForGroupAnnotation(flags, pflag, requiredAsGroupAnnotation, groupStatus)\n\t\tprocessFlagForGroupAnnotation(flags, pflag, oneRequiredAnnotation, oneRequiredGroupStatus)\n\t\tprocessFlagForGroupAnnotation(flags, pflag, mutuallyExclusiveAnnotation, mutuallyExclusiveGroupStatus)\n\t})\n\n\tif err := validateRequiredFlagGroups(groupStatus); err != nil {\n\t\treturn err\n\t}\n\tif err := validateOneRequiredFlagGroups(oneRequiredGroupStatus); err != nil {\n\t\treturn err\n\t}\n\tif err := validateExclusiveFlagGroups(mutuallyExclusiveGroupStatus); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}",
    "importString": "",
    "lineNum": 28,
    "relativeDocumentPath": "flag_groups.go"
  },
  {
    "symbolName": "processFlagForGroupAnnotation",
    "sourceCode": "func processFlagForGroupAnnotation(flags *flag.FlagSet, pflag *flag.Flag, annotation string, groupStatus map[string]map[string]bool) {\n\tgroupInfo, found := pflag.Annotations[annotation]\n\tif found {\n\t\tfor _, group := range groupInfo {\n\t\t\tif groupStatus[group] == nil {\n\t\t\t\tflagnames := strings.Split(group, \" \")\n\n\t\t\t\t// Only consider this flag group at all if all the flags are defined.\n\t\t\t\tif !hasAllFlags(flags, flagnames...) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tgroupStatus[group] = make(map[string]bool, len(flagnames))\n\t\t\t\tfor _, name := range flagnames {\n\t\t\t\t\tgroupStatus[group][name] = false\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgroupStatus[group][pflag.Name] = pflag.Changed\n\t\t}\n\t}\n}",
    "importString": "",
    "lineNum": 21,
    "relativeDocumentPath": "flag_groups.go"
  },
  {
    "symbolName": "validateRequiredFlagGroups",
    "sourceCode": "func validateRequiredFlagGroups(data map[string]map[string]bool) error {\n\tkeys := sortedKeys(data)\n\tfor _, flagList := range keys {\n\t\tflagnameAndStatus := data[flagList]\n\n\t\tunset := []string{}\n\t\tfor flagname, isSet := range flagnameAndStatus {\n\t\t\tif !isSet {\n\t\t\t\tunset = append(unset, flagname)\n\t\t\t}\n\t\t}\n\t\tif len(unset) == len(flagnameAndStatus) || len(unset) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Sort values, so they can be tested/scripted against consistently.\n\t\tsort.Strings(unset)\n\t\treturn fmt.Errorf(\"if any flags in the group [%v] are set they must all be set; missing %v\", flagList, unset)\n\t}\n\n\treturn nil\n}",
    "importString": "",
    "lineNum": 21,
    "relativeDocumentPath": "flag_groups.go"
  },
  {
    "symbolName": "validateOneRequiredFlagGroups",
    "sourceCode": "func validateOneRequiredFlagGroups(data map[string]map[string]bool) error {\n\tkeys := sortedKeys(data)\n\tfor _, flagList := range keys {\n\t\tflagnameAndStatus := data[flagList]\n\t\tvar set []string\n\t\tfor flagname, isSet := range flagnameAndStatus {\n\t\t\tif isSet {\n\t\t\t\tset = append(set, flagname)\n\t\t\t}\n\t\t}\n\t\tif len(set) >= 1 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Sort values, so they can be tested/scripted against consistently.\n\t\tsort.Strings(set)\n\t\treturn fmt.Errorf(\"at least one of the flags in the group [%v] is required\", flagList)\n\t}\n\treturn nil\n}",
    "importString": "",
    "lineNum": 19,
    "relativeDocumentPath": "flag_groups.go"
  },
  {
    "symbolName": "validateExclusiveFlagGroups",
    "sourceCode": "func validateExclusiveFlagGroups(data map[string]map[string]bool) error {\n\tkeys := sortedKeys(data)\n\tfor _, flagList := range keys {\n\t\tflagnameAndStatus := data[flagList]\n\t\tvar set []string\n\t\tfor flagname, isSet := range flagnameAndStatus {\n\t\t\tif isSet {\n\t\t\t\tset = append(set, flagname)\n\t\t\t}\n\t\t}\n\t\tif len(set) == 0 || len(set) == 1 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Sort values, so they can be tested/scripted against consistently.\n\t\tsort.Strings(set)\n\t\treturn fmt.Errorf(\"if any flags in the group [%v] are set none of the others can be; %v were all set\", flagList, set)\n\t}\n\treturn nil\n}",
    "importString": "",
    "lineNum": 19,
    "relativeDocumentPath": "flag_groups.go"
  },
  {
    "symbolName": "(*Command).enforceFlagGroupsForCompletion",
    "sourceCode": "func (c *Command) enforceFlagGroupsForCompletion() {\n\tif c.DisableFlagParsing {\n\t\treturn\n\t}\n\n\tflags := c.Flags()\n\tgroupStatus := map[string]map[string]bool{}\n\toneRequiredGroupStatus := map[string]map[string]bool{}\n\tmutuallyExclusiveGroupStatus := map[string]map[string]bool{}\n\tc.Flags().VisitAll(func(pflag *flag.Flag) {\n\t\tprocessFlagForGroupAnnotation(flags, pflag, requiredAsGroupAnnotation, groupStatus)\n\t\tprocessFlagForGroupAnnotation(flags, pflag, oneRequiredAnnotation, oneRequiredGroupStatus)\n\t\tprocessFlagForGroupAnnotation(flags, pflag, mutuallyExclusiveAnnotation, mutuallyExclusiveGroupStatus)\n\t})\n\n\t// If a flag that is part of a group is present, we make all the other flags\n\t// of that group required so that the shell completion suggests them automatically\n\tfor flagList, flagnameAndStatus := range groupStatus {\n\t\tfor _, isSet := range flagnameAndStatus {\n\t\t\tif isSet {\n\t\t\t\t// One of the flags of the group is set, mark the other ones as required\n\t\t\t\tfor _, fName := range strings.Split(flagList, \" \") {\n\t\t\t\t\t_ = c.MarkFlagRequired(fName)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// If none of the flags of a one-required group are present, we make all the flags\n\t// of that group required so that the shell completion suggests them automatically\n\tfor flagList, flagnameAndStatus := range oneRequiredGroupStatus {\n\t\tisSet := false\n\n\t\tfor _, isSet = range flagnameAndStatus {\n\t\t\tif isSet {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// None of the flags of the group are set, mark all flags in the group\n\t\t// as required\n\t\tif !isSet {\n\t\t\tfor _, fName := range strings.Split(flagList, \" \") {\n\t\t\t\t_ = c.MarkFlagRequired(fName)\n\t\t\t}\n\t\t}\n\t}\n\n\t// If a flag that is mutually exclusive to others is present, we hide the other\n\t// flags of that group so the shell completion does not suggest them\n\tfor flagList, flagnameAndStatus := range mutuallyExclusiveGroupStatus {\n\t\tfor flagName, isSet := range flagnameAndStatus {\n\t\t\tif isSet {\n\t\t\t\t// One of the flags of the mutually exclusive group is set, mark the other ones as hidden\n\t\t\t\t// Don't mark the flag that is already set as hidden because it may be an\n\t\t\t\t// array or slice flag and therefore must continue being suggested\n\t\t\t\tfor _, fName := range strings.Split(flagList, \" \") {\n\t\t\t\t\tif fName != flagName {\n\t\t\t\t\t\tflag := c.Flags().Lookup(fName)\n\t\t\t\t\t\tflag.Hidden = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
    "importString": "",
    "lineNum": 65,
    "relativeDocumentPath": "flag_groups.go"
  },
  {
    "symbolName": "genPowerShellComp",
    "sourceCode": "func genPowerShellComp(buf io.StringWriter, name string, includeDesc bool) {\n\t// Variables should not contain a '-' or ':' character\n\tnameForVar := name\n\tnameForVar = strings.ReplaceAll(nameForVar, \"-\", \"_\")\n\tnameForVar = strings.ReplaceAll(nameForVar, \":\", \"_\")\n\n\tcompCmd := ShellCompRequestCmd\n\tif !includeDesc {\n\t\tcompCmd = ShellCompNoDescRequestCmd\n\t}\n\tWriteStringAndCheck(buf, fmt.Sprintf(`# powershell completion for %-36[1]s -*- shell-script -*-\n\nfunction __%[1]s_debug {\n    if ($env:BASH_COMP_DEBUG_FILE) {\n        \"$args\" | Out-File -Append -FilePath \"$env:BASH_COMP_DEBUG_FILE\"\n    }\n}\n\nfilter __%[1]s_escapeStringWithSpecialChars {\n`+\"    $_ -replace '\\\\s|#|@|\\\\$|;|,|''|\\\\{|\\\\}|\\\\(|\\\\)|\\\"|`|\\\\||<|>|&','`$&'\"+`\n}\n\n[scriptblock]${__%[2]sCompleterBlock} = {\n    param(\n            $WordToComplete,\n            $CommandAst,\n            $CursorPosition\n        )\n\n    # Get the current command line and convert into a string\n    $Command = $CommandAst.CommandElements\n    $Command = \"$Command\"\n\n    __%[1]s_debug \"\"\n    __%[1]s_debug \"========= starting completion logic ==========\"\n    __%[1]s_debug \"WordToComplete: $WordToComplete Command: $Command CursorPosition: $CursorPosition\"\n\n    # The user could have moved the cursor backwards on the command-line.\n    # We need to trigger completion from the $CursorPosition location, so we need\n    # to truncate the command-line ($Command) up to the $CursorPosition location.\n    # Make sure the $Command is longer then the $CursorPosition before we truncate.\n    # This happens because the $Command does not include the last space.\n    if ($Command.Length -gt $CursorPosition) {\n        $Command=$Command.Substring(0,$CursorPosition)\n    }\n    __%[1]s_debug \"Truncated command: $Command\"\n\n    $ShellCompDirectiveError=%[4]d\n    $ShellCompDirectiveNoSpace=%[5]d\n    $ShellCompDirectiveNoFileComp=%[6]d\n    $ShellCompDirectiveFilterFileExt=%[7]d\n    $ShellCompDirectiveFilterDirs=%[8]d\n    $ShellCompDirectiveKeepOrder=%[9]d\n\n    # Prepare the command to request completions for the program.\n    # Split the command at the first space to separate the program and arguments.\n    $Program,$Arguments = $Command.Split(\" \",2)\n\n    $RequestComp=\"$Program %[3]s $Arguments\"\n    __%[1]s_debug \"RequestComp: $RequestComp\"\n\n    # we cannot use $WordToComplete because it\n    # has the wrong values if the cursor was moved\n    # so use the last argument\n    if ($WordToComplete -ne \"\" ) {\n        $WordToComplete = $Arguments.Split(\" \")[-1]\n    }\n    __%[1]s_debug \"New WordToComplete: $WordToComplete\"\n\n\n    # Check for flag with equal sign\n    $IsEqualFlag = ($WordToComplete -Like \"--*=*\" )\n    if ( $IsEqualFlag ) {\n        __%[1]s_debug \"Completing equal sign flag\"\n        # Remove the flag part\n        $Flag,$WordToComplete = $WordToComplete.Split(\"=\",2)\n    }\n\n    if ( $WordToComplete -eq \"\" -And ( -Not $IsEqualFlag )) {\n        # If the last parameter is complete (there is a space following it)\n        # We add an extra empty parameter so we can indicate this to the go method.\n        __%[1]s_debug \"Adding extra empty parameter\"\n        # PowerShell 7.2+ changed the way how the arguments are passed to executables,\n        # so for pre-7.2 or when Legacy argument passing is enabled we need to use\n`+\"        # `\\\"`\\\" to pass an empty argument, a \\\"\\\" or '' does not work!!!\"+`\n        if ($PSVersionTable.PsVersion -lt [version]'7.2.0' -or\n            ($PSVersionTable.PsVersion -lt [version]'7.3.0' -and -not [ExperimentalFeature]::IsEnabled(\"PSNativeCommandArgumentPassing\")) -or\n            (($PSVersionTable.PsVersion -ge [version]'7.3.0' -or [ExperimentalFeature]::IsEnabled(\"PSNativeCommandArgumentPassing\")) -and\n              $PSNativeCommandArgumentPassing -eq 'Legacy')) {\n`+\"             $RequestComp=\\\"$RequestComp\\\" + ' `\\\"`\\\"'\"+`\n        } else {\n             $RequestComp=\"$RequestComp\" + ' \"\"'\n        }\n    }\n\n    __%[1]s_debug \"Calling $RequestComp\"\n    # First disable ActiveHelp which is not supported for Powershell\n    ${env:%[10]s}=0\n\n    #call the command store the output in $out and redirect stderr and stdout to null\n    # $Out is an array contains each line per element\n    Invoke-Expression -OutVariable out \"$RequestComp\" 2>&1 | Out-Null\n\n    # get directive from last line\n    [int]$Directive = $Out[-1].TrimStart(':')\n    if ($Directive -eq \"\") {\n        # There is no directive specified\n        $Directive = 0\n    }\n    __%[1]s_debug \"The completion directive is: $Directive\"\n\n    # remove directive (last element) from out\n    $Out = $Out | Where-Object { $_ -ne $Out[-1] }\n    __%[1]s_debug \"The completions are: $Out\"\n\n    if (($Directive -band $ShellCompDirectiveError) -ne 0 ) {\n        # Error code.  No completion.\n        __%[1]s_debug \"Received error from custom completion go code\"\n        return\n    }\n\n    $Longest = 0\n    [Array]$Values = $Out | ForEach-Object {\n        #Split the output in name and description\n`+\"        $Name, $Description = $_.Split(\\\"`t\\\",2)\"+`\n        __%[1]s_debug \"Name: $Name Description: $Description\"\n\n        # Look for the longest completion so that we can format things nicely\n        if ($Longest -lt $Name.Length) {\n            $Longest = $Name.Length\n        }\n\n        # Set the description to a one space string if there is none set.\n        # This is needed because the CompletionResult does not accept an empty string as argument\n        if (-Not $Description) {\n            $Description = \" \"\n        }\n        New-Object -TypeName PSCustomObject -Property @{\n            Name = \"$Name\"\n            Description = \"$Description\"\n        }\n    }\n\n\n    $Space = \" \"\n    if (($Directive -band $ShellCompDirectiveNoSpace) -ne 0 ) {\n        # remove the space here\n        __%[1]s_debug \"ShellCompDirectiveNoSpace is called\"\n        $Space = \"\"\n    }\n\n    if ((($Directive -band $ShellCompDirectiveFilterFileExt) -ne 0 ) -or\n       (($Directive -band $ShellCompDirectiveFilterDirs) -ne 0 ))  {\n        __%[1]s_debug \"ShellCompDirectiveFilterFileExt ShellCompDirectiveFilterDirs are not supported\"\n\n        # return here to prevent the completion of the extensions\n        return\n    }\n\n    $Values = $Values | Where-Object {\n        # filter the result\n        $_.Name -like \"$WordToComplete*\"\n\n        # Join the flag back if we have an equal sign flag\n        if ( $IsEqualFlag ) {\n            __%[1]s_debug \"Join the equal sign flag back to the completion value\"\n            $_.Name = $Flag + \"=\" + $_.Name\n        }\n    }\n\n    # we sort the values in ascending order by name if keep order isn't passed\n    if (($Directive -band $ShellCompDirectiveKeepOrder) -eq 0 ) {\n        $Values = $Values | Sort-Object -Property Name\n    }\n\n    if (($Directive -band $ShellCompDirectiveNoFileComp) -ne 0 ) {\n        __%[1]s_debug \"ShellCompDirectiveNoFileComp is called\"\n\n        if ($Values.Length -eq 0) {\n            # Just print an empty string here so the\n            # shell does not start to complete paths.\n            # We cannot use CompletionResult here because\n            # it does not accept an empty string as argument.\n            \"\"\n            return\n        }\n    }\n\n    # Get the current mode\n    $Mode = (Get-PSReadLineKeyHandler | Where-Object {$_.Key -eq \"Tab\" }).Function\n    __%[1]s_debug \"Mode: $Mode\"\n\n    $Values | ForEach-Object {\n\n        # store temporary because switch will overwrite $_\n        $comp = $_\n\n        # PowerShell supports three different completion modes\n        # - TabCompleteNext (default windows style - on each key press the next option is displayed)\n        # - Complete (works like bash)\n        # - MenuComplete (works like zsh)\n        # You set the mode with Set-PSReadLineKeyHandler -Key Tab -Function <mode>\n\n        # CompletionResult Arguments:\n        # 1) CompletionText text to be used as the auto completion result\n        # 2) ListItemText   text to be displayed in the suggestion list\n        # 3) ResultType     type of completion result\n        # 4) ToolTip        text for the tooltip with details about the object\n\n        switch ($Mode) {\n\n            # bash like\n            \"Complete\" {\n\n                if ($Values.Length -eq 1) {\n                    __%[1]s_debug \"Only one completion left\"\n\n                    # insert space after value\n                    $CompletionText = $($comp.Name | __%[1]s_escapeStringWithSpecialChars) + $Space\n                    if ($ExecutionContext.SessionState.LanguageMode -eq \"FullLanguage\"){\n                        [System.Management.Automation.CompletionResult]::new($CompletionText, \"$($comp.Name)\", 'ParameterValue', \"$($comp.Description)\")\n                    } else {\n                        $CompletionText\n                    }\n\n                } else {\n                    # Add the proper number of spaces to align the descriptions\n                    while($comp.Name.Length -lt $Longest) {\n                        $comp.Name = $comp.Name + \" \"\n                    }\n\n                    # Check for empty description and only add parentheses if needed\n                    if ($($comp.Description) -eq \" \" ) {\n                        $Description = \"\"\n                    } else {\n                        $Description = \"  ($($comp.Description))\"\n                    }\n\n                    $CompletionText = \"$($comp.Name)$Description\"\n                    if ($ExecutionContext.SessionState.LanguageMode -eq \"FullLanguage\"){\n                        [System.Management.Automation.CompletionResult]::new($CompletionText, \"$($comp.Name)$Description\", 'ParameterValue', \"$($comp.Description)\")\n                    } else {\n                        $CompletionText\n                    }\n                }\n             }\n\n            # zsh like\n            \"MenuComplete\" {\n                # insert space after value\n                # MenuComplete will automatically show the ToolTip of\n                # the highlighted value at the bottom of the suggestions.\n\n                $CompletionText = $($comp.Name | __%[1]s_escapeStringWithSpecialChars) + $Space\n                if ($ExecutionContext.SessionState.LanguageMode -eq \"FullLanguage\"){\n                    [System.Management.Automation.CompletionResult]::new($CompletionText, \"$($comp.Name)\", 'ParameterValue', \"$($comp.Description)\")\n                } else {\n                    $CompletionText\n                }\n            }\n\n            # TabCompleteNext and in case we get something unknown\n            Default {\n                # Like MenuComplete but we don't want to add a space here because\n                # the user need to press space anyway to get the completion.\n                # Description will not be shown because that's not possible with TabCompleteNext\n\n                $CompletionText = $($comp.Name | __%[1]s_escapeStringWithSpecialChars)\n                if ($ExecutionContext.SessionState.LanguageMode -eq \"FullLanguage\"){\n                    [System.Management.Automation.CompletionResult]::new($CompletionText, \"$($comp.Name)\", 'ParameterValue', \"$($comp.Description)\")\n                } else {\n                    $CompletionText\n                }\n            }\n        }\n\n    }\n}\n\nRegister-ArgumentCompleter -CommandName '%[1]s' -ScriptBlock ${__%[2]sCompleterBlock}\n`, name, nameForVar, compCmd,\n\t\tShellCompDirectiveError, ShellCompDirectiveNoSpace, ShellCompDirectiveNoFileComp,\n\t\tShellCompDirectiveFilterFileExt, ShellCompDirectiveFilterDirs, ShellCompDirectiveKeepOrder, activeHelpEnvVar(name)))\n}",
    "importString": "",
    "lineNum": 283,
    "relativeDocumentPath": "powershell_completions.go"
  },
  {
    "symbolName": "genZshComp",
    "sourceCode": "func genZshComp(buf io.StringWriter, name string, includeDesc bool) {\n\tcompCmd := ShellCompRequestCmd\n\tif !includeDesc {\n\t\tcompCmd = ShellCompNoDescRequestCmd\n\t}\n\tWriteStringAndCheck(buf, fmt.Sprintf(`#compdef %[1]s\ncompdef _%[1]s %[1]s\n\n# zsh completion for %-36[1]s -*- shell-script -*-\n\n__%[1]s_debug()\n{\n    local file=\"$BASH_COMP_DEBUG_FILE\"\n    if [[ -n ${file} ]]; then\n        echo \"$*\" >> \"${file}\"\n    fi\n}\n\n_%[1]s()\n{\n    local shellCompDirectiveError=%[3]d\n    local shellCompDirectiveNoSpace=%[4]d\n    local shellCompDirectiveNoFileComp=%[5]d\n    local shellCompDirectiveFilterFileExt=%[6]d\n    local shellCompDirectiveFilterDirs=%[7]d\n    local shellCompDirectiveKeepOrder=%[8]d\n\n    local lastParam lastChar flagPrefix requestComp out directive comp lastComp noSpace keepOrder\n    local -a completions\n\n    __%[1]s_debug \"\\n========= starting completion logic ==========\"\n    __%[1]s_debug \"CURRENT: ${CURRENT}, words[*]: ${words[*]}\"\n\n    # The user could have moved the cursor backwards on the command-line.\n    # We need to trigger completion from the $CURRENT location, so we need\n    # to truncate the command-line ($words) up to the $CURRENT location.\n    # (We cannot use $CURSOR as its value does not work when a command is an alias.)\n    words=(\"${=words[1,CURRENT]}\")\n    __%[1]s_debug \"Truncated words[*]: ${words[*]},\"\n\n    lastParam=${words[-1]}\n    lastChar=${lastParam[-1]}\n    __%[1]s_debug \"lastParam: ${lastParam}, lastChar: ${lastChar}\"\n\n    # For zsh, when completing a flag with an = (e.g., %[1]s -n=<TAB>)\n    # completions must be prefixed with the flag\n    setopt local_options BASH_REMATCH\n    if [[ \"${lastParam}\" =~ '-.*=' ]]; then\n        # We are dealing with a flag with an =\n        flagPrefix=\"-P ${BASH_REMATCH}\"\n    fi\n\n    # Prepare the command to obtain completions\n    requestComp=\"${words[1]} %[2]s ${words[2,-1]}\"\n    if [ \"${lastChar}\" = \"\" ]; then\n        # If the last parameter is complete (there is a space following it)\n        # We add an extra empty parameter so we can indicate this to the go completion code.\n        __%[1]s_debug \"Adding extra empty parameter\"\n        requestComp=\"${requestComp} \\\"\\\"\"\n    fi\n\n    __%[1]s_debug \"About to call: eval ${requestComp}\"\n\n    # Use eval to handle any environment variables and such\n    out=$(eval ${requestComp} 2>/dev/null)\n    __%[1]s_debug \"completion output: ${out}\"\n\n    # Extract the directive integer following a : from the last line\n    local lastLine\n    while IFS='\\n' read -r line; do\n        lastLine=${line}\n    done < <(printf \"%%s\\n\" \"${out[@]}\")\n    __%[1]s_debug \"last line: ${lastLine}\"\n\n    if [ \"${lastLine[1]}\" = : ]; then\n        directive=${lastLine[2,-1]}\n        # Remove the directive including the : and the newline\n        local suffix\n        (( suffix=${#lastLine}+2))\n        out=${out[1,-$suffix]}\n    else\n        # There is no directive specified.  Leave $out as is.\n        __%[1]s_debug \"No directive found.  Setting do default\"\n        directive=0\n    fi\n\n    __%[1]s_debug \"directive: ${directive}\"\n    __%[1]s_debug \"completions: ${out}\"\n    __%[1]s_debug \"flagPrefix: ${flagPrefix}\"\n\n    if [ $((directive & shellCompDirectiveError)) -ne 0 ]; then\n        __%[1]s_debug \"Completion received error. Ignoring completions.\"\n        return\n    fi\n\n    local activeHelpMarker=\"%[9]s\"\n    local endIndex=${#activeHelpMarker}\n    local startIndex=$((${#activeHelpMarker}+1))\n    local hasActiveHelp=0\n    while IFS='\\n' read -r comp; do\n        # Check if this is an activeHelp statement (i.e., prefixed with $activeHelpMarker)\n        if [ \"${comp[1,$endIndex]}\" = \"$activeHelpMarker\" ];then\n            __%[1]s_debug \"ActiveHelp found: $comp\"\n            comp=\"${comp[$startIndex,-1]}\"\n            if [ -n \"$comp\" ]; then\n                compadd -x \"${comp}\"\n                __%[1]s_debug \"ActiveHelp will need delimiter\"\n                hasActiveHelp=1\n            fi\n\n            continue\n        fi\n\n        if [ -n \"$comp\" ]; then\n            # If requested, completions are returned with a description.\n            # The description is preceded by a TAB character.\n            # For zsh's _describe, we need to use a : instead of a TAB.\n            # We first need to escape any : as part of the completion itself.\n            comp=${comp//:/\\\\:}\n\n            local tab=\"$(printf '\\t')\"\n            comp=${comp//$tab/:}\n\n            __%[1]s_debug \"Adding completion: ${comp}\"\n            completions+=${comp}\n            lastComp=$comp\n        fi\n    done < <(printf \"%%s\\n\" \"${out[@]}\")\n\n    # Add a delimiter after the activeHelp statements, but only if:\n    # - there are completions following the activeHelp statements, or\n    # - file completion will be performed (so there will be choices after the activeHelp)\n    if [ $hasActiveHelp -eq 1 ]; then\n        if [ ${#completions} -ne 0 ] || [ $((directive & shellCompDirectiveNoFileComp)) -eq 0 ]; then\n            __%[1]s_debug \"Adding activeHelp delimiter\"\n            compadd -x \"--\"\n            hasActiveHelp=0\n        fi\n    fi\n\n    if [ $((directive & shellCompDirectiveNoSpace)) -ne 0 ]; then\n        __%[1]s_debug \"Activating nospace.\"\n        noSpace=\"-S ''\"\n    fi\n\n    if [ $((directive & shellCompDirectiveKeepOrder)) -ne 0 ]; then\n        __%[1]s_debug \"Activating keep order.\"\n        keepOrder=\"-V\"\n    fi\n\n    if [ $((directive & shellCompDirectiveFilterFileExt)) -ne 0 ]; then\n        # File extension filtering\n        local filteringCmd\n        filteringCmd='_files'\n        for filter in ${completions[@]}; do\n            if [ ${filter[1]} != '*' ]; then\n                # zsh requires a glob pattern to do file filtering\n                filter=\"\\*.$filter\"\n            fi\n            filteringCmd+=\" -g $filter\"\n        done\n        filteringCmd+=\" ${flagPrefix}\"\n\n        __%[1]s_debug \"File filtering command: $filteringCmd\"\n        _arguments '*:filename:'\"$filteringCmd\"\n    elif [ $((directive & shellCompDirectiveFilterDirs)) -ne 0 ]; then\n        # File completion for directories only\n        local subdir\n        subdir=\"${completions[1]}\"\n        if [ -n \"$subdir\" ]; then\n            __%[1]s_debug \"Listing directories in $subdir\"\n            pushd \"${subdir}\" >/dev/null 2>&1\n        else\n            __%[1]s_debug \"Listing directories in .\"\n        fi\n\n        local result\n        _arguments '*:dirname:_files -/'\" ${flagPrefix}\"\n        result=$?\n        if [ -n \"$subdir\" ]; then\n            popd >/dev/null 2>&1\n        fi\n        return $result\n    else\n        __%[1]s_debug \"Calling _describe\"\n        if eval _describe $keepOrder \"completions\" completions $flagPrefix $noSpace; then\n            __%[1]s_debug \"_describe found some completions\"\n\n            # Return the success of having called _describe\n            return 0\n        else\n            __%[1]s_debug \"_describe did not find completions.\"\n            __%[1]s_debug \"Checking if we should do file completion.\"\n            if [ $((directive & shellCompDirectiveNoFileComp)) -ne 0 ]; then\n                __%[1]s_debug \"deactivating file completion\"\n\n                # We must return an error code here to let zsh know that there were no\n                # completions found by _describe; this is what will trigger other\n                # matching algorithms to attempt to find completions.\n                # For example zsh can match letters in the middle of words.\n                return 1\n            else\n                # Perform file completion\n                __%[1]s_debug \"Activating file completion\"\n\n                # We must return the result of this command, so it must be the\n                # last command, or else we must store its result to return it.\n                _arguments '*:filename:_files'\" ${flagPrefix}\"\n            fi\n        fi\n    fi\n}\n\n# don't run the completion function when being source-ed or eval-ed\nif [ \"$funcstack[1]\" = \"_%[1]s\" ]; then\n    _%[1]s\nfi\n`, name, compCmd,\n\t\tShellCompDirectiveError, ShellCompDirectiveNoSpace, ShellCompDirectiveNoFileComp,\n\t\tShellCompDirectiveFilterFileExt, ShellCompDirectiveFilterDirs, ShellCompDirectiveKeepOrder,\n\t\tactiveHelpMarker))\n}",
    "importString": "",
    "lineNum": 221,
    "relativeDocumentPath": "zsh_completions.go"
  }
]