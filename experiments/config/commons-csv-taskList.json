[
  {
    "symbolName": "create()",
    "sourceCode": "/**\n         * Creates a new default builder, as for {@link #RFC4180} but allowing empty lines.\n         *\n         * <p>\n         * The {@link Builder} settings are:\n         * </p>\n         * <ul>\n         * <li>{@link Builder#setDelimiter(char) setDelimiter}{@code (',')}</li>\n         * <li>{@link Builder#setQuote(char) setQuote}{@code ('\"')}</li>\n         * <li>{@link Builder#setRecordSeparator(String) setRecordSeparator}{@code (\"\\r\\n\")}</li>\n         * <li>{@link Builder#setIgnoreEmptyLines(boolean) setIgnoreEmptyLines}{@code (true)}</li>\n         * <li>{@link Builder#setDuplicateHeaderMode(DuplicateHeaderMode) setDuplicateHeaderMode}{@code (DuplicateHeaderMode.ALLOW_ALL)}</li>\n         * <li>All other values take their Java defaults, {@code false} for booleans, {@code null} for object references.</li>\n         * </ul>\n         *\n         * @see Predefined#Default\n         * @see DuplicateHeaderMode#ALLOW_ALL\n         *\n         * @return a copy of the builder\n         */\n        public static Builder create() {\n            // @formatter:off\n            return new Builder()\n                    .setDelimiter(Constants.COMMA)\n                    .setQuote(Constants.DOUBLE_QUOTE_CHAR)\n                    .setRecordSeparator(Constants.CRLF)\n                    .setIgnoreEmptyLines(true)\n                    .setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL);\n                    // @formatter:on\n        }",
    "importString": "",
    "lineNum": 29,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "setAllowDuplicateHeaderNames(boolean)",
    "sourceCode": "/**\n         * Sets the duplicate header names behavior, true to allow, false to disallow.\n         *\n         * @param allowDuplicateHeaderNames the duplicate header names behavior, true to allow, false to disallow.\n         * @return This instance.\n         * @deprecated Use {@link #setDuplicateHeaderMode(DuplicateHeaderMode)}.\n         */\n        @Deprecated\n        public Builder setAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNames) {\n            setDuplicateHeaderMode(allowDuplicateHeaderNames ? DuplicateHeaderMode.ALLOW_ALL : DuplicateHeaderMode.ALLOW_EMPTY);\n            return this;\n        }",
    "importString": "",
    "lineNum": 11,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "setAllowMissingColumnNames(boolean)",
    "sourceCode": "/**\n         * Sets the parser missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to cause an\n         * {@link IllegalArgumentException} to be thrown.\n         *\n         * @param allowMissingColumnNames the missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to\n         *                                cause an {@link IllegalArgumentException} to be thrown.\n         * @return This instance.\n         */\n        public Builder setAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n            this.allowMissingColumnNames = allowMissingColumnNames;\n            return this;\n        }",
    "importString": "",
    "lineNum": 11,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "setCommentMarker(char)",
    "sourceCode": "/**\n         * Sets the comment marker character, use {@code null} to disable comments.\n         * <p>\n         * The comment start character is only recognized at the start of a line.\n         * </p>\n         * <p>\n         * Comments are printed first, before headers.\n         * </p>\n         * <p>\n         * Use {@link #setCommentMarker(char)} or {@link #setCommentMarker(Character)} to set the comment marker written at the start of each comment line.\n         * </p>\n         * <p>\n         * If the comment marker is not set, then the header comments are ignored.\n         * </p>\n         * <p>\n         * For example:\n         * </p>\n         *\n         * <pre>\n         * builder.setCommentMarker('#').setHeaderComments(\"Generated by Apache Commons CSV\", Instant.ofEpochMilli(0));\n         * </pre>\n         * <p>\n         * writes:\n         * </p>\n         *\n         * <pre>\n         * # Generated by Apache Commons CSV.\n         * # 1970-01-01T00:00:00Z\n         * </pre>\n         *\n         * @param commentMarker the comment start marker, use {@code null} to disable.\n         * @return This instance.\n         * @throws IllegalArgumentException thrown if the specified character is a line break\n         */\n        public Builder setCommentMarker(final char commentMarker) {\n            setCommentMarker(Character.valueOf(commentMarker));\n            return this;\n        }",
    "importString": "",
    "lineNum": 37,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "setCommentMarker(Character)",
    "sourceCode": "/**\n         * Sets the comment marker character, use {@code null} to disable comments.\n         * <p>\n         * The comment start character is only recognized at the start of a line.\n         * </p>\n         * <p>\n         * Comments are printed first, before headers.\n         * </p>\n         * <p>\n         * Use {@link #setCommentMarker(char)} or {@link #setCommentMarker(Character)} to set the comment marker written at the start of each comment line.\n         * </p>\n         * <p>\n         * If the comment marker is not set, then the header comments are ignored.\n         * </p>\n         * <p>\n         * For example:\n         * </p>\n         *\n         * <pre>\n         * builder.setCommentMarker('#').setHeaderComments(\"Generated by Apache Commons CSV\", Instant.ofEpochMilli(0));\n         * </pre>\n         * <p>\n         * writes:\n         * </p>\n         *\n         * <pre>\n         * # Generated by Apache Commons CSV.\n         * # 1970-01-01T00:00:00Z\n         * </pre>\n         *\n         * @param commentMarker the comment start marker, use {@code null} to disable.\n         * @return This instance.\n         * @throws IllegalArgumentException thrown if the specified character is a line break\n         */\n        public Builder setCommentMarker(final Character commentMarker) {\n            if (isLineBreak(commentMarker)) {\n                throw new IllegalArgumentException(\"The comment start marker character cannot be a line break\");\n            }\n            this.commentMarker = commentMarker;\n            return this;\n        }",
    "importString": "",
    "lineNum": 40,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "setDelimiter(String)",
    "sourceCode": "/**\n         * Sets the delimiter character.\n         *\n         * @param delimiter the delimiter character.\n         * @return This instance.\n         */\n        public Builder setDelimiter(final String delimiter) {\n            if (containsLineBreak(delimiter)) {\n                throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n            }\n            if (delimiter.isEmpty()) {\n                throw new IllegalArgumentException(\"The delimiter cannot be empty\");\n            }\n            this.delimiter = delimiter;\n            return this;\n        }",
    "importString": "",
    "lineNum": 15,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "setDuplicateHeaderMode(DuplicateHeaderMode)",
    "sourceCode": "/**\n         * Sets the duplicate header names behavior.\n         *\n         * @param duplicateHeaderMode the duplicate header names behavior\n         * @return This instance.\n         * @since 1.10.0\n         */\n        public Builder setDuplicateHeaderMode(final DuplicateHeaderMode duplicateHeaderMode) {\n            this.duplicateHeaderMode = Objects.requireNonNull(duplicateHeaderMode, \"duplicateHeaderMode\");\n            return this;\n        }",
    "importString": "",
    "lineNum": 10,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "setEscape(char)",
    "sourceCode": "/**\n         * Sets the escape character.\n         *\n         * @param escapeCharacter the escape character.\n         * @return This instance.\n         * @throws IllegalArgumentException thrown if the specified character is a line break\n         */\n        public Builder setEscape(final char escapeCharacter) {\n            setEscape(Character.valueOf(escapeCharacter));\n            return this;\n        }",
    "importString": "",
    "lineNum": 10,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "setEscape(Character)",
    "sourceCode": "/**\n         * Sets the escape character.\n         *\n         * @param escapeCharacter the escape character.\n         * @return This instance.\n         * @throws IllegalArgumentException thrown if the specified character is a line break\n         */\n        public Builder setEscape(final Character escapeCharacter) {\n            if (isLineBreak(escapeCharacter)) {\n                throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n            }\n            this.escapeCharacter = escapeCharacter;\n            return this;\n        }",
    "importString": "",
    "lineNum": 13,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "setHeader(Class<? extends Enum<?>>)",
    "sourceCode": "/**\n         * Sets the header defined by the given {@link Enum} class.\n         *\n         * <p>\n         * Example:\n         * </p>\n         *\n         * <pre>\n         * public enum HeaderEnum {\n         *     Name, Email, Phone\n         * }\n         *\n         * Builder builder = builder.setHeader(HeaderEnum.class);\n         * </pre>\n         * <p>\n         * The header is also used by the {@link CSVPrinter}.\n         * </p>\n         *\n         * @param headerEnum the enum defining the header, {@code null} if disabled, empty if parsed automatically, user-specified otherwise.\n         * @return This instance.\n         */\n        public Builder setHeader(final Class<? extends Enum<?>> headerEnum) {\n            String[] header = null;\n            if (headerEnum != null) {\n                final Enum<?>[] enumValues = headerEnum.getEnumConstants();\n                header = new String[enumValues.length];\n                Arrays.setAll(header, i -> enumValues[i].name());\n            }\n            return setHeader(header);\n        }",
    "importString": "",
    "lineNum": 29,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "setHeader(ResultSet)",
    "sourceCode": "/**\n         * Sets the header from the result set metadata. The header can be parsed automatically from the input file with:\n         *\n         * <pre>\n         * builder.setHeader();\n         * </pre>\n         *\n         * or specified manually with:\n         *\n         * <pre>\n         * builder.setHeader(resultSet);\n         * </pre>\n         * <p>\n         * The header is also used by the {@link CSVPrinter}.\n         * </p>\n         *\n         * @param resultSet the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user-specified otherwise.\n         * @return This instance.\n         * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\n         */\n        public Builder setHeader(final ResultSet resultSet) throws SQLException {\n            return setHeader(resultSet != null ? resultSet.getMetaData() : null);\n        }",
    "importString": "",
    "lineNum": 22,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "setHeader(ResultSetMetaData)",
    "sourceCode": "/**\n         * Sets the header from the result set metadata. The header can be parsed automatically from the input file with:\n         *\n         * <pre>\n         * builder.setHeader();\n         * </pre>\n         *\n         * or specified manually with:\n         *\n         * <pre>\n         * builder.setHeader(resultSetMetaData);\n         * </pre>\n         * <p>\n         * The header is also used by the {@link CSVPrinter}.\n         * </p>\n         *\n         * @param resultSetMetaData the metaData for the header, {@code null} if disabled, empty if parsed automatically, user-specified otherwise.\n         * @return This instance.\n         * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\n         */\n        public Builder setHeader(final ResultSetMetaData resultSetMetaData) throws SQLException {\n            String[] labels = null;\n            if (resultSetMetaData != null) {\n                final int columnCount = resultSetMetaData.getColumnCount();\n                labels = new String[columnCount];\n                for (int i = 0; i < columnCount; i++) {\n                    labels[i] = resultSetMetaData.getColumnLabel(i + 1);\n                }\n            }\n            return setHeader(labels);\n        }",
    "importString": "",
    "lineNum": 30,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "setHeader(String...)",
    "sourceCode": "/**\n         * Sets the header to the given values. The header can be parsed automatically from the input file with:\n         *\n         * <pre>\n         * builder.setHeader();\n         * </pre>\n         *\n         * or specified manually with:\n         *\n         * <pre>{@code\n         * builder.setHeader(\"name\", \"email\", \"phone\");\n         * }</pre>\n         * <p>\n         * The header is also used by the {@link CSVPrinter}.\n         * </p>\n         * <p>\n         * This method keeps a copy of the input array.\n         * </p>\n         * @param header the header, {@code null} if disabled, empty if parsed automatically, user-specified otherwise.\n         * @return This instance.\n         */\n        public Builder setHeader(final String... header) {\n            this.headers = CSVFormat.clone(header);\n            return this;\n        }",
    "importString": "",
    "lineNum": 24,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "setHeaderComments(Object...)",
    "sourceCode": "/**\n         * Sets the header comments to write before the CSV data.\n         * <p>\n         * This setting is ignored by the parser.\n         * </p>\n         * <p>\n         * Comments are printed first, before headers.\n         * </p>\n         * <p>\n         * Use {@link #setCommentMarker(char)} or {@link #setCommentMarker(Character)} to set the comment marker written at the start of each comment line.\n         * </p>\n         * <p>\n         * If the comment marker is not set, then the header comments are ignored.\n         * </p>\n         * <p>\n         * For example:\n         * </p>\n         *\n         * <pre>\n         * builder.setCommentMarker('#').setHeaderComments(\"Generated by Apache Commons CSV\", Instant.ofEpochMilli(0));\n         * </pre>\n         * <p>\n         * writes:\n         * </p>\n         *\n         * <pre>\n         * # Generated by Apache Commons CSV.\n         * # 1970-01-01T00:00:00Z\n         * </pre>\n         * <p>\n         * This method keeps a copy of the input array.\n         * </p>\n         *\n         * @param headerComments the headerComments which will be printed by the Printer before the CSV data.\n         * @return This instance.\n         */\n        public Builder setHeaderComments(final Object... headerComments) {\n            this.headerComments = CSVFormat.clone(toStringArray(headerComments));\n            return this;\n        }",
    "importString": "",
    "lineNum": 39,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "setHeaderComments(String...)",
    "sourceCode": "/**\n         * Sets the header comments to write before the CSV data.\n         * <p>\n         * This setting is ignored by the parser.\n         * </p>\n         * <p>\n         * Comments are printed first, before headers.\n         * </p>\n         * <p>\n         * Use {@link #setCommentMarker(char)} or {@link #setCommentMarker(Character)} to set the comment marker written at the start of each comment line.\n         * </p>\n         * <p>\n         * If the comment marker is not set, then the header comments are ignored.\n         * </p>\n         * <p>\n         * For example:\n         * </p>\n         *\n         * <pre>\n         * builder.setCommentMarker('#').setHeaderComments(\"Generated by Apache Commons CSV\", Instant.ofEpochMilli(0).toString());\n         * </pre>\n         * <p>\n         * writes:\n         * </p>\n         *\n         * <pre>\n         * # Generated by Apache Commons CSV.\n         * # 1970-01-01T00:00:00Z\n         * </pre>\n         * <p>\n         * This method keeps a copy of the input array.\n         * </p>\n         * @param headerComments the headerComments which will be printed by the Printer before the CSV data.\n         * @return This instance.\n         */\n        public Builder setHeaderComments(final String... headerComments) {\n            this.headerComments = CSVFormat.clone(headerComments);\n            return this;\n        }",
    "importString": "",
    "lineNum": 38,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "setIgnoreEmptyLines(boolean)",
    "sourceCode": "/**\n         * Sets the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate empty lines to empty\n         * records.\n         *\n         * @param ignoreEmptyLines the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate\n         *                         empty lines to empty records.\n         * @return This instance.\n         */\n        public Builder setIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n            this.ignoreEmptyLines = ignoreEmptyLines;\n            return this;\n        }",
    "importString": "",
    "lineNum": 11,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "setLenientEof(boolean)",
    "sourceCode": "/**\n         * Sets whether reading end-of-file is allowed even when input is malformed, helps Excel compatibility.\n         *\n         * @param lenientEof whether reading end-of-file is allowed even when input is malformed, helps Excel compatibility.\n         * @return This instance.\n         * @since 1.11.0\n         */\n        public Builder setLenientEof(final boolean lenientEof) {\n            this.lenientEof = lenientEof;\n            return this;\n        }",
    "importString": "",
    "lineNum": 10,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "setMaxRows(long)",
    "sourceCode": "/**\n         * Sets the maximum number of rows to process, excluding the header row.\n         * <p>\n         * Values less than or equal to 0 mean no limit.\n         * </p>\n         *\n         * @param maxRows the maximum number of rows to process, excluding the header row.\n         * @return This instance.\n         * @since 1.14.0\n         */\n        public Builder setMaxRows(final long maxRows) {\n            this.maxRows = maxRows;\n            return this;\n        }",
    "importString": "",
    "lineNum": 13,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "setNullString(String)",
    "sourceCode": "/**\n         * Sets the String to convert to and from {@code null}. No substitution occurs if {@code null}.\n         *\n         * <ul>\n         * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading records.</li>\n         * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n         * </ul>\n         *\n         * @param nullString the String to convert to and from {@code null}. No substitution occurs if {@code null}.\n         * @return This instance.\n         */\n        public Builder setNullString(final String nullString) {\n            this.nullString = nullString;\n            this.quotedNullString = quoteCharacter + nullString + quoteCharacter;\n            return this;\n        }",
    "importString": "",
    "lineNum": 15,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "setQuote(Character)",
    "sourceCode": "/**\n         * Sets the quote character, use {@code null} to disable.\n         *\n         * @param quoteCharacter the quote character, use {@code null} to disable.\n         * @return This instance.\n         */\n        public Builder setQuote(final Character quoteCharacter) {\n            if (isLineBreak(quoteCharacter)) {\n                throw new IllegalArgumentException(\"The quoteCharacter cannot be a line break\");\n            }\n            this.quoteCharacter = quoteCharacter;\n            return this;\n        }",
    "importString": "",
    "lineNum": 12,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "setRecordSeparator(char)",
    "sourceCode": "/**\n         * Sets the record separator to use for output.\n         *\n         * <p>\n         * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r'\n         * and \"\\r\\n\"\n         * </p>\n         *\n         * @param recordSeparator the record separator to use for output.\n         * @return This instance.\n         */\n        public Builder setRecordSeparator(final char recordSeparator) {\n            this.recordSeparator = String.valueOf(recordSeparator);\n            return this;\n        }",
    "importString": "",
    "lineNum": 14,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "setRecordSeparator(String)",
    "sourceCode": "/**\n         * Sets the record separator to use for output.\n         *\n         * <p>\n         * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r'\n         * and \"\\r\\n\"\n         * </p>\n         *\n         * @param recordSeparator the record separator to use for output.\n         * @return This instance.\n         */\n        public Builder setRecordSeparator(final String recordSeparator) {\n            this.recordSeparator = recordSeparator;\n            return this;\n        }",
    "importString": "",
    "lineNum": 14,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "setTrailingData(boolean)",
    "sourceCode": "/**\n         * Sets whether reading trailing data is allowed in records, helps Excel compatibility.\n         *\n         * @param trailingData whether reading trailing data is allowed in records, helps Excel compatibility.\n         * @return This instance.\n         * @since 1.11.0\n         */\n        public Builder setTrailingData(final boolean trailingData) {\n            this.trailingData = trailingData;\n            return this;\n        }",
    "importString": "",
    "lineNum": 10,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "clone(T...) <T>",
    "sourceCode": "// @formatter:on\n\n    /**\n     * Null-safe clone of an array.\n     *\n     * @param <T>    The array element type.\n     * @param values the source array\n     * @return the cloned array.\n     */\n    @SafeVarargs\n    static <T> T[] clone(final T... values) {\n        return values == null ? null : values.clone();\n    }",
    "importString": "",
    "lineNum": 12,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "newFormat(char)",
    "sourceCode": "/**\n     * Creates a new CSV format with the specified delimiter.\n     *\n     * <p>\n     * Use this method if you want to create a CSVFormat from scratch. All fields but the delimiter will be initialized with null/false.\n     * </p>\n     *\n     * @param delimiter the char used for value separation, must not be a line break character\n     * @return a new CSV format.\n     * @throws IllegalArgumentException if the delimiter is a line break character\n     * @see #DEFAULT\n     * @see #RFC4180\n     * @see #MYSQL\n     * @see #EXCEL\n     * @see #TDF\n     */\n    public static CSVFormat newFormat(final char delimiter) {\n        return new CSVFormat(new Builder().setDelimiter(delimiter));\n    }",
    "importString": "",
    "lineNum": 18,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "trim(CharSequence)",
    "sourceCode": "static CharSequence trim(final CharSequence charSequence) {\n        if (charSequence instanceof String) {\n            return ((String) charSequence).trim();\n        }\n        final int count = charSequence.length();\n        int len = count;\n        int pos = 0;\n\n        while (pos < len && isTrimChar(charSequence, pos)) {\n            pos++;\n        }\n        while (pos < len && isTrimChar(charSequence, len - 1)) {\n            len--;\n        }\n        return pos > 0 || len < count ? charSequence.subSequence(pos, len) : charSequence;\n    }",
    "importString": "",
    "lineNum": 15,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "equals(Object)",
    "sourceCode": "@Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n        final CSVFormat other = (CSVFormat) obj;\n        return allowMissingColumnNames == other.allowMissingColumnNames && autoFlush == other.autoFlush &&\n                Objects.equals(commentMarker, other.commentMarker) && Objects.equals(delimiter, other.delimiter) &&\n                duplicateHeaderMode == other.duplicateHeaderMode && Objects.equals(escapeCharacter, other.escapeCharacter) &&\n                Arrays.equals(headerComments, other.headerComments) && Arrays.equals(headers, other.headers) &&\n                ignoreEmptyLines == other.ignoreEmptyLines && ignoreHeaderCase == other.ignoreHeaderCase &&\n                ignoreSurroundingSpaces == other.ignoreSurroundingSpaces && lenientEof == other.lenientEof &&\n                Objects.equals(nullString, other.nullString) && Objects.equals(quoteCharacter, other.quoteCharacter) &&\n                quoteMode == other.quoteMode && Objects.equals(quotedNullString, other.quotedNullString) &&\n                Objects.equals(recordSeparator, other.recordSeparator) && skipHeaderRecord == other.skipHeaderRecord &&\n                trailingData == other.trailingData && trailingDelimiter == other.trailingDelimiter && trim == other.trim;\n    }",
    "importString": "",
    "lineNum": 22,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "getAllowDuplicateHeaderNames()",
    "sourceCode": "/**\n     * Gets whether duplicate names are allowed in the headers.\n     *\n     * @return whether duplicate header names are allowed\n     * @since 1.7\n     * @deprecated Use {@link #getDuplicateHeaderMode()}.\n     */\n    @Deprecated\n    public boolean getAllowDuplicateHeaderNames() {\n        return duplicateHeaderMode == DuplicateHeaderMode.ALLOW_ALL;\n    }",
    "importString": "",
    "lineNum": 10,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "getCommentMarker()",
    "sourceCode": "/**\n     * Gets the comment marker character, {@code null} disables comments.\n     * <p>\n     * The comment start character is only recognized at the start of a line.\n     * </p>\n     * <p>\n     * Comments are printed first, before headers.\n     * </p>\n     * <p>\n     * Use {@link Builder#setCommentMarker(char)} or {@link Builder#setCommentMarker(Character)} to set the comment marker written at the start of each comment\n     * line.\n     * </p>\n     * <p>\n     * If the comment marker is not set, then the header comments are ignored.\n     * </p>\n     * <p>\n     * For example:\n     * </p>\n     *\n     * <pre>\n     * builder.setCommentMarker('#').setHeaderComments(\"Generated by Apache Commons CSV\", Instant.ofEpochMilli(0));\n     * </pre>\n     * <p>\n     * writes:\n     * </p>\n     *\n     * <pre>\n     * # Generated by Apache Commons CSV.\n     * # 1970-01-01T00:00:00Z\n     * </pre>\n     *\n     * @return the comment start marker, may be {@code null}\n     */\n    public Character getCommentMarker() {\n        return commentMarker;\n    }",
    "importString": "",
    "lineNum": 35,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "getHeaderComments()",
    "sourceCode": "/**\n     * Gets a copy of the header comment array to write before the CSV data.\n     * <p>\n     * This setting is ignored by the parser.\n     * </p>\n     * <p>\n     * Comments are printed first, before headers.\n     * </p>\n     * <p>\n     * Use {@link Builder#setCommentMarker(char)} or {@link Builder#setCommentMarker(Character)} to set the comment marker written at the start of each comment\n     * line.\n     * </p>\n     * <p>\n     * If the comment marker is not set, then the header comments are ignored.\n     * </p>\n     * <p>\n     * For example:\n     * </p>\n     *\n     * <pre>\n     * builder.setCommentMarker('#').setHeaderComments(\"Generated by Apache Commons CSV\", Instant.ofEpochMilli(0));\n     * </pre>\n     * <p>\n     * writes:\n     * </p>\n     *\n     * <pre>\n     * # Generated by Apache Commons CSV.\n     * # 1970-01-01T00:00:00Z\n     * </pre>\n     *\n     * @return a copy of the header comment array; {@code null} if disabled.\n     */\n    public String[] getHeaderComments() {\n        return headerComments != null ? headerComments.clone() : null;\n    }",
    "importString": "",
    "lineNum": 35,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "getMaxRows()",
    "sourceCode": "/**\n     * Gets the maximum number of rows to process, excluding the header row.\n     * <p>\n     * Values less than or equal to 0 mean no limit.\n     * </p>\n     *\n     * @return The maximum number of rows to process, excluding the header row.\n     * @since 1.14.0\n     */\n    public long getMaxRows() {\n        return maxRows;\n    }",
    "importString": "",
    "lineNum": 11,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "getNullString()",
    "sourceCode": "/**\n     * Gets the String to convert to and from {@code null}.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     */\n    public String getNullString() {\n        return nullString;\n    }",
    "importString": "",
    "lineNum": 11,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "isDelimiter(char, CharSequence, int, char[], int)",
    "sourceCode": "/**\n     * Tests whether the next characters constitute a delimiter\n     *\n     * @param ch0             the first char (index 0).\n     * @param charSeq         the match char sequence\n     * @param startIndex      where start to match\n     * @param delimiter       the delimiter\n     * @param delimiterLength the delimiter length\n     * @return true if the match is successful\n     */\n    private boolean isDelimiter(final char ch0, final CharSequence charSeq, final int startIndex, final char[] delimiter, final int delimiterLength) {\n        if (ch0 != delimiter[0]) {\n            return false;\n        }\n        final int len = charSeq.length();\n        if (startIndex + delimiterLength > len) {\n            return false;\n        }\n        for (int i = 1; i < delimiterLength; i++) {\n            if (charSeq.charAt(startIndex + i) != delimiter[i]) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "importString": "",
    "lineNum": 24,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "parse(Reader)",
    "sourceCode": "/**\n     * Parses the specified content.\n     *\n     * <p>\n     * See also the various static parse methods on {@link CSVParser}.\n     * </p>\n     *\n     * @param reader the input stream\n     * @return a parser over a stream of {@link CSVRecord}s.\n     * @throws IOException  If an I/O error occurs\n     * @throws CSVException Thrown on invalid input.\n     */\n    public CSVParser parse(final Reader reader) throws IOException {\n        return CSVParser.builder().setReader(reader).setFormat(this).get();\n    }",
    "importString": "",
    "lineNum": 14,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "print(Appendable)",
    "sourceCode": "/**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out the output.\n     * @return a printer to an output.\n     * @throws IOException thrown if the optional header cannot be printed.\n     */\n    public CSVPrinter print(final Appendable out) throws IOException {\n        return new CSVPrinter(out, this);\n    }",
    "importString": "",
    "lineNum": 13,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "print(File, Charset)",
    "sourceCode": "/**\n     * Prints to the specified {@code File} with given {@code Charset}.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out     the output.\n     * @param charset A charset.\n     * @return a printer to an output.\n     * @throws IOException thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    public CSVPrinter print(final File out, final Charset charset) throws IOException {\n        return print(out.toPath(), charset);\n    }",
    "importString": "",
    "lineNum": 15,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "print(InputStream, Appendable, boolean)",
    "sourceCode": "private void print(final InputStream inputStream, final Appendable out, final boolean newRecord) throws IOException {\n        // InputStream is never null here\n        // There is nothing to escape when quoting is used which is the default.\n        if (!newRecord) {\n            append(getDelimiterString(), out);\n        }\n        final boolean quoteCharacterSet = isQuoteCharacterSet();\n        if (quoteCharacterSet) {\n            append(getQuoteCharacter().charValue(), out); // Explicit (un)boxing is intentional\n        }\n        // Stream the input to the output without reading or holding the whole value in memory.\n        // AppendableOutputStream cannot \"close\" an Appendable.\n        try (OutputStream outputStream = new Base64OutputStream(new AppendableOutputStream<>(out))) {\n            IOUtils.copy(inputStream, outputStream);\n        }\n        if (quoteCharacterSet) {\n            append(getQuoteCharacter().charValue(), out); // Explicit (un)boxing is intentional\n        }\n    }",
    "importString": "",
    "lineNum": 18,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "print(Object, Appendable, boolean)",
    "sourceCode": "/**\n     * Prints the {@code value} as the next value on the line to {@code out}. The value will be escaped or encapsulated as needed. Useful when one wants to\n     * avoid creating CSVPrinters. Trims the value if {@link #getTrim()} is true.\n     *\n     * @param value     value to output.\n     * @param out       where to print the value.\n     * @param newRecord if this a new record.\n     * @throws IOException If an I/O error occurs.\n     * @since 1.4\n     */\n    public synchronized void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {\n        // null values are considered empty\n        // Only call CharSequence.toString() if you have to, helps GC-free use cases.\n        CharSequence charSequence;\n        if (value == null) {\n            // https://issues.apache.org/jira/browse/CSV-203\n            if (null == nullString) {\n                charSequence = Constants.EMPTY;\n            } else if (QuoteMode.ALL == quoteMode) {\n                charSequence = quotedNullString;\n            } else {\n                charSequence = nullString;\n            }\n        } else if (value instanceof CharSequence) {\n            charSequence = (CharSequence) value;\n        } else if (value instanceof Reader) {\n            print((Reader) value, out, newRecord);\n            return;\n        } else if (value instanceof InputStream) {\n            print((InputStream) value, out, newRecord);\n            return;\n        } else {\n            charSequence = value.toString();\n        }\n        charSequence = getTrim() ? trim(charSequence) : charSequence;\n        print(value, charSequence, out, newRecord);\n    }",
    "importString": "",
    "lineNum": 36,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "print(Object, CharSequence, Appendable, boolean)",
    "sourceCode": "private synchronized void print(final Object object, final CharSequence value, final Appendable out, final boolean newRecord) throws IOException {\n        final int offset = 0;\n        final int len = value.length();\n        if (!newRecord) {\n            out.append(getDelimiterString());\n        }\n        if (object == null) {\n            out.append(value);\n        } else if (isQuoteCharacterSet()) {\n            // The original object is needed so can check for Number\n            printWithQuotes(object, value, out, newRecord);\n        } else if (isEscapeCharacterSet()) {\n            printWithEscapes(value, out);\n        } else {\n            out.append(value, offset, len);\n        }\n    }",
    "importString": "",
    "lineNum": 16,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "print(Path, Charset)",
    "sourceCode": "/**\n     * Prints to the specified {@code Path} with given {@code Charset}, returns a {@code CSVPrinter} which the caller MUST close.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out     the output.\n     * @param charset A charset.\n     * @return a printer to an output.\n     * @throws IOException thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVPrinter print(final Path out, final Charset charset) throws IOException {\n        return print(Files.newBufferedWriter(out, charset));\n    }",
    "importString": "",
    "lineNum": 16,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "print(Reader, Appendable, boolean)",
    "sourceCode": "private void print(final Reader reader, final Appendable out, final boolean newRecord) throws IOException {\n        // Reader is never null here\n        if (!newRecord) {\n            append(getDelimiterString(), out);\n        }\n        if (isQuoteCharacterSet()) {\n            printWithQuotes(reader, out);\n        } else if (isEscapeCharacterSet()) {\n            printWithEscapes(reader, out);\n        } else if (out instanceof Writer) {\n            IOUtils.copyLarge(reader, (Writer) out);\n        } else {\n            IOUtils.copy(reader, out);\n        }\n    }",
    "importString": "",
    "lineNum": 14,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "printer()",
    "sourceCode": "/**\n     * Prints to the {@link System#out}.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @return a printer to {@link System#out}.\n     * @throws IOException thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    public CSVPrinter printer() throws IOException {\n        return new CSVPrinter(System.out, this);\n    }",
    "importString": "",
    "lineNum": 13,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "println(Appendable)",
    "sourceCode": "/**\n     * Outputs the trailing delimiter (if set) followed by the record separator (if set).\n     *\n     * @param appendable where to write\n     * @throws IOException If an I/O error occurs.\n     * @since 1.4\n     */\n    public synchronized void println(final Appendable appendable) throws IOException {\n        if (getTrailingDelimiter()) {\n            append(getDelimiterString(), appendable);\n        }\n        if (recordSeparator != null) {\n            append(recordSeparator, appendable);\n        }\n    }",
    "importString": "",
    "lineNum": 14,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "printRecord(Appendable, Object...)",
    "sourceCode": "/**\n     * Prints the given {@code values} to {@code out} as a single record of delimiter-separated values followed by the record separator.\n     *\n     * <p>\n     * The values will be quoted if needed. Quotes and new-line characters will be escaped. This method adds the record separator to the output after printing\n     * the record, so there is no need to call {@link #println(Appendable)}.\n     * </p>\n     *\n     * @param appendable where to write.\n     * @param values     values to output.\n     * @throws IOException If an I/O error occurs.\n     * @since 1.4\n     */\n    public synchronized void printRecord(final Appendable appendable, final Object... values) throws IOException {\n        for (int i = 0; i < values.length; i++) {\n            print(values[i], appendable, i == 0);\n        }\n        println(appendable);\n    }",
    "importString": "",
    "lineNum": 18,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "printWithEscapes(CharSequence, Appendable)",
    "sourceCode": "/*\n     * This method must only be called if escaping is enabled, otherwise can throw exceptions.\n     */\n    private void printWithEscapes(final CharSequence charSeq, final Appendable appendable) throws IOException {\n        int start = 0;\n        int pos = 0;\n        final int end = charSeq.length();\n        final char[] delimArray = getDelimiterCharArray();\n        final int delimLength = delimArray.length;\n        final char escape = getEscapeChar();\n        while (pos < end) {\n            char c = charSeq.charAt(pos);\n            final boolean isDelimiterStart = isDelimiter(c, charSeq, pos, delimArray, delimLength);\n            final boolean isCr = c == Constants.CR;\n            final boolean isLf = c == Constants.LF;\n            if (isCr || isLf || c == escape || isDelimiterStart) {\n                // write out segment up until this char\n                if (pos > start) {\n                    appendable.append(charSeq, start, pos);\n                }\n                if (isLf) {\n                    c = 'n';\n                } else if (isCr) {\n                    c = 'r';\n                }\n                escape(c, appendable);\n                if (isDelimiterStart) {\n                    for (int i = 1; i < delimLength; i++) {\n                        pos++;\n                        escape(charSeq.charAt(pos), appendable);\n                    }\n                }\n                start = pos + 1; // start on the current char after this one\n            }\n            pos++;\n        }\n\n        // write last segment\n        if (pos > start) {\n            appendable.append(charSeq, start, pos);\n        }\n    }",
    "importString": "",
    "lineNum": 41,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "printWithEscapes(Reader, Appendable)",
    "sourceCode": "/*\n     * This method must only be called if escaping is enabled, otherwise can throw exceptions.\n     */\n    private void printWithEscapes(final Reader reader, final Appendable appendable) throws IOException {\n        int start = 0;\n        int pos = 0;\n        @SuppressWarnings(\"resource\") // Temp reader on input reader.\n        final ExtendedBufferedReader bufferedReader = new ExtendedBufferedReader(reader);\n        final char[] delimArray = getDelimiterCharArray();\n        final int delimLength = delimArray.length;\n        final char escape = getEscapeChar();\n        final StringBuilder builder = new StringBuilder(IOUtils.DEFAULT_BUFFER_SIZE);\n        int c;\n        final char[] lookAheadBuffer = new char[delimLength - 1];\n        while (EOF != (c = bufferedReader.read())) {\n            builder.append((char) c);\n            Arrays.fill(lookAheadBuffer, (char) 0);\n            bufferedReader.peek(lookAheadBuffer);\n            final String test = builder.toString() + new String(lookAheadBuffer);\n            final boolean isDelimiterStart = isDelimiter((char) c, test, pos, delimArray, delimLength);\n            final boolean isCr = c == Constants.CR;\n            final boolean isLf = c == Constants.LF;\n            if (isCr || isLf || c == escape || isDelimiterStart) {\n                // write out segment up until this char\n                if (pos > start) {\n                    append(builder.substring(start, pos), appendable);\n                    builder.setLength(0);\n                    pos = -1;\n                }\n                if (isLf) {\n                    c = 'n';\n                } else if (isCr) {\n                    c = 'r';\n                }\n                escape((char) c, appendable);\n                if (isDelimiterStart) {\n                    for (int i = 1; i < delimLength; i++) {\n                        escape((char) bufferedReader.read(), appendable);\n                    }\n                }\n                start = pos + 1; // start on the current char after this one\n            }\n            pos++;\n        }\n        // write last segment\n        if (pos > start) {\n            appendable.append(builder, start, pos);\n        }\n    }",
    "importString": "",
    "lineNum": 48,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "printWithQuotes(Object, CharSequence, Appendable, boolean)",
    "sourceCode": "/*\n     * This method must only be called if quoting is enabled, otherwise will generate NPE.\n     * The original object is needed so can check for Number\n     */\n    private void printWithQuotes(final Object object, final CharSequence charSeq, final Appendable out, final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = 0;\n        int pos = 0;\n        final int len = charSeq.length();\n        final char[] delim = getDelimiterCharArray();\n        final int delimLength = delim.length;\n        final char quoteChar = getQuoteCharacter().charValue(); // Explicit (un)boxing is intentional\n        // If escape char not specified, default to the quote char\n        // This avoids having to keep checking whether there is an escape character\n        // at the cost of checking against quote twice\n        final char escapeChar = isEscapeCharacterSet() ? getEscapeChar() : quoteChar;\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n        switch (quoteModePolicy) {\n        case ALL:\n        case ALL_NON_NULL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printWithEscapes(charSeq, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // Always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = charSeq.charAt(pos);\n                if (c <= Constants.COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    while (pos < len) {\n                        c = charSeq.charAt(pos);\n                        if (c == Constants.LF || c == Constants.CR || c == quoteChar || c == escapeChar || isDelimiter(c, charSeq, pos, delim, delimLength)) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = len - 1;\n                        c = charSeq.charAt(pos);\n                        // Some other chars at the end caused the parser to fail, so for now\n                        // encapsulate if we end in anything less than ' '\n                        if (isTrimChar(c)) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n            if (!quote) {\n                // No encapsulation needed - write out the original value\n                out.append(charSeq, start, len);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n        if (!quote) {\n            // No encapsulation needed - write out the original value\n            out.append(charSeq, start, len);\n            return;\n        }\n        // We hit something that needed encapsulation\n        out.append(quoteChar);\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < len) {\n            final char c = charSeq.charAt(pos);\n            if (c == quoteChar || c == escapeChar) {\n                // write out the chunk up until this point\n                out.append(charSeq, start, pos);\n                out.append(escapeChar); // now output the escape\n                start = pos; // and restart with the matched char\n            }\n            pos++;\n        }\n        // Write the last segment\n        out.append(charSeq, start, pos);\n        out.append(quoteChar);\n    }",
    "importString": "",
    "lineNum": 100,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "printWithQuotes(Reader, Appendable)",
    "sourceCode": "/**\n     * Always use quotes unless QuoteMode is NONE, so we do not have to look ahead.\n     *\n     * @param reader     What to print\n     * @param appendable Where to print it\n     * @throws IOException If an I/O error occurs\n     */\n    private void printWithQuotes(final Reader reader, final Appendable appendable) throws IOException {\n        if (getQuoteMode() == QuoteMode.NONE) {\n            printWithEscapes(reader, appendable);\n            return;\n        }\n        final char quote = getQuoteCharacter().charValue(); // Explicit (un)boxing is intentional\n        // (1) Append opening quote\n        append(quote, appendable);\n        // (2) Append Reader contents, doubling quotes\n        int c;\n        while (EOF != (c = reader.read())) {\n            append((char) c, appendable);\n            if (c == quote) {\n                append(quote, appendable);\n            }\n        }\n        // (3) Append closing quote\n        append(quote, appendable);\n    }",
    "importString": "",
    "lineNum": 25,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "toString()",
    "sourceCode": "@Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\n        if (isEscapeCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"Escape=<\").append(escapeCharacter).append('>');\n        }\n        if (isQuoteCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\n        }\n        if (quoteMode != null) {\n            sb.append(' ');\n            sb.append(\"QuoteMode=<\").append(quoteMode).append('>');\n        }\n        if (isCommentMarkerSet()) {\n            sb.append(' ');\n            sb.append(\"CommentStart=<\").append(commentMarker).append('>');\n        }\n        if (isNullStringSet()) {\n            sb.append(' ');\n            sb.append(\"NullString=<\").append(nullString).append('>');\n        }\n        if (recordSeparator != null) {\n            sb.append(' ');\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\n        }\n        if (getIgnoreEmptyLines()) {\n            sb.append(\" EmptyLines:ignored\");\n        }\n        if (getIgnoreSurroundingSpaces()) {\n            sb.append(\" SurroundingSpaces:ignored\");\n        }\n        if (getIgnoreHeaderCase()) {\n            sb.append(\" IgnoreHeaderCase:ignored\");\n        }\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\n        if (headerComments != null) {\n            sb.append(' ');\n            sb.append(\"HeaderComments:\").append(Arrays.toString(headerComments));\n        }\n        if (headers != null) {\n            sb.append(' ');\n            sb.append(\"Header:\").append(Arrays.toString(headers));\n        }\n        return sb.toString();\n    }",
    "importString": "",
    "lineNum": 47,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "validate()",
    "sourceCode": "/**\n     * Verifies the validity and consistency of the attributes, and throws an {@link IllegalArgumentException} if necessary.\n     * <p>\n     * Because an instance can be used for both writing and parsing, not all conditions can be tested here. For example, allowMissingColumnNames is only used\n     * for parsing, so it cannot be used here.\n     * </p>\n     *\n     * @throws IllegalArgumentException Throw when any attribute is invalid or inconsistent with other attributes.\n     */\n    private void validate() throws IllegalArgumentException {\n        if (quoteCharacter != null && contains(delimiter, quoteCharacter.charValue())) { // Explicit (un)boxing is intentional\n            throw new IllegalArgumentException(\"The quoteChar character and the delimiter cannot be the same ('\" + quoteCharacter + \"')\");\n        }\n        if (escapeCharacter != null && contains(delimiter, escapeCharacter.charValue())) { // Explicit (un)boxing is intentional\n            throw new IllegalArgumentException(\"The escape character and the delimiter cannot be the same ('\" + escapeCharacter + \"')\");\n        }\n        if (commentMarker != null && contains(delimiter, commentMarker.charValue())) { // Explicit (un)boxing is intentional\n            throw new IllegalArgumentException(\"The comment start character and the delimiter cannot be the same ('\" + commentMarker + \"')\");\n        }\n        if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\"The comment start character and the quoteChar cannot be the same ('\" + commentMarker + \"')\");\n        }\n        if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\"The comment start and the escape character cannot be the same ('\" + commentMarker + \"')\");\n        }\n        if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\n            throw new IllegalArgumentException(\"Quote mode set to NONE but no escape character is set\");\n        }\n        // Validate headers\n        if (headers != null && duplicateHeaderMode != DuplicateHeaderMode.ALLOW_ALL) {\n            final Set<String> dupCheckSet = new HashSet<>(headers.length);\n            final boolean emptyDuplicatesAllowed = duplicateHeaderMode == DuplicateHeaderMode.ALLOW_EMPTY;\n            for (final String header : headers) {\n                final boolean blank = isBlank(header);\n                // Sanitize all empty headers to the empty string \"\" when checking duplicates\n                final boolean containsHeader = !dupCheckSet.add(blank ? \"\" : header);\n                if (containsHeader && !(blank && emptyDuplicatesAllowed)) {\n                    throw new IllegalArgumentException(String.format(\n                            \"The header contains a duplicate name: \\\"%s\\\" in %s. If this is valid then use CSVFormat.Builder.setDuplicateHeaderMode().\", header,\n                            Arrays.toString(headers)));\n                }\n            }\n        }\n    }",
    "importString": "",
    "lineNum": 43,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "withAllowDuplicateHeaderNames()",
    "sourceCode": "/**\n     * Builds a new {@code CSVFormat} that allows duplicate header names.\n     *\n     * @return a new {@code CSVFormat} that allows duplicate header names\n     * @since 1.7\n     * @deprecated Use {@link Builder#setAllowDuplicateHeaderNames(boolean) Builder#setAllowDuplicateHeaderNames(true)}\n     */\n    @Deprecated\n    public CSVFormat withAllowDuplicateHeaderNames() {\n        return builder().setDuplicateHeaderMode(DuplicateHeaderMode.ALLOW_ALL).get();\n    }",
    "importString": "",
    "lineNum": 10,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "withAllowDuplicateHeaderNames(boolean)",
    "sourceCode": "/**\n     * Builds a new {@code CSVFormat} with duplicate header names behavior set to the given value.\n     *\n     * @param allowDuplicateHeaderNames the duplicate header names behavior, true to allow, false to disallow.\n     * @return a new {@code CSVFormat} with duplicate header names behavior set to the given value.\n     * @since 1.7\n     * @deprecated Use {@link Builder#setAllowDuplicateHeaderNames(boolean)}\n     */\n    @Deprecated\n    public CSVFormat withAllowDuplicateHeaderNames(final boolean allowDuplicateHeaderNames) {\n        final DuplicateHeaderMode mode = allowDuplicateHeaderNames ? DuplicateHeaderMode.ALLOW_ALL : DuplicateHeaderMode.ALLOW_EMPTY;\n        return builder().setDuplicateHeaderMode(mode).get();\n    }",
    "importString": "",
    "lineNum": 12,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "withAllowMissingColumnNames()",
    "sourceCode": "/**\n     * Builds a new {@code CSVFormat} with the missing column names behavior of the format set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     * @see Builder#setAllowMissingColumnNames(boolean)\n     * @since 1.1\n     * @deprecated Use {@link Builder#setAllowMissingColumnNames(boolean) Builder#setAllowMissingColumnNames(true)}\n     */\n    @Deprecated\n    public CSVFormat withAllowMissingColumnNames() {\n        return builder().setAllowMissingColumnNames(true).get();\n    }",
    "importString": "",
    "lineNum": 11,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "withAllowMissingColumnNames(boolean)",
    "sourceCode": "/**\n     * Builds a new {@code CSVFormat} with the missing column names behavior of the format set to the given value.\n     *\n     * @param allowMissingColumnNames the missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to cause\n     *                                an {@link IllegalArgumentException} to be thrown.\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     * @deprecated Use {@link Builder#setAllowMissingColumnNames(boolean)}\n     */\n    @Deprecated\n    public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n        return builder().setAllowMissingColumnNames(allowMissingColumnNames).get();\n    }",
    "importString": "",
    "lineNum": 11,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "withAutoFlush(boolean)",
    "sourceCode": "/**\n     * Builds a new {@code CSVFormat} with whether to flush on close.\n     *\n     * @param autoFlush whether to flush on close.\n     * @return A new CSVFormat that is equal to this but with the specified autoFlush setting.\n     * @since 1.6\n     * @deprecated Use {@link Builder#setAutoFlush(boolean)}\n     */\n    @Deprecated\n    public CSVFormat withAutoFlush(final boolean autoFlush) {\n        return builder().setAutoFlush(autoFlush).get();\n    }",
    "importString": "",
    "lineNum": 11,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "withCommentMarker(char)",
    "sourceCode": "/**\n     * Builds a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker the comment start marker\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException thrown if the specified character is a line break\n     * @deprecated Use {@link Builder#setCommentMarker(char)}\n     */\n    @Deprecated\n    public CSVFormat withCommentMarker(final char commentMarker) {\n        return builder().setCommentMarker(commentMarker).get();\n    }",
    "importString": "",
    "lineNum": 13,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "withCommentMarker(Character)",
    "sourceCode": "/**\n     * Builds a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker the comment start marker, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException thrown if the specified character is a line break\n     * @deprecated Use {@link Builder#setCommentMarker(Character)}\n     */\n    @Deprecated\n    public CSVFormat withCommentMarker(final Character commentMarker) {\n        return builder().setCommentMarker(commentMarker).get();\n    }",
    "importString": "",
    "lineNum": 13,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "withDelimiter(char)",
    "sourceCode": "/**\n     * Builds a new {@code CSVFormat} with the delimiter of the format set to the specified character.\n     *\n     * @param delimiter the delimiter character\n     * @return A new CSVFormat that is equal to this with the specified character as a delimiter\n     * @throws IllegalArgumentException thrown if the specified character is a line break\n     * @deprecated Use {@link Builder#setDelimiter(char)}\n     */\n    @Deprecated\n    public CSVFormat withDelimiter(final char delimiter) {\n        return builder().setDelimiter(delimiter).get();\n    }",
    "importString": "",
    "lineNum": 11,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "withEscape(char)",
    "sourceCode": "/**\n     * Builds a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape the escape character\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\n     * @throws IllegalArgumentException thrown if the specified character is a line break\n     * @deprecated Use {@link Builder#setEscape(char)}\n     */\n    @Deprecated\n    public CSVFormat withEscape(final char escape) {\n        return builder().setEscape(escape).get();\n    }",
    "importString": "",
    "lineNum": 11,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "withEscape(Character)",
    "sourceCode": "/**\n     * Builds a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape the escape character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\n     * @throws IllegalArgumentException thrown if the specified character is a line break\n     * @deprecated Use {@link Builder#setEscape(Character)}\n     */\n    @Deprecated\n    public CSVFormat withEscape(final Character escape) {\n        return builder().setEscape(escape).get();\n    }",
    "importString": "",
    "lineNum": 11,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "withFirstRecordAsHeader()",
    "sourceCode": "// @formatter:off\n    /**\n     * Builds a new {@code CSVFormat} using the first record as header.\n     *\n     * <p>\n     * Calling this method is equivalent to calling:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat format = aFormat.builder()\n     *                           .setHeader()\n     *                           .setSkipHeaderRecord(true)\n     *                           .get();\n     * </pre>\n     *\n     * @return A new CSVFormat that is equal to this but using the first record as header.\n     * @see Builder#setSkipHeaderRecord(boolean)\n     * @see Builder#setHeader(String...)\n     * @since 1.3\n     * @deprecated Use {@link Builder#setHeader(String...) Builder#setHeader()}.{@link Builder#setSkipHeaderRecord(boolean) setSkipHeaderRecord(true)}.\n     */\n    // @formatter:on\n    @Deprecated\n    public CSVFormat withFirstRecordAsHeader() {\n        // @formatter:off\n        return builder()\n                .setHeader()\n                .setSkipHeaderRecord(true)\n                .get();\n        // @formatter:on\n    }",
    "importString": "",
    "lineNum": 30,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "withHeader(Class<? extends Enum<?>>)",
    "sourceCode": "/**\n     * Builds a new {@code CSVFormat} with the header of the format defined by the enum class.\n     *\n     * <p>\n     * Example:\n     * </p>\n     *\n     * <pre>\n     * public enum MyHeader {\n     *     Name, Email, Phone\n     * }\n     * ...\n     * CSVFormat format = aFormat.builder().setHeader(MyHeader.class).get();\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param headerEnum the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see Builder#setHeader(String...)\n     * @see Builder#setSkipHeaderRecord(boolean)\n     * @since 1.3\n     * @deprecated Use {@link Builder#setHeader(Class)}\n     */\n    @Deprecated\n    public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) {\n        return builder().setHeader(headerEnum).get();\n    }",
    "importString": "",
    "lineNum": 28,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "withHeader(ResultSet)",
    "sourceCode": "/**\n     * Builds a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can either be parsed automatically from the\n     * input file with:\n     *\n     * <pre>\n     * CSVFormat format = aFormat.builder().setHeader().get();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aFormat.builder().setHeader(resultSet).get();\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param resultSet the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user-specified otherwise.\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     * @deprecated Use {@link Builder#setHeader(ResultSet)}\n     */\n    @Deprecated\n    public CSVFormat withHeader(final ResultSet resultSet) throws SQLException {\n        return builder().setHeader(resultSet).get();\n    }",
    "importString": "",
    "lineNum": 26,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "withHeader(ResultSetMetaData)",
    "sourceCode": "/**\n     * Builds a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can either be parsed automatically from the\n     * input file with:\n     *\n     * <pre>\n     * CSVFormat format = aFormat.builder().setHeader().get()\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aFormat.builder().setHeader(resultSetMetaData).get()\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param resultSetMetaData the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     * @deprecated Use {@link Builder#setHeader(ResultSetMetaData)}\n     */\n    @Deprecated\n    public CSVFormat withHeader(final ResultSetMetaData resultSetMetaData) throws SQLException {\n        return builder().setHeader(resultSetMetaData).get();\n    }",
    "importString": "",
    "lineNum": 26,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "withHeader(String...)",
    "sourceCode": "/**\n     * Builds a new {@code CSVFormat} with the header of the format set to the given values. The header can either be parsed automatically from the input file\n     * with:\n     *\n     * <pre>\n     * CSVFormat format = aFormat.builder().setHeader().get();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>{@code\n     * CSVFormat format = aFormat.builder().setHeader(\"name\", \"email\", \"phone\").get();\n     * }</pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param header the header, {@code null} if disabled, empty if parsed automatically, user-specified otherwise.\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see Builder#setSkipHeaderRecord(boolean)\n     * @deprecated Use {@link Builder#setHeader(String...)}\n     */\n    @Deprecated\n    public CSVFormat withHeader(final String... header) {\n        return builder().setHeader(header).get();\n    }",
    "importString": "",
    "lineNum": 25,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "withHeaderComments(Object...)",
    "sourceCode": "/**\n     * Builds a new {@code CSVFormat} with the header comments of the format set to the given values. The comments will be printed first, before the headers.\n     * This setting is ignored by the parser.\n     *\n     * <pre>{@code\n     * CSVFormat format = aFormat.builder().setHeaderComments(\"Generated by Apache Commons CSV.\", Instant.now()).get();\n     * }</pre>\n     *\n     * @param headerComments the headerComments which will be printed by the Printer before the actual CSV data.\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see Builder#setSkipHeaderRecord(boolean)\n     * @since 1.1\n     * @deprecated Use {@link Builder#setHeaderComments(Object...)}\n     */\n    @Deprecated\n    public CSVFormat withHeaderComments(final Object... headerComments) {\n        return builder().setHeaderComments(headerComments).get();\n    }",
    "importString": "",
    "lineNum": 17,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "withIgnoreEmptyLines()",
    "sourceCode": "/**\n     * Builds a new {@code CSVFormat} with the empty line skipping behavior of the format set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     * @see Builder#setIgnoreEmptyLines(boolean)\n     * @since 1.1\n     * @deprecated Use {@link Builder#setIgnoreEmptyLines(boolean) Builder#setIgnoreEmptyLines(true)}\n     */\n    @Deprecated\n    public CSVFormat withIgnoreEmptyLines() {\n        return builder().setIgnoreEmptyLines(true).get();\n    }",
    "importString": "",
    "lineNum": 11,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "withIgnoreEmptyLines(boolean)",
    "sourceCode": "/**\n     * Builds a new {@code CSVFormat} with the empty line skipping behavior of the format set to the given value.\n     *\n     * @param ignoreEmptyLines the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate empty\n     *                         lines to empty records.\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     * @deprecated Use {@link Builder#setIgnoreEmptyLines(boolean)}\n     */\n    @Deprecated\n    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n        return builder().setIgnoreEmptyLines(ignoreEmptyLines).get();\n    }",
    "importString": "",
    "lineNum": 11,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "withIgnoreHeaderCase()",
    "sourceCode": "/**\n     * Builds a new {@code CSVFormat} with the header ignore case behavior set to {@code true}.\n     *\n     * @return A new CSVFormat that will ignore the new case header name behavior.\n     * @see Builder#setIgnoreHeaderCase(boolean)\n     * @since 1.3\n     * @deprecated Use {@link Builder#setIgnoreHeaderCase(boolean) Builder#setIgnoreHeaderCase(true)}\n     */\n    @Deprecated\n    public CSVFormat withIgnoreHeaderCase() {\n        return builder().setIgnoreHeaderCase(true).get();\n    }",
    "importString": "",
    "lineNum": 11,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "withIgnoreHeaderCase(boolean)",
    "sourceCode": "/**\n     * Builds a new {@code CSVFormat} with whether header names should be accessed ignoring case.\n     *\n     * @param ignoreHeaderCase the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.\n     * @return A new CSVFormat that will ignore case header name if specified as {@code true}\n     * @since 1.3\n     * @deprecated Use {@link Builder#setIgnoreHeaderCase(boolean)}\n     */\n    @Deprecated\n    public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) {\n        return builder().setIgnoreHeaderCase(ignoreHeaderCase).get();\n    }",
    "importString": "",
    "lineNum": 11,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "withIgnoreSurroundingSpaces()",
    "sourceCode": "/**\n     * Builds a new {@code CSVFormat} with the parser trimming behavior of the format set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified parser trimming behavior.\n     * @see Builder#setIgnoreSurroundingSpaces(boolean)\n     * @since 1.1\n     * @deprecated Use {@link Builder#setIgnoreSurroundingSpaces(boolean) Builder#setIgnoreSurroundingSpaces(true)}\n     */\n    @Deprecated\n    public CSVFormat withIgnoreSurroundingSpaces() {\n        return builder().setIgnoreSurroundingSpaces(true).get();\n    }",
    "importString": "",
    "lineNum": 11,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "withIgnoreSurroundingSpaces(boolean)",
    "sourceCode": "/**\n     * Builds a new {@code CSVFormat} with the parser trimming behavior of the format set to the given value.\n     *\n     * @param ignoreSurroundingSpaces the parser trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the spaces as is.\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n     * @deprecated Use {@link Builder#setIgnoreSurroundingSpaces(boolean)}\n     */\n    @Deprecated\n    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n        return builder().setIgnoreSurroundingSpaces(ignoreSurroundingSpaces).get();\n    }",
    "importString": "",
    "lineNum": 10,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "withNullString(String)",
    "sourceCode": "/**\n     * Builds a new {@code CSVFormat} with conversions to and from null for strings on input and output.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @param nullString the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     * @return A new CSVFormat that is equal to this but with the specified null conversion string.\n     * @deprecated Use {@link Builder#setNullString(String)}\n     */\n    @Deprecated\n    public CSVFormat withNullString(final String nullString) {\n        return builder().setNullString(nullString).get();\n    }",
    "importString": "",
    "lineNum": 14,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "withQuote(char)",
    "sourceCode": "/**\n     * Builds a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\n     *\n     * @param quoteChar the quote character\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException thrown if the specified character is a line break\n     * @deprecated Use {@link Builder#setQuote(char)}\n     */\n    @Deprecated\n    public CSVFormat withQuote(final char quoteChar) {\n        return builder().setQuote(quoteChar).get();\n    }",
    "importString": "",
    "lineNum": 11,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "withQuote(Character)",
    "sourceCode": "/**\n     * Builds a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\n     *\n     * @param quoteChar the quote character, use {@code null} to disable.\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException thrown if the specified character is a line break\n     * @deprecated Use {@link Builder#setQuote(Character)}\n     */\n    @Deprecated\n    public CSVFormat withQuote(final Character quoteChar) {\n        return builder().setQuote(quoteChar).get();\n    }",
    "importString": "",
    "lineNum": 11,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "withQuoteMode(QuoteMode)",
    "sourceCode": "/**\n     * Builds a new {@code CSVFormat} with the output quote policy of the format set to the specified value.\n     *\n     * @param quoteMode the quote policy to use for output.\n     * @return A new CSVFormat that is equal to this but with the specified quote policy\n     * @deprecated Use {@link Builder#setQuoteMode(QuoteMode)}\n     */\n    @Deprecated\n    public CSVFormat withQuoteMode(final QuoteMode quoteMode) {\n        return builder().setQuoteMode(quoteMode).get();\n    }",
    "importString": "",
    "lineNum": 10,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "withRecordSeparator(char)",
    "sourceCode": "/**\n     * Builds a new {@code CSVFormat} with the record separator of the format set to the specified character.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r' and\n     * \"\\r\\n\"\n     * </p>\n     *\n     * @param recordSeparator the record separator to use for output.\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\n     * @deprecated Use {@link Builder#setRecordSeparator(char)}\n     */\n    @Deprecated\n    public CSVFormat withRecordSeparator(final char recordSeparator) {\n        return builder().setRecordSeparator(recordSeparator).get();\n    }",
    "importString": "",
    "lineNum": 15,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "withRecordSeparator(String)",
    "sourceCode": "/**\n     * Builds a new {@code CSVFormat} with the record separator of the format set to the specified String.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r' and\n     * \"\\r\\n\"\n     * </p>\n     *\n     * @param recordSeparator the record separator to use for output.\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\n     * @throws IllegalArgumentException if recordSeparator is none of CR, LF or CRLF\n     * @deprecated Use {@link Builder#setRecordSeparator(String)}\n     */\n    @Deprecated\n    public CSVFormat withRecordSeparator(final String recordSeparator) {\n        return builder().setRecordSeparator(recordSeparator).get();\n    }",
    "importString": "",
    "lineNum": 16,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "withSkipHeaderRecord()",
    "sourceCode": "/**\n     * Builds a new {@code CSVFormat} with skipping the header record set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\n     * @see Builder#setSkipHeaderRecord(boolean)\n     * @see Builder#setHeader(String...)\n     * @since 1.1\n     * @deprecated Use {@link Builder#setSkipHeaderRecord(boolean) Builder#setSkipHeaderRecord(true)}\n     */\n    @Deprecated\n    public CSVFormat withSkipHeaderRecord() {\n        return builder().setSkipHeaderRecord(true).get();\n    }",
    "importString": "",
    "lineNum": 12,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "withSkipHeaderRecord(boolean)",
    "sourceCode": "/**\n     * Builds a new {@code CSVFormat} with whether to skip the header record.\n     *\n     * @param skipHeaderRecord whether to skip the header record.\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\n     * @see Builder#setHeader(String...)\n     * @deprecated Use {@link Builder#setSkipHeaderRecord(boolean)}\n     */\n    @Deprecated\n    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n        return builder().setSkipHeaderRecord(skipHeaderRecord).get();\n    }",
    "importString": "",
    "lineNum": 11,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "withSystemRecordSeparator()",
    "sourceCode": "/**\n     * Builds a new {@code CSVFormat} with the record separator of the format set to the operating system's line separator string, typically CR+LF on Windows\n     * and LF on Linux.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r' and\n     * \"\\r\\n\"\n     * </p>\n     *\n     * @return A new CSVFormat that is equal to this but with the operating system's line separator string.\n     * @since 1.6\n     * @deprecated Use {@link Builder#setRecordSeparator(String) setRecordSeparator(System.lineSeparator())}\n     */\n    @Deprecated\n    public CSVFormat withSystemRecordSeparator() {\n        return builder().setRecordSeparator(System.lineSeparator()).get();\n    }",
    "importString": "",
    "lineNum": 16,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "withTrailingDelimiter()",
    "sourceCode": "/**\n     * Builds a new {@code CSVFormat} to add a trailing delimiter.\n     *\n     * @return A new CSVFormat that is equal to this but with the trailing delimiter setting.\n     * @since 1.3\n     * @deprecated Use {@link Builder#setTrailingDelimiter(boolean) Builder#setTrailingDelimiter(true)}\n     */\n    @Deprecated\n    public CSVFormat withTrailingDelimiter() {\n        return builder().setTrailingDelimiter(true).get();\n    }",
    "importString": "",
    "lineNum": 10,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "withTrailingDelimiter(boolean)",
    "sourceCode": "/**\n     * Builds a new {@code CSVFormat} with whether to add a trailing delimiter.\n     *\n     * @param trailingDelimiter whether to add a trailing delimiter.\n     * @return A new CSVFormat that is equal to this but with the specified trailing delimiter setting.\n     * @since 1.3\n     * @deprecated Use {@link Builder#setTrailingDelimiter(boolean)}\n     */\n    @Deprecated\n    public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) {\n        return builder().setTrailingDelimiter(trailingDelimiter).get();\n    }",
    "importString": "",
    "lineNum": 11,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "withTrim()",
    "sourceCode": "/**\n     * Builds a new {@code CSVFormat} to trim leading and trailing blanks. See {@link #getTrim()} for details of where this is used.\n     *\n     * @return A new CSVFormat that is equal to this but with the trim setting on.\n     * @since 1.3\n     * @deprecated Use {@link Builder#setTrim(boolean) Builder#setTrim(true)}\n     */\n    @Deprecated\n    public CSVFormat withTrim() {\n        return builder().setTrim(true).get();\n    }",
    "importString": "",
    "lineNum": 10,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "withTrim(boolean)",
    "sourceCode": "/**\n     * Builds a new {@code CSVFormat} with whether to trim leading and trailing blanks. See {@link #getTrim()} for details of where this is used.\n     *\n     * @param trim whether to trim leading and trailing blanks.\n     * @return A new CSVFormat that is equal to this but with the specified trim setting.\n     * @since 1.3\n     * @deprecated Use {@link Builder#setTrim(boolean)}\n     */\n    @Deprecated\n    public CSVFormat withTrim(final boolean trim) {\n        return builder().setTrim(trim).get();\n    }",
    "importString": "",
    "lineNum": 11,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  {
    "symbolName": "setTrackBytes(boolean)",
    "sourceCode": "/**\n         * Sets whether to enable byte tracking for the parser.\n         *\n         * @param trackBytes {@code true} to enable byte tracking; {@code false} to disable it.\n         * @return this instance.\n         * @since 1.13.0\n         */\n        public Builder setTrackBytes(final boolean trackBytes) {\n            this.trackBytes = trackBytes;\n            return asThis();\n        }",
    "importString": "",
    "lineNum": 10,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVParser.java"
  },
  {
    "symbolName": "getNextRecord()",
    "sourceCode": "/**\n         * Gets the next record or null at the end of stream or max rows read.\n         *\n         * @throws IOException  on parse error or input read-failure\n         * @throws CSVException on invalid input.\n         * @return the next record, or {@code null} if the end of the stream has been reached.\n         */\n        private CSVRecord getNextRecord() {\n            CSVRecord record = null;\n            if (format.useRow(recordNumber + 1)) {\n                record = Uncheck.get(CSVParser.this::nextRecord);\n            }\n            return record;\n        }",
    "importString": "",
    "lineNum": 13,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVParser.java"
  },
  {
    "symbolName": "next()",
    "sourceCode": "@Override\n        public CSVRecord next() {\n            if (isClosed()) {\n                throw new NoSuchElementException(\"CSVParser has been closed\");\n            }\n            CSVRecord next = current;\n            current = null;\n            if (next == null) {\n                // hasNext() wasn't called before\n                next = getNextRecord();\n                if (next == null) {\n                    throw new NoSuchElementException(\"No more CSV records available\");\n                }\n            }\n            return next;\n        }",
    "importString": "",
    "lineNum": 15,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVParser.java"
  },
  {
    "symbolName": "parse(File, Charset, CSVFormat)",
    "sourceCode": "/**\n     * Creates a parser for the given {@link File}.\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            The Charset to decode the given file, {@code null} maps to the {@link Charset#defaultCharset() default Charset}.\n     * @param format\n     *            the CSVFormat used for CSV parsing, {@code null} maps to {@link CSVFormat#DEFAULT}.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @throws CSVException Thrown on invalid CSV input data.\n     * @throws NullPointerException if {@code file} is {@code null}.\n     */\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Objects.requireNonNull(file, \"file\");\n        return parse(file.toPath(), charset, format);\n    }",
    "importString": "",
    "lineNum": 20,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVParser.java"
  },
  {
    "symbolName": "parse(InputStream, Charset, CSVFormat)",
    "sourceCode": "/**\n     * Creates a CSV parser using the given {@link CSVFormat}.\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param inputStream\n     *            an InputStream containing CSV-formatted input, {@code null} maps to {@link CSVFormat#DEFAULT}.\n     * @param charset\n     *            The Charset to decode the given file, {@code null} maps to the {@link Charset#defaultCharset() default Charset}.\n     * @param format\n     *            the CSVFormat used for CSV parsing, {@code null} maps to {@link CSVFormat#DEFAULT}.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @throws CSVException Thrown on invalid CSV input data.\n     * @since 1.5\n     */\n    public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format)\n            throws IOException {\n        return parse(new InputStreamReader(inputStream, Charsets.toCharset(charset)), format);\n    }",
    "importString": "",
    "lineNum": 25,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVParser.java"
  },
  {
    "symbolName": "parse(Path, Charset, CSVFormat)",
    "sourceCode": "/**\n     * Creates and returns a parser for the given {@link Path}, which the caller MUST close.\n     *\n     * @param path\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            The Charset to decode the given file, {@code null} maps to the {@link Charset#defaultCharset() default Charset}.\n     * @param format\n     *            the CSVFormat used for CSV parsing, {@code null} maps to {@link CSVFormat#DEFAULT}.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @throws CSVException Thrown on invalid CSV input data.\n     * @throws NullPointerException if {@code path} is {@code null}.\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException {\n        Objects.requireNonNull(path, \"path\");\n        return parse(Files.newInputStream(path), charset, format);\n    }",
    "importString": "",
    "lineNum": 22,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVParser.java"
  },
  {
    "symbolName": "parse(Reader, CSVFormat)",
    "sourceCode": "/**\n     * Creates a CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing, {@code null} maps to {@link CSVFormat#DEFAULT}.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @throws CSVException Thrown on invalid CSV input data.\n     * @since 1.5\n     */\n    public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException {\n        return builder().setReader(reader).setFormat(format).get();\n    }",
    "importString": "",
    "lineNum": 22,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVParser.java"
  },
  {
    "symbolName": "parse(String, CSVFormat)",
    "sourceCode": "/**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing, {@code null} maps to {@link CSVFormat#DEFAULT}.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @throws CSVException Thrown on invalid CSV input data.\n     * @throws NullPointerException if {@code string} is {@code null}.\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Objects.requireNonNull(string, \"string\");\n        return parse(new StringReader(string), format);\n    }",
    "importString": "",
    "lineNum": 18,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVParser.java"
  },
  {
    "symbolName": "parse(URL, Charset, CSVFormat)",
    "sourceCode": "/**\n     * Creates and returns a parser for the given URL, which the caller MUST close.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource, {@code null} maps to the {@link Charset#defaultCharset() default Charset}.\n     * @param format\n     *            the CSVFormat used for CSV parsing, {@code null} maps to {@link CSVFormat#DEFAULT}.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @throws CSVException Thrown on invalid CSV input data.\n     * @throws NullPointerException if {@code url} is {@code null}.\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Objects.requireNonNull(url, \"url\");\n        return parse(url.openStream(), charset, format);\n    }",
    "importString": "",
    "lineNum": 26,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVParser.java"
  },
  {
    "symbolName": "createHeaders()",
    "sourceCode": "/**\n     * Creates the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     * @throws CSVException on invalid input.\n     */\n    private Headers createHeaders() throws IOException {\n        Map<String, Integer> headerMap = null;\n        List<String> headerNames = null;\n        final String[] formatHeader = format.getHeader();\n        if (formatHeader != null) {\n            headerMap = createEmptyHeaderMap();\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                    headerComment = nextRecord.getComment();\n                }\n            } else {\n                if (format.getSkipHeaderRecord()) {\n                    final CSVRecord nextRecord = nextRecord();\n                    if (nextRecord != null) {\n                        headerComment = nextRecord.getComment();\n                    }\n                }\n                headerRecord = formatHeader;\n            }\n            // build the name to index mappings\n            if (headerRecord != null) {\n                // Track an occurrence of a null, empty or blank header.\n                boolean observedMissing = false;\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean blankHeader = CSVFormat.isBlank(header);\n                    if (blankHeader && !format.getAllowMissingColumnNames()) {\n                        throw new IllegalArgumentException(\"A header name is missing in \" + Arrays.toString(headerRecord));\n                    }\n                    final boolean containsHeader = blankHeader ? observedMissing : headerMap.containsKey(header);\n                    final DuplicateHeaderMode headerMode = format.getDuplicateHeaderMode();\n                    final boolean duplicatesAllowed = headerMode == DuplicateHeaderMode.ALLOW_ALL;\n                    final boolean emptyDuplicatesAllowed = headerMode == DuplicateHeaderMode.ALLOW_EMPTY;\n                    if (containsHeader && !duplicatesAllowed && !(blankHeader && emptyDuplicatesAllowed)) {\n                        throw new IllegalArgumentException(String.format(\n                                \"The header contains a duplicate name: \\\"%s\\\" in %s. If this is valid then use CSVFormat.Builder.setDuplicateHeaderMode().\",\n                                header, Arrays.toString(headerRecord)));\n                    }\n                    observedMissing |= blankHeader;\n                    if (header != null) {\n                        headerMap.put(header, Integer.valueOf(i)); // Explicit (un)boxing is intentional\n                        if (headerNames == null) {\n                            headerNames = new ArrayList<>(headerRecord.length);\n                        }\n                        headerNames.add(header);\n                    }\n                }\n            }\n        }\n        // Make header names Collection immutable\n        return new Headers(headerMap, headerNames == null ? Collections.emptyList() : Collections.unmodifiableList(headerNames));\n    }",
    "importString": "",
    "lineNum": 62,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVParser.java"
  },
  {
    "symbolName": "getCurrentLineNumber()",
    "sourceCode": "/**\n     * Gets the current line number in the input stream.\n     *\n     * <p>\n     * <strong>Note:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number.\n     */\n    public long getCurrentLineNumber() {\n        return lexer.getCurrentLineNumber();\n    }",
    "importString": "",
    "lineNum": 12,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVParser.java"
  },
  {
    "symbolName": "getHeaderMap()",
    "sourceCode": "/**\n     * Gets a copy of the header map as defined in the CSVFormat's header.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * <p>\n     * <strong>Note:</strong> The map can only provide a one-to-one mapping when the format did not\n     * contain null or duplicate column names.\n     * </p>\n     *\n     * @return a copy of the header map.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        if (headers.headerMap == null) {\n            return null;\n        }\n        final Map<String, Integer> map = createEmptyHeaderMap();\n        map.putAll(headers.headerMap);\n        return map;\n    }",
    "importString": "",
    "lineNum": 19,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVParser.java"
  },
  {
    "symbolName": "getHeaderNames()",
    "sourceCode": "/**\n     * Gets a read-only list of header names that iterates in column order as defined in the CSVFormat's header.\n     * <p>\n     * Note: The list provides strings that can be used as keys in the header map.\n     * The list will not contain null column names if they were present in the input\n     * format.\n     * </p>\n     *\n     * @return read-only list of header names that iterates in column order.\n     * @see #getHeaderMap()\n     * @since 1.7\n     */\n    public List<String> getHeaderNames() {\n        return Collections.unmodifiableList(headers.headerNames);\n    }",
    "importString": "",
    "lineNum": 14,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVParser.java"
  },
  {
    "symbolName": "getRecordNumber()",
    "sourceCode": "/**\n     * Gets the current record number in the input stream.\n     *\n     * <p>\n     * <strong>Note:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current record number\n     */\n    public long getRecordNumber() {\n        return recordNumber;\n    }",
    "importString": "",
    "lineNum": 12,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVParser.java"
  },
  {
    "symbolName": "getRecords()",
    "sourceCode": "/**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     * <p>\n     * You can use {@link CSVFormat.Builder#setMaxRows(long)} to limit how many rows this method produces.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws UncheckedIOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() {\n        return stream().collect(Collectors.toList());\n    }",
    "importString": "",
    "lineNum": 17,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVParser.java"
  },
  {
    "symbolName": "handleNull(String)",
    "sourceCode": "/**\n     * Handles whether the input is parsed as null\n     *\n     * @param input\n     *           the cell data to further processed\n     * @return null if input is parsed as null, or input itself if the input isn't parsed as null\n     */\n    private String handleNull(final String input) {\n        final boolean isQuoted = reusableToken.isQuoted;\n        final String nullString = format.getNullString();\n        final boolean strictQuoteMode = isStrictQuoteMode();\n        if (input.equals(nullString)) {\n            // nullString = NULL(String), distinguish between \"NULL\" and NULL in ALL_NON_NULL or NON_NUMERIC quote mode\n            return strictQuoteMode && isQuoted ? input : null;\n        }\n        // don't set nullString, distinguish between \"\" and ,, (absent values) in All_NON_NULL or NON_NUMERIC quote mode\n        return strictQuoteMode && nullString == null && input.isEmpty() && !isQuoted ? null : input;\n    }",
    "importString": "",
    "lineNum": 17,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVParser.java"
  },
  {
    "symbolName": "hasHeaderComment()",
    "sourceCode": "/**\n     * Checks whether there is a header comment.\n     * The header comment appears before the header record.\n     * Note that if the parser's format has been given an explicit header\n     * (with {@link CSVFormat.Builder#setHeader(String... )} or another overload)\n     * and the header record is not being skipped\n     * ({@link CSVFormat.Builder#setSkipHeaderRecord} is false) then any initial comments\n     * will be associated with the first record, not the header.\n     *\n     * @return true if this parser has seen a header comment, false otherwise\n     * @since 1.10.0\n     */\n    public boolean hasHeaderComment() {\n        return headerComment != null;\n    }",
    "importString": "",
    "lineNum": 14,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVParser.java"
  },
  {
    "symbolName": "hasTrailerComment()",
    "sourceCode": "/**\n     * Checks whether there is a trailer comment.\n     * Trailer comments are located between the last record and EOF.\n     * The trailer comments will only be available after the parser has\n     * finished processing this stream.\n     *\n     * @return true if this parser has seen a trailer comment, false otherwise\n     * @since 1.10.0\n     */\n    public boolean hasTrailerComment() {\n        return trailerComment != null;\n    }",
    "importString": "",
    "lineNum": 11,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVParser.java"
  },
  {
    "symbolName": "iterator()",
    "sourceCode": "/**\n     * Returns the record iterator.\n     *\n     * <p>\n     * An {@link IOException} caught during the iteration is re-thrown as an\n     * {@link IllegalStateException}.\n     * </p>\n     * <p>\n     * If the parser is closed, the iterator will not yield any more records.\n     * A call to {@link Iterator#hasNext()} will return {@code false} and\n     * a call to {@link Iterator#next()} will throw a\n     * {@link NoSuchElementException}.\n     * </p>\n     * <p>\n     * If it is necessary to construct an iterator which is usable after the\n     * parser is closed, one option is to extract all records as a list with\n     * {@link #getRecords()}, and return an iterator to that list.\n     * </p>\n     * <p>\n     * You can use {@link CSVFormat.Builder#setMaxRows(long)} to limit how many rows an Iterator produces.\n     * </p>\n     */\n    @Override\n    public Iterator<CSVRecord> iterator() {\n        return csvRecordIterator;\n    }",
    "importString": "",
    "lineNum": 25,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVParser.java"
  },
  {
    "symbolName": "nextRecord()",
    "sourceCode": "/**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or {@code null} if the end of the stream has been reached.\n     * @throws IOException  on parse error or input read-failure.\n     * @throws CSVException on invalid CSV input data.\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        recordList.clear();\n        StringBuilder sb = null;\n        final long startCharPosition = lexer.getCharacterPosition() + characterOffset;\n        final long startBytePosition = lexer.getBytesRead() + this.characterOffset;\n        do {\n            reusableToken.reset();\n            lexer.nextToken(reusableToken);\n            switch (reusableToken.type) {\n            case TOKEN:\n                addRecordValue(false);\n                break;\n            case EORECORD:\n                addRecordValue(true);\n                break;\n            case EOF:\n                if (reusableToken.isReady) {\n                    addRecordValue(true);\n                } else if (sb != null) {\n                    trailerComment = sb.toString();\n                }\n                break;\n            case INVALID:\n                throw new CSVException(\"(line %,d) invalid parse sequence\", getCurrentLineNumber());\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(reusableToken.content);\n                reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new CSVException(\"Unexpected Token type: %s\", reusableToken.type);\n            }\n        } while (reusableToken.type == TOKEN);\n\n        if (!recordList.isEmpty()) {\n            recordNumber++;\n            final String comment = Objects.toString(sb, null);\n            result = new CSVRecord(this, recordList.toArray(Constants.EMPTY_STRING_ARRAY), comment,\n                recordNumber, startCharPosition, startBytePosition);\n        }\n        return result;\n    }",
    "importString": "",
    "lineNum": 53,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVParser.java"
  },
  {
    "symbolName": "stream()",
    "sourceCode": "/**\n     * Returns a sequential {@code Stream} with this collection as its source.\n     * <p>\n     * If the parser is closed, the stream will not produce any more values.\n     * See the comments in {@link #iterator()}.\n     * </p>\n     * <p>\n     * You can use {@link CSVFormat.Builder#setMaxRows(long)} to limit how many rows a Stream produces.\n     * </p>\n     *\n     * @return a sequential {@code Stream} with this collection as its source.\n     * @since 1.9.0\n     */\n    public Stream<CSVRecord> stream() {\n        return StreamSupport.stream(Spliterators.spliteratorUnknownSize(iterator(), Spliterator.ORDERED), false);\n    }",
    "importString": "",
    "lineNum": 15,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVParser.java"
  },
  {
    "symbolName": "close(boolean)",
    "sourceCode": "/**\n     * Closes the underlying stream with an optional flush first.\n     *\n     * @param flush whether to flush before the actual close.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.6\n     * @see CSVFormat#getAutoFlush()\n     */\n    public void close(final boolean flush) throws IOException {\n        if (flush || format.getAutoFlush()) {\n            flush();\n        }\n        if (appendable instanceof Closeable) {\n            ((Closeable) appendable).close();\n        }\n    }",
    "importString": "",
    "lineNum": 16,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVPrinter.java"
  },
  {
    "symbolName": "flush()",
    "sourceCode": "/**\n     * Flushes the underlying stream.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void flush() throws IOException {\n        if (appendable instanceof Flushable) {\n            ((Flushable) appendable).flush();\n        }\n    }",
    "importString": "",
    "lineNum": 11,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVPrinter.java"
  },
  {
    "symbolName": "print(Object)",
    "sourceCode": "/**\n     * Prints the string as the next value on the line. The value will be escaped or encapsulated as needed.\n     *\n     * @param value\n     *            value to be output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public synchronized void print(final Object value) throws IOException {\n        format.print(value, appendable, newRecord);\n        newRecord = false;\n    }",
    "importString": "",
    "lineNum": 11,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVPrinter.java"
  },
  {
    "symbolName": "printComment(String)",
    "sourceCode": "/**\n     * Prints a comment on a new line among the delimiter-separated values.\n     *\n     * <p>\n     * Comments will always begin on a new line and occupy at least one full line. The character specified to start\n     * comments and a space will be inserted at the beginning of each new line in the comment.\n     * </p>\n     *\n     * <p>\n     * If comments are disabled in the current CSV format this method does nothing.\n     * </p>\n     *\n     * <p>This method detects line breaks inside the comment string and inserts {@link CSVFormat#getRecordSeparator()}\n     * to start a new line of the comment. Note that this might produce unexpected results for formats that do not use\n     * line breaks as record separators.</p>\n     *\n     * @param comment\n     *            the comment to output\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public synchronized void printComment(final String comment) throws IOException {\n        if (comment == null || !format.isCommentMarkerSet()) {\n            return;\n        }\n        if (!newRecord) {\n            println();\n        }\n        appendable.append(format.getCommentMarker().charValue()); // Explicit (un)boxing is intentional\n        appendable.append(SP);\n        for (int i = 0; i < comment.length(); i++) {\n            final char c = comment.charAt(i);\n            switch (c) {\n            case CR:\n                if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) {\n                    i++;\n                }\n                // falls-through: break intentionally excluded.\n            case LF:\n                println();\n                appendable.append(format.getCommentMarker().charValue()); // Explicit (un)boxing is intentional\n                appendable.append(SP);\n                break;\n            default:\n                appendable.append(c);\n                break;\n            }\n        }\n        println();\n    }",
    "importString": "",
    "lineNum": 49,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVPrinter.java"
  },
  {
    "symbolName": "printHeaders(ResultSet)",
    "sourceCode": "/**\n     * Prints headers for a result set based on its metadata.\n     *\n     * @param resultSet The ResultSet to query for metadata.\n     * @throws IOException If an I/O error occurs.\n     * @throws SQLException If a database access error occurs or this method is called on a closed result set.\n     * @since 1.9.0\n     */\n    public synchronized void printHeaders(final ResultSet resultSet) throws IOException, SQLException {\n        try (IOStream<String> stream = IOStream.of(format.builder().setHeader(resultSet).get().getHeader())) {\n            stream.forEachOrdered(this::print);\n        }\n        println();\n    }",
    "importString": "",
    "lineNum": 13,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVPrinter.java"
  },
  {
    "symbolName": "printRecord(Iterable<?>)",
    "sourceCode": "/**\n     * Prints the given values as a single record of delimiter-separated values followed by the record separator.\n     *\n     * <p>\n     * The values will be quoted if needed. Quotes and newLine characters will be escaped. This method adds the record\n     * separator to the output after printing the record, so there is no need to call {@link #println()}.\n     * </p>\n     *\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @SuppressWarnings(\"resource\")\n    public synchronized void printRecord(final Iterable<?> values) throws IOException {\n        IOStream.of(values).forEachOrdered(this::print);\n        endOfRecord();\n    }",
    "importString": "",
    "lineNum": 17,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVPrinter.java"
  },
  {
    "symbolName": "printRecord(Object...)",
    "sourceCode": "/**\n     * Prints the given values as a single record of delimiter-separated values followed by the record separator.\n     *\n     * <p>\n     * The values will be quoted if needed. Quotes and newLine characters will be escaped. This method adds the record\n     * separator to the output after printing the record, so there is no need to call {@link #println()}.\n     * </p>\n     *\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecord(final Object... values) throws IOException {\n        printRecord(Arrays.asList(values));\n    }",
    "importString": "",
    "lineNum": 15,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVPrinter.java"
  },
  {
    "symbolName": "printRecord(Stream<?>)",
    "sourceCode": "/**\n     * Prints the given values as a single record of delimiter-separated values followed by the record separator.\n     *\n     * <p>\n     * The values will be quoted if needed. Quotes and newLine characters will be escaped. This method adds the record\n     * separator to the output after printing the record, so there is no need to call {@link #println()}.\n     * </p>\n     *\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.10.0\n     */\n    @SuppressWarnings(\"resource\") // caller closes.\n    public synchronized void printRecord(final Stream<?> values) throws IOException {\n        IOStream.adapt(values).forEachOrdered(this::print);\n        endOfRecord();\n    }",
    "importString": "",
    "lineNum": 18,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVPrinter.java"
  },
  {
    "symbolName": "printRecords(Iterable<?>)",
    "sourceCode": "/**\n     * Prints all the objects in the given {@link Iterable} handling nested collections/arrays as records.\n     *\n     * <p>\n     * If the given Iterable only contains simple objects, this method will print a single record like\n     * {@link #printRecord(Iterable)}. If the given Iterable contains nested collections/arrays those nested elements\n     * will each be printed as records using {@link #printRecord(Object...)}.\n     * </p>\n     *\n     * <p>\n     * Given the following data structure:\n     * </p>\n     *\n     * <pre>{@code\n     * List<String[]> data = new ArrayList<>();\n     * data.add(new String[]{ \"A\", \"B\", \"C\" });\n     * data.add(new String[]{ \"1\", \"2\", \"3\" });\n     * data.add(new String[]{ \"A1\", \"B2\", \"C3\" });\n     * }\n     * </pre>\n     *\n     * <p>\n     * Calling this method will print:\n     * </p>\n     *\n     * <pre>\n     * {@code\n     * A, B, C\n     * 1, 2, 3\n     * A1, B2, C3\n     * }\n     * </pre>\n     *\n     * @param values\n     *            the values to print.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @SuppressWarnings(\"resource\")\n    public void printRecords(final Iterable<?> values) throws IOException {\n        printRecords(IOStream.of(values));\n    }",
    "importString": "",
    "lineNum": 41,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVPrinter.java"
  },
  {
    "symbolName": "printRecords(Object...)",
    "sourceCode": "/**\n     * Prints all the objects in the given array handling nested collections/arrays as records.\n     *\n     * <p>\n     * If the given array only contains simple objects, this method will print a single record like\n     * {@link #printRecord(Object...)}. If the given collections contain nested collections or arrays, those nested\n     * elements will each be printed as records using {@link #printRecord(Object...)}.\n     * </p>\n     *\n     * <p>\n     * Given the following data structure:\n     * </p>\n     *\n     * <pre>{@code\n     * String[][] data = new String[3][]\n     * data[0] = String[]{ \"A\", \"B\", \"C\" };\n     * data[1] = new String[]{ \"1\", \"2\", \"3\" };\n     * data[2] = new String[]{ \"A1\", \"B2\", \"C3\" };\n     * }\n     * </pre>\n     *\n     * <p>\n     * Calling this method will print:\n     * </p>\n     *\n     * <pre>{@code\n     * A, B, C\n     * 1, 2, 3\n     * A1, B2, C3\n     * }\n     * </pre>\n     *\n     * @param values\n     *            the values to print.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecords(final Object... values) throws IOException {\n        printRecords(Arrays.asList(values));\n    }",
    "importString": "",
    "lineNum": 39,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVPrinter.java"
  },
  {
    "symbolName": "printRecords(ResultSet)",
    "sourceCode": "/**\n     * Prints all the objects in the given JDBC result set.\n     * <p>\n     * You can use {@link CSVFormat.Builder#setMaxRows(long)} to limit how many rows a result set produces. This is most useful when you cannot limit rows\n     * through {@link Statement#setLargeMaxRows(long)} or {@link Statement#setMaxRows(int)}.\n     * </p>\n     *\n     * @param resultSet The values to print.\n     * @throws IOException  If an I/O error occurs.\n     * @throws SQLException Thrown when a database access error occurs.\n     */\n    public void printRecords(final ResultSet resultSet) throws SQLException, IOException {\n        final int columnCount = resultSet.getMetaData().getColumnCount();\n        while (resultSet.next() && format.useRow(resultSet.getRow())) {\n            for (int i = 1; i <= columnCount; i++) {\n                final Object object = resultSet.getObject(i);\n                if (object instanceof Clob) {\n                    try (Reader reader = ((Clob) object).getCharacterStream()) {\n                        print(reader);\n                    }\n                } else if (object instanceof Blob) {\n                    try (InputStream inputStream = ((Blob) object).getBinaryStream()) {\n                        print(inputStream);\n                    }\n                } else {\n                    print(object);\n                }\n            }\n            endOfRecord();\n        }\n    }",
    "importString": "",
    "lineNum": 30,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVPrinter.java"
  },
  {
    "symbolName": "printRecords(ResultSet, boolean)",
    "sourceCode": "/**\n     * Prints all the objects with metadata in the given JDBC result set based on the header boolean.\n     * <p>\n     * You can use {@link CSVFormat.Builder#setMaxRows(long)} to limit how many rows a result set produces. This is most useful when you cannot limit rows\n     * through {@link Statement#setLargeMaxRows(long)} or {@link Statement#setMaxRows(int)}.\n     * </p>\n     *\n     * @param resultSet source of row data.\n     * @param printHeader whether to print headers.\n     * @throws IOException If an I/O error occurs\n     * @throws SQLException if a database access error occurs\n     * @since 1.9.0\n     */\n    public void printRecords(final ResultSet resultSet, final boolean printHeader) throws SQLException, IOException {\n        if (printHeader) {\n            printHeaders(resultSet);\n        }\n        printRecords(resultSet);\n    }",
    "importString": "",
    "lineNum": 18,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVPrinter.java"
  },
  {
    "symbolName": "printRecords(Stream<?>)",
    "sourceCode": "/**\n     * Prints all the objects in the given {@link Stream} handling nested collections/arrays as records.\n     *\n     * <p>\n     * If the given Stream only contains simple objects, this method will print a single record like\n     * {@link #printRecord(Iterable)}. If the given Stream contains nested collections/arrays those nested elements\n     * will each be printed as records using {@link #printRecord(Object...)}.\n     * </p>\n     *\n     * <p>\n     * Given the following data structure:\n     * </p>\n     *\n     * <pre>{@code\n     * List<String[]> data = new ArrayList<>();\n     * data.add(new String[]{ \"A\", \"B\", \"C\" });\n     * data.add(new String[]{ \"1\", \"2\", \"3\" });\n     * data.add(new String[]{ \"A1\", \"B2\", \"C3\" });\n     * Stream<String[]> stream = data.stream();\n     * }\n     * </pre>\n     *\n     * <p>\n     * Calling this method will print:\n     * </p>\n     *\n     * <pre>\n     * {@code\n     * A, B, C\n     * 1, 2, 3\n     * A1, B2, C3\n     * }\n     * </pre>\n     *\n     * @param values\n     *            the values to print.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.10.0\n     */\n    @SuppressWarnings({ \"resource\" }) // Caller closes.\n    public void printRecords(final Stream<?> values) throws IOException {\n        printRecords(IOStream.adapt(values));\n    }",
    "importString": "",
    "lineNum": 43,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVPrinter.java"
  },
  {
    "symbolName": "get(String)",
    "sourceCode": "/**\n     * Returns a value by name. If multiple instances of the header name exists, only the last occurrence is returned.\n     *\n     * <p>\n     * Note: This requires a field mapping obtained from the original parser.\n     * A check using {@link #isMapped(String)} should be used to determine if a\n     * mapping exists from the provided {@code name} to a field index. In this case an\n     * exception will only be thrown if the record does not contain a field corresponding\n     * to the mapping, that is the record length is not consistent with the mapping size.\n     * </p>\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return the column value, maybe null depending on {@link CSVFormat#getNullString()}.\n     * @throws IllegalStateException\n     *             if no header mapping was provided\n     * @throws IllegalArgumentException\n     *             if {@code name} is not mapped or if the record is inconsistent\n     * @see #isMapped(String)\n     * @see #isConsistent()\n     * @see #getParser()\n     * @see CSVFormat.Builder#setNullString(String)\n     */\n    public String get(final String name) {\n        final Map<String, Integer> headerMap = getHeaderMapRaw();\n        if (headerMap == null) {\n            throw new IllegalStateException(\n                \"No header mapping was specified, the record values can't be accessed by name\");\n        }\n        final Integer index = headerMap.get(name);\n        if (index == null) {\n            throw new IllegalArgumentException(String.format(\"Mapping for %s not found, expected one of %s\", name,\n                headerMap.keySet()));\n        }\n        try {\n            return values[index.intValue()];  // Explicit (un)boxing is intentional\n        } catch (final ArrayIndexOutOfBoundsException e) {\n            throw new IllegalArgumentException(String.format(\n                \"Index for header '%s' is %d but CSVRecord only has %d values!\", name, index,\n                Integer.valueOf(values.length)));  // Explicit (un)boxing is intentional\n        }\n    }",
    "importString": "",
    "lineNum": 41,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVRecord.java"
  },
  {
    "symbolName": "getComment()",
    "sourceCode": "/**\n     * Returns the comment for this record, if any.\n     * Note that comments are attached to the following record.\n     * If there is no following record (that is, the comment is at EOF),\n     * then the comment will be ignored.\n     *\n     * @return the comment for this record, or null if no comment for this record is available.\n     */\n    public String getComment() {\n        return comment;\n    }",
    "importString": "",
    "lineNum": 10,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVRecord.java"
  },
  {
    "symbolName": "getParser()",
    "sourceCode": "/**\n     * Returns the parser.\n     *\n     * <p>\n     * Note: The parser is not part of the serialized state of the record. A null check\n     * should be used when the record may have originated from a serialized form.\n     * </p>\n     *\n     * @return the parser.\n     * @since 1.7\n     */\n    public CSVParser getParser() {\n        return parser;\n    }",
    "importString": "",
    "lineNum": 13,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVRecord.java"
  },
  {
    "symbolName": "getRecordNumber()",
    "sourceCode": "/**\n     * Returns the number of this record in the parsed CSV file.\n     *\n     * <p>\n     * <strong>NOTE:</strong>If your CSV input has multi-line values, the returned number does not correspond to\n     * the current line number of the parser that created this record.\n     * </p>\n     *\n     * @return the number of this record.\n     * @see CSVParser#getCurrentLineNumber()\n     */\n    public long getRecordNumber() {\n        return recordNumber;\n    }",
    "importString": "",
    "lineNum": 13,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVRecord.java"
  },
  {
    "symbolName": "hasComment()",
    "sourceCode": "/**\n     * Checks whether this record has a comment, false otherwise.\n     * Note that comments are attached to the following record.\n     * If there is no following record (that is, the comment is at EOF),\n     * then the comment will be ignored.\n     *\n     * @return true if this record has a comment, false otherwise\n     * @since 1.3\n     */\n    public boolean hasComment() {\n        return comment != null;\n    }",
    "importString": "",
    "lineNum": 11,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVRecord.java"
  },
  {
    "symbolName": "isConsistent()",
    "sourceCode": "/**\n     * Tells whether the record size matches the header size.\n     *\n     * <p>\n     * Returns true if the sizes for this record match and false if not. Some programs can export files that fail this\n     * test but still produce parsable files.\n     * </p>\n     *\n     * @return true of this record is valid, false if not\n     */\n    public boolean isConsistent() {\n        final Map<String, Integer> headerMap = getHeaderMapRaw();\n        return headerMap == null || headerMap.size() == values.length;\n    }",
    "importString": "",
    "lineNum": 13,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVRecord.java"
  },
  {
    "symbolName": "isMapped(String)",
    "sourceCode": "/**\n     * Checks whether a given column is mapped, that is, its name has been defined to the parser.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given column is mapped.\n     */\n    public boolean isMapped(final String name) {\n        final Map<String, Integer> headerMap = getHeaderMapRaw();\n        return headerMap != null && headerMap.containsKey(name);\n    }",
    "importString": "",
    "lineNum": 10,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVRecord.java"
  },
  {
    "symbolName": "putIn(M) <M extends Map<String, String>>",
    "sourceCode": "/**\n     * Puts all values of this record into the given Map.\n     *\n     * @param <M> the map type\n     * @param map The Map to populate.\n     * @return the given map.\n     * @since 1.9.0\n     */\n    public <M extends Map<String, String>> M putIn(final M map) {\n        if (getHeaderMapRaw() == null) {\n            return map;\n        }\n        getHeaderMapRaw().forEach((key, value) -> {\n            if (value < values.length) {\n                map.put(key, values[value]);\n            }\n        });\n        return map;\n    }",
    "importString": "",
    "lineNum": 18,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVRecord.java"
  },
  {
    "symbolName": "toList()",
    "sourceCode": "/**\n     * Converts the values to a new List.\n     * <p>\n     * Editing the list does not update this instance.\n     * </p>\n     *\n     * @return a new List\n     * @since 1.9.0\n     */\n    public List<String> toList() {\n        return stream().collect(Collectors.toList());\n    }",
    "importString": "",
    "lineNum": 11,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVRecord.java"
  },
  {
    "symbolName": "toMap()",
    "sourceCode": "/**\n     * Copies this record into a new Map of header name to record value. If multiple instances of a header name exist,\n     * then only the last occurrence is mapped.\n     *\n     * <p>\n     * Editing the map does not update this instance.\n     * </p>\n     *\n     * @return A new Map. The map is empty if the record has no headers.\n     */\n    public Map<String, String> toMap() {\n        return putIn(new LinkedHashMap<>(values.length));\n    }",
    "importString": "",
    "lineNum": 12,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVRecord.java"
  },
  {
    "symbolName": "toString()",
    "sourceCode": "/**\n     * Returns a string representation of the contents of this record. The result is constructed by comment, mapping,\n     * recordNumber and by passing the internal values array to {@link Arrays#toString(Object[])}.\n     *\n     * @return a String representation of this record.\n     */\n    @Override\n    public String toString() {\n        return \"CSVRecord [comment='\" + comment + \"', recordNumber=\" + recordNumber + \", values=\" +\n            Arrays.toString(values) + \"]\";\n    }",
    "importString": "",
    "lineNum": 10,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/CSVRecord.java"
  },
  {
    "symbolName": "close()",
    "sourceCode": "/**\n     * Closes the stream.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void close() throws IOException {\n        // Set ivars before calling super close() in case close() throws an IOException.\n        lastChar = EOF;\n        super.close();\n    }",
    "importString": "",
    "lineNum": 11,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java"
  },
  {
    "symbolName": "getEncodedCharLength(int)",
    "sourceCode": "/**\n     * Gets the byte length of the given character based on the the original Unicode\n     * specification, which defined characters as fixed-width 16-bit entities.\n     * <p>\n     * The Unicode characters are divided into two main ranges:\n     * <ul>\n     *   <li><b>U+0000 to U+FFFF (Basic Multilingual Plane, BMP):</b>\n     *     <ul>\n     *       <li>Represented using a single 16-bit {@code char}.</li>\n     *       <li>Includes UTF-8 encodings of 1-byte, 2-byte, and some 3-byte characters.</li>\n     *     </ul>\n     *   </li>\n     *   <li><b>U+10000 to U+10FFFF (Supplementary Characters):</b>\n     *     <ul>\n     *       <li>Represented as a pair of {@code char}s:</li>\n     *       <li>The first {@code char} is from the high-surrogates range (\\uD800-\\uDBFF).</li>\n     *       <li>The second {@code char} is from the low-surrogates range (\\uDC00-\\uDFFF).</li>\n     *       <li>Includes UTF-8 encodings of some 3-byte characters and all 4-byte characters.</li>\n     *     </ul>\n     *   </li>\n     * </ul>\n     *\n     * @param current the current character to process.\n     * @return the byte length of the character.\n     * @throws CharacterCodingException if the character cannot be encoded.\n     */\n    private int getEncodedCharLength(final int current) throws CharacterCodingException {\n        final char cChar = (char) current;\n        final char lChar = (char) lastChar;\n        if (!Character.isSurrogate(cChar)) {\n            return encoder.encode(CharBuffer.wrap(new char[] { cChar })).limit();\n        }\n        if (Character.isHighSurrogate(cChar)) {\n            // Move on to the next char (low surrogate)\n            return 0;\n        } else if (Character.isSurrogatePair(lChar, cChar)) {\n            return encoder.encode(CharBuffer.wrap(new char[] { lChar, cChar })).limit();\n        } else {\n            throw new CharacterCodingException();\n        }\n    }",
    "importString": "",
    "lineNum": 40,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java"
  },
  {
    "symbolName": "getLastChar()",
    "sourceCode": "/**\n     * Returns the last character that was read as an integer (0 to 65535). This will be the last character returned by\n     * any of the read methods. This will not include a character read using the {@link #peek()} method. If no\n     * character has been read then this will return {@link Constants#UNDEFINED}. If the end of the stream was reached\n     * on the last read then this will return {@link IOUtils#EOF}.\n     *\n     * @return the last character that was read\n     */\n    int getLastChar() {\n        return lastChar;\n    }",
    "importString": "",
    "lineNum": 10,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java"
  },
  {
    "symbolName": "getLineNumber()",
    "sourceCode": "/**\n     * Returns the current line number\n     *\n     * @return the current line number\n     */\n    long getLineNumber() {\n        // Check if we are at EOL or EOF or just starting\n        if (lastChar == CR || lastChar == LF || lastChar == UNDEFINED || lastChar == EOF) {\n            return lineNumber; // counter is accurate\n        }\n        return lineNumber + 1; // Allow for counter being incremented only at EOL\n    }",
    "importString": "",
    "lineNum": 11,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java"
  },
  {
    "symbolName": "read()",
    "sourceCode": "@Override\n    public int read() throws IOException {\n        final int current = super.read();\n        if (current == CR || current == LF && lastChar != CR ||\n            current == EOF && lastChar != CR && lastChar != LF && lastChar != EOF) {\n            lineNumber++;\n        }\n        if (encoder != null) {\n            this.bytesRead += getEncodedCharLength(current);\n        }\n        lastChar = current;\n        position++;\n        return lastChar;\n    }",
    "importString": "",
    "lineNum": 13,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java"
  },
  {
    "symbolName": "read(char[], int, int)",
    "sourceCode": "@Override\n    public int read(final char[] buf, final int offset, final int length) throws IOException {\n        if (length == 0) {\n            return 0;\n        }\n        final int len = super.read(buf, offset, length);\n        if (len > 0) {\n            for (int i = offset; i < offset + len; i++) {\n                final char ch = buf[i];\n                if (ch == LF) {\n                    if (CR != (i > offset ? buf[i - 1] : lastChar)) {\n                        lineNumber++;\n                    }\n                } else if (ch == CR) {\n                    lineNumber++;\n                }\n            }\n            lastChar = buf[offset + len - 1];\n        } else if (len == EOF) {\n            lastChar = EOF;\n        }\n        position += len;\n        return len;\n    }",
    "importString": "",
    "lineNum": 23,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java"
  },
  {
    "symbolName": "readLine()",
    "sourceCode": "/**\n     * Gets the next line, dropping the line terminator(s). This method should only be called when processing a\n     * comment, otherwise, information can be lost.\n     * <p>\n     * Increments {@link #lineNumber} and updates {@link #position}.\n     * </p>\n     * <p>\n     * Sets {@link #lastChar} to {@code Constants.EOF} at EOF, otherwise the last EOL character.\n     * </p>\n     *\n     * @return the line that was read, or null if reached EOF.\n     */\n    @Override\n    public String readLine() throws IOException {\n        if (peek() == EOF) {\n            return null;\n        }\n        final StringBuilder buffer = new StringBuilder();\n        while (true) {\n            final int current = read();\n            if (current == CR) {\n                final int next = peek();\n                if (next == LF) {\n                    read();\n                }\n            }\n            if (current == EOF || current == LF || current == CR) {\n                break;\n            }\n            buffer.append((char) current);\n        }\n        return buffer.toString();\n    }",
    "importString": "",
    "lineNum": 32,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java"
  },
  {
    "symbolName": "appendNextEscapedCharacterToToken(Token)",
    "sourceCode": "/**\n     * Appends the next escaped character to the token's content.\n     *\n     * @param token the current token\n     * @throws IOException  on stream access error\n     * @throws CSVException Thrown on invalid input.\n     */\n    private void appendNextEscapedCharacterToToken(final Token token) throws IOException {\n        if (isEscapeDelimiter()) {\n            token.content.append(delimiter);\n        } else {\n            final int unescaped = readEscape();\n            if (unescaped == EOF) { // unexpected char after escape\n                token.content.append((char) escape).append((char) reader.getLastChar());\n            } else {\n                token.content.append((char) unescaped);\n            }\n        }\n    }",
    "importString": "",
    "lineNum": 18,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/Lexer.java"
  },
  {
    "symbolName": "isDelimiter(int)",
    "sourceCode": "/**\n     * Determine whether the next characters constitute a delimiter through {@link ExtendedBufferedReader#peek(char[])}.\n     *\n     * @param ch\n     *             the current character.\n     * @return true if the next characters constitute a delimiter.\n     * @throws IOException If an I/O error occurs.\n     */\n    boolean isDelimiter(final int ch) throws IOException {\n        isLastTokenDelimiter = false;\n        if (ch != delimiter[0]) {\n            return false;\n        }\n        if (delimiter.length == 1) {\n            isLastTokenDelimiter = true;\n            return true;\n        }\n        reader.peek(delimiterBuf);\n        for (int i = 0; i < delimiterBuf.length; i++) {\n            if (delimiterBuf[i] != delimiter[i + 1]) {\n                return false;\n            }\n        }\n        final int count = reader.read(delimiterBuf, 0, delimiterBuf.length);\n        isLastTokenDelimiter = count != EOF;\n        return isLastTokenDelimiter;\n    }",
    "importString": "",
    "lineNum": 26,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/Lexer.java"
  },
  {
    "symbolName": "isEscapeDelimiter()",
    "sourceCode": "/**\n     * Tests if the next characters constitute a escape delimiter through {@link ExtendedBufferedReader#peek(char[])}.\n     *\n     * For example, for delimiter \"[|]\" and escape '!', return true if the next characters constitute \"![!|!]\".\n     *\n     * @return true if the next characters constitute an escape delimiter.\n     * @throws IOException If an I/O error occurs.\n     */\n    boolean isEscapeDelimiter() throws IOException {\n        reader.peek(escapeDelimiterBuf);\n        if (escapeDelimiterBuf[0] != delimiter[0]) {\n            return false;\n        }\n        for (int i = 1; i < delimiter.length; i++) {\n            if (escapeDelimiterBuf[2 * i] != delimiter[i] || escapeDelimiterBuf[2 * i - 1] != escape) {\n                return false;\n            }\n        }\n        final int count = reader.read(escapeDelimiterBuf, 0, escapeDelimiterBuf.length);\n        return count != EOF;\n    }",
    "importString": "",
    "lineNum": 20,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/Lexer.java"
  },
  {
    "symbolName": "nextToken(Token)",
    "sourceCode": "/**\n     * Returns the next token.\n     * <p>\n     * A token corresponds to a term, a record change or an end-of-file indicator.\n     * </p>\n     *\n     * @param token an existing Token object to reuse. The caller is responsible for initializing the Token.\n     * @return the next token found.\n     * @throws IOException  on stream access error.\n     * @throws CSVException Thrown on invalid input.\n     */\n    Token nextToken(final Token token) throws IOException {\n        // Get the last read char (required for empty line detection)\n        int lastChar = reader.getLastChar();\n        // read the next char and set eol\n        int c = reader.read();\n        // Note: The following call will swallow LF if c == CR. But we don't need to know if the last char was CR or LF - they are equivalent here.\n        boolean eol = readEndOfLine(c);\n        // empty line detection: eol AND (last char was EOL or beginning)\n        if (ignoreEmptyLines) {\n            while (eol && isStartOfLine(lastChar)) {\n                // Go on char ahead ...\n                lastChar = c;\n                c = reader.read();\n                eol = readEndOfLine(c);\n                // reached the end of the file without any content (empty line at the end)\n                if (isEndOfFile(c)) {\n                    token.type = Token.Type.EOF;\n                    // don't set token.isReady here because no content\n                    return token;\n                }\n            }\n        }\n        // Did we reach EOF during the last iteration already? EOF\n        if (isEndOfFile(lastChar) || !isLastTokenDelimiter && isEndOfFile(c)) {\n            token.type = Token.Type.EOF;\n            // don't set token.isReady here because no content\n            return token;\n        }\n        if (isStartOfLine(lastChar) && isCommentStart(c)) {\n            final String line = reader.readLine();\n            if (line == null) {\n                token.type = Token.Type.EOF;\n                // don't set token.isReady here because no content\n                return token;\n            }\n            final String comment = line.trim();\n            token.content.append(comment);\n            token.type = Token.Type.COMMENT;\n            return token;\n        }\n        // Important: make sure a new char gets consumed in each iteration\n        while (token.type == Token.Type.INVALID) {\n            // ignore whitespaces at beginning of a token\n            if (ignoreSurroundingSpaces) {\n                while (Character.isWhitespace((char) c) && !isDelimiter(c) && !eol) {\n                    c = reader.read();\n                    eol = readEndOfLine(c);\n                }\n            }\n            // ok, start of token reached: encapsulated, or token\n            if (isDelimiter(c)) {\n                // empty token return TOKEN(\"\")\n                token.type = Token.Type.TOKEN;\n            } else if (eol) {\n                // empty token return EORECORD(\"\")\n                // noop: token.content.append(\"\");\n                token.type = Token.Type.EORECORD;\n            } else if (isQuoteChar(c)) {\n                // consume encapsulated token\n                parseEncapsulatedToken(token);\n            } else if (isEndOfFile(c)) {\n                // end of file return EOF()\n                // noop: token.content.append(\"\");\n                token.type = Token.Type.EOF;\n                token.isReady = true; // there is data at EOF\n            } else {\n                // next token must be a simple token\n                // add removed blanks when not ignoring whitespace chars...\n                parseSimpleToken(token, c);\n            }\n        }\n        return token;\n    }",
    "importString": "",
    "lineNum": 83,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/Lexer.java"
  },
  {
    "symbolName": "parseEncapsulatedToken(Token)",
    "sourceCode": "/**\n     * Parses an encapsulated token.\n     * <p>\n     * Encapsulated tokens are surrounded by the given encapsulating string. The encapsulator itself might be included\n     * in the token using a doubling syntax (as \"\", '') or using escaping (as in \\\", \\'). Whitespaces before and after\n     * an encapsulated token is ignored. The token is finished when one of the following conditions becomes true:\n     * </p>\n     * <ul>\n     * <li>An unescaped encapsulator has been reached and is followed by optional whitespace then:</li>\n     * <ul>\n     * <li>delimiter (TOKEN)</li>\n     * <li>end of line (EORECORD)</li>\n     * </ul>\n     * <li>end of stream has been reached (EOF)</li> </ul>\n     *\n     * @param token\n     *            the current token\n     * @return a valid token object\n     * @throws IOException\n     *             Thrown when in an invalid state: EOF before closing encapsulator or invalid character before\n     *             delimiter or EOL.\n     * @throws CSVException Thrown on invalid input.\n     */\n    private Token parseEncapsulatedToken(final Token token) throws IOException {\n        token.isQuoted = true;\n        // Save current line number in case needed for IOE\n        final long startLineNumber = getCurrentLineNumber();\n        int c;\n        while (true) {\n            c = reader.read();\n\n            if (isQuoteChar(c)) {\n                if (isQuoteChar(reader.peek())) {\n                    // double or escaped encapsulator -> add single encapsulator to token\n                    c = reader.read();\n                    token.content.append((char) c);\n                } else {\n                    // token finish mark (encapsulator) reached: ignore whitespace till delimiter\n                    while (true) {\n                        c = reader.read();\n                        if (isDelimiter(c)) {\n                            token.type = Token.Type.TOKEN;\n                            return token;\n                        }\n                        if (isEndOfFile(c)) {\n                            token.type = Token.Type.EOF;\n                            token.isReady = true; // There is data at EOF\n                            return token;\n                        }\n                        if (readEndOfLine(c)) {\n                            token.type = Token.Type.EORECORD;\n                            return token;\n                        }\n                        if (trailingData) {\n                            token.content.append((char) c);\n                        } else if (!Character.isWhitespace((char) c)) {\n                            // error invalid char between token and next delimiter\n                            throw new CSVException(\"Invalid character between encapsulated token and delimiter at line: %,d, position: %,d\",\n                                    getCurrentLineNumber(), getCharacterPosition());\n                        }\n                    }\n                }\n            } else if (isEscape(c)) {\n                appendNextEscapedCharacterToToken(token);\n            } else if (isEndOfFile(c)) {\n                if (lenientEof) {\n                    token.type = Token.Type.EOF;\n                    token.isReady = true; // There is data at EOF\n                    return token;\n                }\n                // error condition (end of file before end of token)\n                throw new CSVException(\"(startline %,d) EOF reached before encapsulated token finished\", startLineNumber);\n            } else {\n                // consume character\n                token.content.append((char) c);\n            }\n        }\n    }",
    "importString": "",
    "lineNum": 77,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/Lexer.java"
  },
  {
    "symbolName": "parseSimpleToken(Token, int)",
    "sourceCode": "/**\n     * Parses a simple token.\n     * <p>\n     * Simple tokens are tokens that are not surrounded by encapsulators. A simple token might contain escaped delimiters (as \\, or \\;). The token is finished\n     * when one of the following conditions becomes true:\n     * </p>\n     * <ul>\n     * <li>The end of line has been reached (EORECORD)</li>\n     * <li>The end of stream has been reached (EOF)</li>\n     * <li>An unescaped delimiter has been reached (TOKEN)</li>\n     * </ul>\n     *\n     * @param token the current token\n     * @param ch     the current character\n     * @return the filled token\n     * @throws IOException  on stream access error\n     * @throws CSVException Thrown on invalid input.\n     */\n    private Token parseSimpleToken(final Token token, final int ch) throws IOException {\n        // Faster to use while(true)+break than while(token.type == INVALID)\n        int cur = ch;\n        while (true) {\n            if (readEndOfLine(cur)) {\n                token.type = Token.Type.EORECORD;\n                break;\n            }\n            if (isEndOfFile(cur)) {\n                token.type = Token.Type.EOF;\n                token.isReady = true; // There is data at EOF\n                break;\n            }\n            if (isDelimiter(cur)) {\n                token.type = Token.Type.TOKEN;\n                break;\n            }\n            // continue\n            if (isEscape(cur)) {\n                appendNextEscapedCharacterToToken(token);\n            } else {\n                token.content.append((char) cur);\n            }\n            cur = reader.read(); // continue\n        }\n\n        if (ignoreSurroundingSpaces) {\n            trimTrailingSpaces(token.content);\n        }\n\n        return token;\n    }",
    "importString": "",
    "lineNum": 49,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/Lexer.java"
  },
  {
    "symbolName": "readEndOfLine(int)",
    "sourceCode": "/**\n     * Greedily accepts \\n, \\r and \\r\\n This checker consumes silently the second control-character...\n     *\n     * @return true if the given or next character is a line-terminator\n     */\n    boolean readEndOfLine(final int ch) throws IOException {\n        // check if we have \\r\\n...\n        int cur = ch;\n        if (cur == Constants.CR && reader.peek() == Constants.LF) {\n            // note: does not change ch outside of this method!\n            cur = reader.read();\n            // Save the EOL state\n            if (firstEol == null) {\n                this.firstEol = Constants.CRLF;\n            }\n        }\n        // save EOL state here.\n        if (firstEol == null) {\n            if (cur == Constants.LF) {\n                this.firstEol = LF_STRING;\n            } else if (cur == Constants.CR) {\n                this.firstEol = CR_STRING;\n            }\n        }\n\n        return cur == Constants.LF || cur == Constants.CR;\n    }",
    "importString": "",
    "lineNum": 26,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/Lexer.java"
  },
  {
    "symbolName": "readEscape()",
    "sourceCode": "// TODO escape handling needs more work\n    /**\n     * Handle an escape sequence. The current character must be the escape character. On return, the next character is available by calling\n     * {@link ExtendedBufferedReader#getLastChar()} on the input stream.\n     *\n     * @return the unescaped character (as an int) or {@link IOUtils#EOF} if char following the escape is invalid.\n     * @throws IOException  if there is a problem reading the stream or the end of stream is detected: the escape character is not allowed at end of stream\n     * @throws CSVException Thrown on invalid input.\n     */\n    int readEscape() throws IOException {\n        // the escape char has just been read (normally a backslash)\n        final int ch = reader.read();\n        switch (ch) {\n        case 'r':\n            return Constants.CR;\n        case 'n':\n            return Constants.LF;\n        case 't':\n            return Constants.TAB;\n        case 'b':\n            return Constants.BACKSPACE;\n        case 'f':\n            return Constants.FF;\n        case Constants.CR:\n        case Constants.LF:\n        case Constants.FF: // TODO is this correct?\n        case Constants.TAB: // TODO is this correct? Do tabs need to be escaped?\n        case Constants.BACKSPACE: // TODO is this correct?\n            return ch;\n        case EOF:\n            throw new CSVException(\"EOF while processing escape sequence\");\n        default:\n            // Now check for meta-characters\n            if (isMetaChar(ch)) {\n                return ch;\n            }\n            // indicate unexpected char - available from in.getLastChar()\n            return EOF;\n        }\n    }",
    "importString": "",
    "lineNum": 39,
    "relativeDocumentPath": "src/main/java/org/apache/commons/csv/Lexer.java"
  }
]