/**
 * Script to run the Go test pipeline on Cobra project tests
 * 
 * This script demonstrates running the complete pipeline on Go test files
 * generated by AI tools, which may include both test files and source files
 * mixed together.
 * 
 * Usage:
 *   npm run compile
 *   node out/test/manual/run_cobra_tests.js
 */

import * as path from 'path';
import * as fs from 'fs';
import { runPipeline } from '../../ut_runner/runner';
import { getConfigInstance } from '../../config';

async function main() {
  console.log('='.repeat(80));
  console.log('Cobra Go Tests - Pipeline Execution');
  console.log('='.repeat(80));
  
  // Configuration
  const testsDir = '/LSPRAG/experiments/data/main_result/cobra/lsprag/1/deepseek-chat/results/final-clean';
  const outputDir = '/LSPRAG/experiments/data/main_result/cobra/lsprag/1/deepseek-chat/results/pipeline-output';
  const testFileMapPath = '/LSPRAG/experiments/config/cobra_test_file_map.json';
  const projectPath = '/LSPRAG/experiments/data/main_result/cobra/lsprag/1/deepseek-chat/results/final-clean';
  
  console.log(`\nConfiguration:`);
  console.log(`  Tests Directory: ${testsDir}`);
  console.log(`  Output Directory: ${outputDir}`);
  console.log(`  Test File Map: ${testFileMapPath}`);
  console.log(`  Project Path: ${projectPath}`);
  
  // Verify inputs exist
  console.log('\nVerifying inputs...');
  
  if (!fs.existsSync(testsDir)) {
    console.error(`✗ Tests directory not found: ${testsDir}`);
    process.exit(1);
  }
  console.log('✓ Tests directory exists');
  
  if (!fs.existsSync(testFileMapPath)) {
    console.error(`✗ Test file map not found: ${testFileMapPath}`);
    process.exit(1);
  }
  console.log('✓ Test file map exists');
  
  // Check for go.mod
  const goModPath = path.join(testsDir, 'go.mod');
  if (!fs.existsSync(goModPath)) {
    console.error(`✗ go.mod not found in test directory`);
    process.exit(1);
  }
  console.log('✓ go.mod exists');
  
  // Check Go toolchain
  try {
    const { execSync } = require('child_process');
    const version = execSync('go version', { encoding: 'utf8', timeout: 5000 });
    console.log(`✓ Go toolchain detected: ${version.trim()}`);
  } catch (error) {
    console.error('✗ Go toolchain not found. Please install Go to run this test.');
    process.exit(1);
  }
  
  // Count test files
  const { execSync } = require('child_process');
  const testFileCount = execSync(
    `find "${testsDir}" -name "*_test.go" | wc -l`,
    { encoding: 'utf8' }
  ).trim();
  const sourceFileCount = execSync(
    `find "${testsDir}" -name "*.go" -not -name "*_test.go" | wc -l`,
    { encoding: 'utf8' }
  ).trim();
  
  console.log(`\nDirectory contents:`);
  console.log(`  Test files (*_test.go): ${testFileCount}`);
  console.log(`  Source files (*.go): ${sourceFileCount}`);
  console.log(`  Total Go files: ${parseInt(testFileCount) + parseInt(sourceFileCount)}`);
  
  // Create output directory
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
    console.log(`\n✓ Created output directory: ${outputDir}`);
  } else {
    console.log(`\n✓ Output directory exists: ${outputDir}`);
  }
  
  // Update config
  const currentConfig = {
    workspace: projectPath,
  };
  getConfigInstance().updateConfig({
    ...currentConfig
  });
  console.log(`✓ Updated config with workspace: ${projectPath}`);
  
  console.log('\n' + '='.repeat(80));
  console.log('Starting Pipeline Execution');
  console.log('='.repeat(80));
  console.log('\nNote: The Collector will automatically filter test files (*_test.go)');
  console.log('      and ignore source files (*.go) in the directory.\n');
  
  try {
    const startTime = Date.now();
    
    // Run the pipeline
    await runPipeline(testsDir, outputDir, testFileMapPath, {
      language: 'go',
      include: ['*_test.go'], // Only collect test files
      timeoutSec: 30, // 30 second timeout per test
      jobs: 4, // Run 4 tests concurrently
    });
    
    const duration = Date.now() - startTime;
    
    console.log('\n' + '='.repeat(80));
    console.log('Pipeline Execution Complete');
    console.log('='.repeat(80));
    console.log(`\nTotal execution time: ${duration}ms (${(duration / 1000).toFixed(2)}s)`);
    
    // Verify outputs
    console.log('\n' + '='.repeat(80));
    console.log('Verifying Outputs');
    console.log('='.repeat(80));
    
    const logsDir = path.join(outputDir, 'logs');
    const junitDir = path.join(outputDir, 'junit');
    const testResultsJson = path.join(outputDir, 'test_results.json');
    const fileResultsJson = path.join(outputDir, 'file_results.json');
    const unifiedLog = path.join(outputDir, 'pytest_output.log');
    
    let allPassed = true;
    
    // Check directories
    if (fs.existsSync(logsDir)) {
      const logFiles = fs.readdirSync(logsDir).filter(f => f.endsWith('.log'));
      console.log(`✓ Logs directory: ${logFiles.length} log files`);
    } else {
      console.error('✗ Logs directory not found');
      allPassed = false;
    }
    
    if (fs.existsSync(junitDir)) {
      console.log(`✓ JUnit directory exists`);
    } else {
      console.warn('⚠ JUnit directory not found (optional for Go)');
    }
    
    // Check JSON outputs
    if (fs.existsSync(testResultsJson)) {
      const testResults = JSON.parse(fs.readFileSync(testResultsJson, 'utf8'));
      const testCount = Object.keys(testResults.tests || {}).length;
      console.log(`✓ test_results.json: ${testCount} test cases`);
      
      // Show sample test results
      if (testCount > 0) {
        const sampleTests = Object.entries(testResults.tests || {}).slice(0, 3);
        console.log(`\n  Sample test results:`);
        sampleTests.forEach(([name, result]: [string, any]) => {
          console.log(`    - ${name}: ${result.status}`);
        });
        if (testCount > 3) {
          console.log(`    ... and ${testCount - 3} more tests`);
        }
      }
    } else {
      console.error('✗ test_results.json not found');
      allPassed = false;
    }
    
    if (fs.existsSync(fileResultsJson)) {
      const fileResults = JSON.parse(fs.readFileSync(fileResultsJson, 'utf8'));
      const fileCount = Object.keys(fileResults.files || {}).length;
      console.log(`✓ file_results.json: ${fileCount} test files`);
      
      // Show statistics
      if (fileCount > 0) {
        let totalPassed = 0;
        let totalFailed = 0;
        let totalErrors = 0;
        
        Object.values(fileResults.files || {}).forEach((file: any) => {
          totalPassed += file.counts['Passed'] || 0;
          totalFailed += file.counts['Assertion Errors'] || 0;
          Object.entries(file.counts).forEach(([key, value]) => {
            if (key !== 'Passed' && key !== 'Assertion Errors') {
              totalErrors += (value as number) || 0;
            }
          });
        });
        
        console.log(`\n  Overall Statistics:`);
        console.log(`    Passed: ${totalPassed}`);
        console.log(`    Failed: ${totalFailed}`);
        console.log(`    Errors: ${totalErrors}`);
        console.log(`    Total: ${totalPassed + totalFailed + totalErrors}`);
        
        if (totalPassed + totalFailed + totalErrors > 0) {
          const successRate = (totalPassed / (totalPassed + totalFailed + totalErrors) * 100).toFixed(1);
          console.log(`    Success Rate: ${successRate}%`);
        }
      }
    } else {
      console.error('✗ file_results.json not found');
      allPassed = false;
    }
    
    if (fs.existsSync(unifiedLog)) {
      const logSize = fs.statSync(unifiedLog).size;
      console.log(`✓ Unified log: ${(logSize / 1024).toFixed(2)} KB`);
    } else {
      console.warn('⚠ Unified log not found');
    }
    
    console.log('\n' + '='.repeat(80));
    if (allPassed) {
      console.log('✓ ALL CHECKS PASSED');
      console.log('='.repeat(80));
      console.log(`\nResults are available in: ${outputDir}`);
      console.log('\nKey files:');
      console.log(`  - ${testResultsJson}`);
      console.log(`  - ${fileResultsJson}`);
      console.log(`  - ${logsDir}/`);
    } else {
      console.log('✗ SOME CHECKS FAILED');
      console.log('='.repeat(80));
      console.log('\nPlease review the errors above.');
      process.exit(1);
    }
    
  } catch (error) {
    console.error('\n' + '='.repeat(80));
    console.error('Pipeline Execution Failed');
    console.error('='.repeat(80));
    console.error('\nError:', error);
    if (error instanceof Error && error.stack) {
      console.error('\nStack trace:');
      console.error(error.stack);
    }
    process.exit(1);
  }
}

main().catch(error => {
  console.error('Fatal error:', error);
  process.exit(1);
});

